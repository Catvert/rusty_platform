/* automatically generated by rust-bindgen */

pub const __LINUX__: ::std::os::raw::c_uint = 1;
pub const HAVE_STDARG_H: ::std::os::raw::c_uint = 1;
pub const HAVE_STDDEF_H: ::std::os::raw::c_uint = 1;
pub const HAVE_STDINT_H: ::std::os::raw::c_uint = 1;
pub const HAVE_GCC_SYNC_LOCK_TEST_AND_SET: ::std::os::raw::c_uint = 1;
pub const SDL_AUDIO_DRIVER_DUMMY: ::std::os::raw::c_uint = 1;
pub const SDL_JOYSTICK_DISABLED: ::std::os::raw::c_uint = 1;
pub const SDL_HAPTIC_DISABLED: ::std::os::raw::c_uint = 1;
pub const SDL_LOADSO_DISABLED: ::std::os::raw::c_uint = 1;
pub const SDL_THREADS_DISABLED: ::std::os::raw::c_uint = 1;
pub const SDL_TIMERS_DISABLED: ::std::os::raw::c_uint = 1;
pub const SDL_VIDEO_DRIVER_DUMMY: ::std::os::raw::c_uint = 1;
pub const SDL_FILESYSTEM_DUMMY: ::std::os::raw::c_uint = 1;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201706;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 26;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __HAVE_GENERIC_SELECTION: ::std::os::raw::c_uint = 1;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: ::std::os::raw::c_uint = 0;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const _BITS_STDINT_INTN_H: ::std::os::raw::c_uint = 1;
pub const _BITS_STDINT_UINTN_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const SDL_PRIs64: &'static [u8; 3usize] = b"ld\x00";
pub const SDL_PRIu64: &'static [u8; 3usize] = b"lu\x00";
pub const SDL_PRIx64: &'static [u8; 3usize] = b"lx\x00";
pub const SDL_PRIX64: &'static [u8; 3usize] = b"lX\x00";
pub const M_PI: f64 = 3.141592653589793;
pub const SDL_ASSERT_LEVEL: ::std::os::raw::c_uint = 2;
pub const SDL_NULL_WHILE_LOOP_CONDITION: ::std::os::raw::c_uint = 0;
pub const SDL_LIL_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const SDL_BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _BITS_UINTN_IDENTITY_H: ::std::os::raw::c_uint = 1;
pub const SDL_BYTEORDER: ::std::os::raw::c_uint = 1234;
pub const SDL_MUTEX_TIMEDOUT: ::std::os::raw::c_uint = 1;
pub const SDL_RWOPS_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const SDL_RWOPS_WINFILE: ::std::os::raw::c_uint = 1;
pub const SDL_RWOPS_STDFILE: ::std::os::raw::c_uint = 2;
pub const SDL_RWOPS_JNIFILE: ::std::os::raw::c_uint = 3;
pub const SDL_RWOPS_MEMORY: ::std::os::raw::c_uint = 4;
pub const SDL_RWOPS_MEMORY_RO: ::std::os::raw::c_uint = 5;
pub const RW_SEEK_SET: ::std::os::raw::c_uint = 0;
pub const RW_SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const RW_SEEK_END: ::std::os::raw::c_uint = 2;
pub const SDL_AUDIO_MASK_BITSIZE: ::std::os::raw::c_uint = 255;
pub const SDL_AUDIO_MASK_DATATYPE: ::std::os::raw::c_uint = 256;
pub const SDL_AUDIO_MASK_ENDIAN: ::std::os::raw::c_uint = 4096;
pub const SDL_AUDIO_MASK_SIGNED: ::std::os::raw::c_uint = 32768;
pub const AUDIO_U8: ::std::os::raw::c_uint = 8;
pub const AUDIO_S8: ::std::os::raw::c_uint = 32776;
pub const AUDIO_U16LSB: ::std::os::raw::c_uint = 16;
pub const AUDIO_S16LSB: ::std::os::raw::c_uint = 32784;
pub const AUDIO_U16MSB: ::std::os::raw::c_uint = 4112;
pub const AUDIO_S16MSB: ::std::os::raw::c_uint = 36880;
pub const AUDIO_U16: ::std::os::raw::c_uint = 16;
pub const AUDIO_S16: ::std::os::raw::c_uint = 32784;
pub const AUDIO_S32LSB: ::std::os::raw::c_uint = 32800;
pub const AUDIO_S32MSB: ::std::os::raw::c_uint = 36896;
pub const AUDIO_S32: ::std::os::raw::c_uint = 32800;
pub const AUDIO_F32LSB: ::std::os::raw::c_uint = 33056;
pub const AUDIO_F32MSB: ::std::os::raw::c_uint = 37152;
pub const AUDIO_F32: ::std::os::raw::c_uint = 33056;
pub const AUDIO_U16SYS: ::std::os::raw::c_uint = 16;
pub const AUDIO_S16SYS: ::std::os::raw::c_uint = 32784;
pub const AUDIO_S32SYS: ::std::os::raw::c_uint = 32800;
pub const AUDIO_F32SYS: ::std::os::raw::c_uint = 33056;
pub const SDL_AUDIO_ALLOW_FREQUENCY_CHANGE: ::std::os::raw::c_uint = 1;
pub const SDL_AUDIO_ALLOW_FORMAT_CHANGE: ::std::os::raw::c_uint = 2;
pub const SDL_AUDIO_ALLOW_CHANNELS_CHANGE: ::std::os::raw::c_uint = 4;
pub const SDL_AUDIO_ALLOW_ANY_CHANGE: ::std::os::raw::c_uint = 7;
pub const SDL_AUDIOCVT_MAX_FILTERS: ::std::os::raw::c_uint = 9;
pub const SDL_MIX_MAXVOLUME: ::std::os::raw::c_uint = 128;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const __HAVE_FLOAT128: ::std::os::raw::c_uint = 0;
pub const __HAVE_DISTINCT_FLOAT128: ::std::os::raw::c_uint = 0;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const __sigset_t_defined: ::std::os::raw::c_uint = 1;
pub const __timeval_defined: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: ::std::os::raw::c_uint = 1;
pub const _THREAD_SHARED_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _MM_HINT_T0: ::std::os::raw::c_uint = 3;
pub const _MM_HINT_T1: ::std::os::raw::c_uint = 2;
pub const _MM_HINT_T2: ::std::os::raw::c_uint = 1;
pub const _MM_HINT_NTA: ::std::os::raw::c_uint = 0;
pub const _MM_EXCEPT_INVALID: ::std::os::raw::c_uint = 1;
pub const _MM_EXCEPT_DENORM: ::std::os::raw::c_uint = 2;
pub const _MM_EXCEPT_DIV_ZERO: ::std::os::raw::c_uint = 4;
pub const _MM_EXCEPT_OVERFLOW: ::std::os::raw::c_uint = 8;
pub const _MM_EXCEPT_UNDERFLOW: ::std::os::raw::c_uint = 16;
pub const _MM_EXCEPT_INEXACT: ::std::os::raw::c_uint = 32;
pub const _MM_EXCEPT_MASK: ::std::os::raw::c_uint = 63;
pub const _MM_MASK_INVALID: ::std::os::raw::c_uint = 128;
pub const _MM_MASK_DENORM: ::std::os::raw::c_uint = 256;
pub const _MM_MASK_DIV_ZERO: ::std::os::raw::c_uint = 512;
pub const _MM_MASK_OVERFLOW: ::std::os::raw::c_uint = 1024;
pub const _MM_MASK_UNDERFLOW: ::std::os::raw::c_uint = 2048;
pub const _MM_MASK_INEXACT: ::std::os::raw::c_uint = 4096;
pub const _MM_MASK_MASK: ::std::os::raw::c_uint = 8064;
pub const _MM_ROUND_NEAREST: ::std::os::raw::c_uint = 0;
pub const _MM_ROUND_DOWN: ::std::os::raw::c_uint = 8192;
pub const _MM_ROUND_UP: ::std::os::raw::c_uint = 16384;
pub const _MM_ROUND_TOWARD_ZERO: ::std::os::raw::c_uint = 24576;
pub const _MM_ROUND_MASK: ::std::os::raw::c_uint = 24576;
pub const _MM_FLUSH_ZERO_MASK: ::std::os::raw::c_uint = 32768;
pub const _MM_FLUSH_ZERO_ON: ::std::os::raw::c_uint = 32768;
pub const _MM_FLUSH_ZERO_OFF: ::std::os::raw::c_uint = 0;
pub const _MM_DENORMALS_ZERO_ON: ::std::os::raw::c_uint = 64;
pub const _MM_DENORMALS_ZERO_OFF: ::std::os::raw::c_uint = 0;
pub const _MM_DENORMALS_ZERO_MASK: ::std::os::raw::c_uint = 64;
pub const SDL_CACHELINE_SIZE: ::std::os::raw::c_uint = 128;
pub const SDL_ALPHA_OPAQUE: ::std::os::raw::c_uint = 255;
pub const SDL_ALPHA_TRANSPARENT: ::std::os::raw::c_uint = 0;
pub const SDL_SWSURFACE: ::std::os::raw::c_uint = 0;
pub const SDL_PREALLOC: ::std::os::raw::c_uint = 1;
pub const SDL_RLEACCEL: ::std::os::raw::c_uint = 2;
pub const SDL_DONTFREE: ::std::os::raw::c_uint = 4;
pub const SDL_WINDOWPOS_UNDEFINED_MASK: ::std::os::raw::c_uint = 536805376;
pub const SDL_WINDOWPOS_CENTERED_MASK: ::std::os::raw::c_uint = 805240832;
pub const SDLK_SCANCODE_MASK: ::std::os::raw::c_uint = 1073741824;
pub const SDL_BUTTON_LEFT: ::std::os::raw::c_uint = 1;
pub const SDL_BUTTON_MIDDLE: ::std::os::raw::c_uint = 2;
pub const SDL_BUTTON_RIGHT: ::std::os::raw::c_uint = 3;
pub const SDL_BUTTON_X1: ::std::os::raw::c_uint = 4;
pub const SDL_BUTTON_X2: ::std::os::raw::c_uint = 5;
pub const SDL_JOYSTICK_AXIS_MAX: ::std::os::raw::c_uint = 32767;
pub const SDL_JOYSTICK_AXIS_MIN: ::std::os::raw::c_int = -32768;
pub const SDL_HAT_CENTERED: ::std::os::raw::c_uint = 0;
pub const SDL_HAT_UP: ::std::os::raw::c_uint = 1;
pub const SDL_HAT_RIGHT: ::std::os::raw::c_uint = 2;
pub const SDL_HAT_DOWN: ::std::os::raw::c_uint = 4;
pub const SDL_HAT_LEFT: ::std::os::raw::c_uint = 8;
pub const SDL_HAT_RIGHTUP: ::std::os::raw::c_uint = 3;
pub const SDL_HAT_RIGHTDOWN: ::std::os::raw::c_uint = 6;
pub const SDL_HAT_LEFTUP: ::std::os::raw::c_uint = 9;
pub const SDL_HAT_LEFTDOWN: ::std::os::raw::c_uint = 12;
pub const SDL_RELEASED: ::std::os::raw::c_uint = 0;
pub const SDL_PRESSED: ::std::os::raw::c_uint = 1;
pub const SDL_TEXTEDITINGEVENT_TEXT_SIZE: ::std::os::raw::c_uint = 32;
pub const SDL_TEXTINPUTEVENT_TEXT_SIZE: ::std::os::raw::c_uint = 32;
pub const SDL_QUERY: ::std::os::raw::c_int = -1;
pub const SDL_IGNORE: ::std::os::raw::c_uint = 0;
pub const SDL_DISABLE: ::std::os::raw::c_uint = 0;
pub const SDL_ENABLE: ::std::os::raw::c_uint = 1;
pub const SDL_HAPTIC_CONSTANT: ::std::os::raw::c_uint = 1;
pub const SDL_HAPTIC_SINE: ::std::os::raw::c_uint = 2;
pub const SDL_HAPTIC_LEFTRIGHT: ::std::os::raw::c_uint = 4;
pub const SDL_HAPTIC_TRIANGLE: ::std::os::raw::c_uint = 8;
pub const SDL_HAPTIC_SAWTOOTHUP: ::std::os::raw::c_uint = 16;
pub const SDL_HAPTIC_SAWTOOTHDOWN: ::std::os::raw::c_uint = 32;
pub const SDL_HAPTIC_RAMP: ::std::os::raw::c_uint = 64;
pub const SDL_HAPTIC_SPRING: ::std::os::raw::c_uint = 128;
pub const SDL_HAPTIC_DAMPER: ::std::os::raw::c_uint = 256;
pub const SDL_HAPTIC_INERTIA: ::std::os::raw::c_uint = 512;
pub const SDL_HAPTIC_FRICTION: ::std::os::raw::c_uint = 1024;
pub const SDL_HAPTIC_CUSTOM: ::std::os::raw::c_uint = 2048;
pub const SDL_HAPTIC_GAIN: ::std::os::raw::c_uint = 4096;
pub const SDL_HAPTIC_AUTOCENTER: ::std::os::raw::c_uint = 8192;
pub const SDL_HAPTIC_STATUS: ::std::os::raw::c_uint = 16384;
pub const SDL_HAPTIC_PAUSE: ::std::os::raw::c_uint = 32768;
pub const SDL_HAPTIC_POLAR: ::std::os::raw::c_uint = 0;
pub const SDL_HAPTIC_CARTESIAN: ::std::os::raw::c_uint = 1;
pub const SDL_HAPTIC_SPHERICAL: ::std::os::raw::c_uint = 2;
pub const SDL_HAPTIC_INFINITY: ::std::os::raw::c_uint = 4294967295;
pub const SDL_HINT_FRAMEBUFFER_ACCELERATION: &'static [u8; 29usize] =
    b"SDL_FRAMEBUFFER_ACCELERATION\x00";
pub const SDL_HINT_RENDER_DRIVER: &'static [u8; 18usize] =
    b"SDL_RENDER_DRIVER\x00";
pub const SDL_HINT_RENDER_OPENGL_SHADERS: &'static [u8; 26usize] =
    b"SDL_RENDER_OPENGL_SHADERS\x00";
pub const SDL_HINT_RENDER_DIRECT3D_THREADSAFE: &'static [u8; 31usize] =
    b"SDL_RENDER_DIRECT3D_THREADSAFE\x00";
pub const SDL_HINT_RENDER_DIRECT3D11_DEBUG: &'static [u8; 28usize] =
    b"SDL_RENDER_DIRECT3D11_DEBUG\x00";
pub const SDL_HINT_RENDER_LOGICAL_SIZE_MODE: &'static [u8; 29usize] =
    b"SDL_RENDER_LOGICAL_SIZE_MODE\x00";
pub const SDL_HINT_RENDER_SCALE_QUALITY: &'static [u8; 25usize] =
    b"SDL_RENDER_SCALE_QUALITY\x00";
pub const SDL_HINT_RENDER_VSYNC: &'static [u8; 17usize] =
    b"SDL_RENDER_VSYNC\x00";
pub const SDL_HINT_VIDEO_ALLOW_SCREENSAVER: &'static [u8; 28usize] =
    b"SDL_VIDEO_ALLOW_SCREENSAVER\x00";
pub const SDL_HINT_VIDEO_X11_XVIDMODE: &'static [u8; 23usize] =
    b"SDL_VIDEO_X11_XVIDMODE\x00";
pub const SDL_HINT_VIDEO_X11_XINERAMA: &'static [u8; 23usize] =
    b"SDL_VIDEO_X11_XINERAMA\x00";
pub const SDL_HINT_VIDEO_X11_XRANDR: &'static [u8; 21usize] =
    b"SDL_VIDEO_X11_XRANDR\x00";
pub const SDL_HINT_VIDEO_X11_NET_WM_PING: &'static [u8; 26usize] =
    b"SDL_VIDEO_X11_NET_WM_PING\x00";
pub const SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN:
          &'static [u8; 44usize] =
    b"SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN\x00";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON: &'static [u8; 29usize] =
    b"SDL_WINDOWS_INTRESOURCE_ICON\x00";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL: &'static [u8; 35usize] =
    b"SDL_WINDOWS_INTRESOURCE_ICON_SMALL\x00";
pub const SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP: &'static [u8; 31usize] =
    b"SDL_WINDOWS_ENABLE_MESSAGELOOP\x00";
pub const SDL_HINT_GRAB_KEYBOARD: &'static [u8; 18usize] =
    b"SDL_GRAB_KEYBOARD\x00";
pub const SDL_HINT_MOUSE_NORMAL_SPEED_SCALE: &'static [u8; 29usize] =
    b"SDL_MOUSE_NORMAL_SPEED_SCALE\x00";
pub const SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE: &'static [u8; 31usize] =
    b"SDL_MOUSE_RELATIVE_SPEED_SCALE\x00";
pub const SDL_HINT_MOUSE_RELATIVE_MODE_WARP: &'static [u8; 29usize] =
    b"SDL_MOUSE_RELATIVE_MODE_WARP\x00";
pub const SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH: &'static [u8; 29usize] =
    b"SDL_MOUSE_FOCUS_CLICKTHROUGH\x00";
pub const SDL_HINT_TOUCH_MOUSE_EVENTS: &'static [u8; 23usize] =
    b"SDL_TOUCH_MOUSE_EVENTS\x00";
pub const SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS: &'static [u8; 33usize] =
    b"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\x00";
pub const SDL_HINT_IDLE_TIMER_DISABLED: &'static [u8; 28usize] =
    b"SDL_IOS_IDLE_TIMER_DISABLED\x00";
pub const SDL_HINT_ORIENTATIONS: &'static [u8; 21usize] =
    b"SDL_IOS_ORIENTATIONS\x00";
pub const SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS: &'static [u8; 34usize] =
    b"SDL_APPLE_TV_CONTROLLER_UI_EVENTS\x00";
pub const SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION: &'static [u8; 35usize] =
    b"SDL_APPLE_TV_REMOTE_ALLOW_ROTATION\x00";
pub const SDL_HINT_ACCELEROMETER_AS_JOYSTICK: &'static [u8; 30usize] =
    b"SDL_ACCELEROMETER_AS_JOYSTICK\x00";
pub const SDL_HINT_XINPUT_ENABLED: &'static [u8; 19usize] =
    b"SDL_XINPUT_ENABLED\x00";
pub const SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING: &'static [u8; 36usize] =
    b"SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING\x00";
pub const SDL_HINT_GAMECONTROLLERCONFIG: &'static [u8; 25usize] =
    b"SDL_GAMECONTROLLERCONFIG\x00";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES: &'static [u8; 34usize] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES\x00";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT:
          &'static [u8; 41usize] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT\x00";
pub const SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS: &'static [u8; 37usize] =
    b"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\x00";
pub const SDL_HINT_ALLOW_TOPMOST: &'static [u8; 18usize] =
    b"SDL_ALLOW_TOPMOST\x00";
pub const SDL_HINT_TIMER_RESOLUTION: &'static [u8; 21usize] =
    b"SDL_TIMER_RESOLUTION\x00";
pub const SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION: &'static [u8; 34usize] =
    b"SDL_QTWAYLAND_CONTENT_ORIENTATION\x00";
pub const SDL_HINT_QTWAYLAND_WINDOW_FLAGS: &'static [u8; 27usize] =
    b"SDL_QTWAYLAND_WINDOW_FLAGS\x00";
pub const SDL_HINT_THREAD_STACK_SIZE: &'static [u8; 22usize] =
    b"SDL_THREAD_STACK_SIZE\x00";
pub const SDL_HINT_VIDEO_HIGHDPI_DISABLED: &'static [u8; 27usize] =
    b"SDL_VIDEO_HIGHDPI_DISABLED\x00";
pub const SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK: &'static [u8; 39usize]
          =
    b"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\x00";
pub const SDL_HINT_VIDEO_WIN_D3DCOMPILER: &'static [u8; 26usize] =
    b"SDL_VIDEO_WIN_D3DCOMPILER\x00";
pub const SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT: &'static [u8; 36usize] =
    b"SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT\x00";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_URL: &'static [u8; 29usize] =
    b"SDL_WINRT_PRIVACY_POLICY_URL\x00";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_LABEL: &'static [u8; 31usize] =
    b"SDL_WINRT_PRIVACY_POLICY_LABEL\x00";
pub const SDL_HINT_WINRT_HANDLE_BACK_BUTTON: &'static [u8; 29usize] =
    b"SDL_WINRT_HANDLE_BACK_BUTTON\x00";
pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES: &'static [u8; 32usize] =
    b"SDL_VIDEO_MAC_FULLSCREEN_SPACES\x00";
pub const SDL_HINT_MAC_BACKGROUND_APP: &'static [u8; 23usize] =
    b"SDL_MAC_BACKGROUND_APP\x00";
pub const SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION:
          &'static [u8; 44usize] =
    b"SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION\x00";
pub const SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION:
          &'static [u8; 45usize] =
    b"SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION\x00";
pub const SDL_HINT_IME_INTERNAL_EDITING: &'static [u8; 25usize] =
    b"SDL_IME_INTERNAL_EDITING\x00";
pub const SDL_HINT_ANDROID_SEPARATE_MOUSE_AND_TOUCH: &'static [u8; 37usize] =
    b"SDL_ANDROID_SEPARATE_MOUSE_AND_TOUCH\x00";
pub const SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT: &'static [u8; 32usize] =
    b"SDL_EMSCRIPTEN_KEYBOARD_ELEMENT\x00";
pub const SDL_HINT_NO_SIGNAL_HANDLERS: &'static [u8; 23usize] =
    b"SDL_NO_SIGNAL_HANDLERS\x00";
pub const SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4: &'static [u8; 31usize] =
    b"SDL_WINDOWS_NO_CLOSE_ON_ALT_F4\x00";
pub const SDL_HINT_BMP_SAVE_LEGACY_FORMAT: &'static [u8; 27usize] =
    b"SDL_BMP_SAVE_LEGACY_FORMAT\x00";
pub const SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING: &'static [u8; 34usize] =
    b"SDL_WINDOWS_DISABLE_THREAD_NAMING\x00";
pub const SDL_HINT_RPI_VIDEO_LAYER: &'static [u8; 20usize] =
    b"SDL_RPI_VIDEO_LAYER\x00";
pub const SDL_HINT_OPENGL_ES_DRIVER: &'static [u8; 21usize] =
    b"SDL_OPENGL_ES_DRIVER\x00";
pub const SDL_HINT_AUDIO_RESAMPLING_MODE: &'static [u8; 26usize] =
    b"SDL_AUDIO_RESAMPLING_MODE\x00";
pub const SDL_HINT_AUDIO_CATEGORY: &'static [u8; 19usize] =
    b"SDL_AUDIO_CATEGORY\x00";
pub const SDL_MAX_LOG_MESSAGE: ::std::os::raw::c_uint = 4096;
pub const SDL_NONSHAPEABLE_WINDOW: ::std::os::raw::c_int = -1;
pub const SDL_INVALID_SHAPE_ARGUMENT: ::std::os::raw::c_int = -2;
pub const SDL_WINDOW_LACKS_SHAPE: ::std::os::raw::c_int = -3;
pub const SDL_MAJOR_VERSION: ::std::os::raw::c_uint = 2;
pub const SDL_MINOR_VERSION: ::std::os::raw::c_uint = 0;
pub const SDL_PATCHLEVEL: ::std::os::raw::c_uint = 6;
pub const SDL_INIT_TIMER: ::std::os::raw::c_uint = 1;
pub const SDL_INIT_AUDIO: ::std::os::raw::c_uint = 16;
pub const SDL_INIT_VIDEO: ::std::os::raw::c_uint = 32;
pub const SDL_INIT_JOYSTICK: ::std::os::raw::c_uint = 512;
pub const SDL_INIT_HAPTIC: ::std::os::raw::c_uint = 4096;
pub const SDL_INIT_GAMECONTROLLER: ::std::os::raw::c_uint = 8192;
pub const SDL_INIT_EVENTS: ::std::os::raw::c_uint = 16384;
pub const SDL_INIT_NOPARACHUTE: ::std::os::raw::c_uint = 1048576;
pub const SDL_INIT_EVERYTHING: ::std::os::raw::c_uint = 29233;
extern "C" {
    /// \brief Gets the name of the platform.
    pub fn SDL_GetPlatform() -> *const ::std::os::raw::c_char;
}
pub type wchar_t = ::std::os::raw::c_int;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_bool { SDL_FALSE = 0, SDL_TRUE = 1, }
/// \brief A signed 8-bit integer type.
pub type Sint8 = i8;
/// \brief An unsigned 8-bit integer type.
pub type Uint8 = u8;
/// \brief A signed 16-bit integer type.
pub type Sint16 = i16;
/// \brief An unsigned 16-bit integer type.
pub type Uint16 = u16;
/// \brief A signed 32-bit integer type.
pub type Sint32 = i32;
/// \brief An unsigned 32-bit integer type.
pub type Uint32 = u32;
/// \brief A signed 64-bit integer type.
pub type Sint64 = i64;
/// \brief An unsigned 64-bit integer type.
pub type Uint64 = u64;
pub type SDL_compile_time_assert_uint8 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_sint8 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_uint16 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_sint16 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_uint32 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_sint32 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_uint64 = [::std::os::raw::c_int; 1usize];
pub type SDL_compile_time_assert_sint64 = [::std::os::raw::c_int; 1usize];
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_DUMMY_ENUM { DUMMY_ENUM_VALUE = 0, }
pub type SDL_compile_time_assert_enum = [::std::os::raw::c_int; 1usize];
extern "C" {
    pub fn SDL_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_calloc(nmemb: usize, size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_realloc(mem: *mut ::std::os::raw::c_void, size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_free(mem: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn SDL_getenv(name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_setenv(name: *const ::std::os::raw::c_char,
                      value: *const ::std::os::raw::c_char,
                      overwrite: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_qsort(base: *mut ::std::os::raw::c_void, nmemb: usize,
                     size: usize,
                     compare:
                         ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *const ::std::os::raw::c_void,
                                                                    arg2:
                                                                        *const ::std::os::raw::c_void)
                                                   -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn SDL_abs(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_isdigit(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_isspace(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_toupper(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_tolower(x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_memset(dst: *mut ::std::os::raw::c_void,
                      c: ::std::os::raw::c_int, len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_memcpy(dst: *mut ::std::os::raw::c_void,
                      src: *const ::std::os::raw::c_void, len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_memmove(dst: *mut ::std::os::raw::c_void,
                       src: *const ::std::os::raw::c_void, len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_memcmp(s1: *const ::std::os::raw::c_void,
                      s2: *const ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_wcslen(wstr: *const wchar_t) -> usize;
}
extern "C" {
    pub fn SDL_wcslcpy(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn SDL_wcslcat(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn SDL_wcscmp(str1: *const wchar_t, str2: *const wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_strlen(str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn SDL_strlcpy(dst: *mut ::std::os::raw::c_char,
                       src: *const ::std::os::raw::c_char, maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn SDL_utf8strlcpy(dst: *mut ::std::os::raw::c_char,
                           src: *const ::std::os::raw::c_char,
                           dst_bytes: usize) -> usize;
}
extern "C" {
    pub fn SDL_strlcat(dst: *mut ::std::os::raw::c_char,
                       src: *const ::std::os::raw::c_char, maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn SDL_strdup(str: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strrev(str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strupr(str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strlwr(str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strchr(str: *const ::std::os::raw::c_char,
                      c: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strrchr(str: *const ::std::os::raw::c_char,
                       c: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_strstr(haystack: *const ::std::os::raw::c_char,
                      needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_utf8strlen(str: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn SDL_itoa(value: ::std::os::raw::c_int,
                    str: *mut ::std::os::raw::c_char,
                    radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_uitoa(value: ::std::os::raw::c_uint,
                     str: *mut ::std::os::raw::c_char,
                     radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ltoa(value: ::std::os::raw::c_long,
                    str: *mut ::std::os::raw::c_char,
                    radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ultoa(value: ::std::os::raw::c_ulong,
                     str: *mut ::std::os::raw::c_char,
                     radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_lltoa(value: Sint64, str: *mut ::std::os::raw::c_char,
                     radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ulltoa(value: Uint64, str: *mut ::std::os::raw::c_char,
                      radix: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_atoi(str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_atof(str: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn SDL_strtol(str: *const ::std::os::raw::c_char,
                      endp: *mut *mut ::std::os::raw::c_char,
                      base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn SDL_strtoul(str: *const ::std::os::raw::c_char,
                       endp: *mut *mut ::std::os::raw::c_char,
                       base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn SDL_strtoll(str: *const ::std::os::raw::c_char,
                       endp: *mut *mut ::std::os::raw::c_char,
                       base: ::std::os::raw::c_int) -> Sint64;
}
extern "C" {
    pub fn SDL_strtoull(str: *const ::std::os::raw::c_char,
                        endp: *mut *mut ::std::os::raw::c_char,
                        base: ::std::os::raw::c_int) -> Uint64;
}
extern "C" {
    pub fn SDL_strtod(str: *const ::std::os::raw::c_char,
                      endp: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn SDL_strcmp(str1: *const ::std::os::raw::c_char,
                      str2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_strncmp(str1: *const ::std::os::raw::c_char,
                       str2: *const ::std::os::raw::c_char, maxlen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_strcasecmp(str1: *const ::std::os::raw::c_char,
                          str2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_strncasecmp(str1: *const ::std::os::raw::c_char,
                           str2: *const ::std::os::raw::c_char, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_sscanf(text: *const ::std::os::raw::c_char,
                      fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_vsscanf(text: *const ::std::os::raw::c_char,
                       fmt: *const ::std::os::raw::c_char,
                       ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_snprintf(text: *mut ::std::os::raw::c_char, maxlen: usize,
                        fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_vsnprintf(text: *mut ::std::os::raw::c_char, maxlen: usize,
                         fmt: *const ::std::os::raw::c_char,
                         ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_acos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_asin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_atan(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_atan2(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_ceil(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_copysign(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_cos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_cosf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_fabs(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_floor(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_log(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_pow(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_scalbn(x: f64, n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn SDL_sin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_sinf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_sqrt(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_sqrtf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_tan(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_tanf(x: f32) -> f32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_iconv_t {
    _unused: [u8; 0],
}
pub type SDL_iconv_t = *mut _SDL_iconv_t;
extern "C" {
    pub fn SDL_iconv_open(tocode: *const ::std::os::raw::c_char,
                          fromcode: *const ::std::os::raw::c_char)
     -> SDL_iconv_t;
}
extern "C" {
    pub fn SDL_iconv_close(cd: SDL_iconv_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_iconv(cd: SDL_iconv_t,
                     inbuf: *mut *const ::std::os::raw::c_char,
                     inbytesleft: *mut usize,
                     outbuf: *mut *mut ::std::os::raw::c_char,
                     outbytesleft: *mut usize) -> usize;
}
extern "C" {
    /// This function converts a string between encodings in one pass, returning a
/// string that must be freed with SDL_free() or NULL on error.
    pub fn SDL_iconv_string(tocode: *const ::std::os::raw::c_char,
                            fromcode: *const ::std::os::raw::c_char,
                            inbuf: *const ::std::os::raw::c_char,
                            inbytesleft: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// The prototype for the application's main() function
    pub fn SDL_main(argc: ::std::os::raw::c_int,
                    argv: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// This is called by the real SDL main function to let the rest of the
/// library know that initialization was done properly.
///
/// Calling this yourself without knowing what you're doing can cause
/// crashes and hard to diagnose problems with your application.
    pub fn SDL_SetMainReady();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_AssertState {
    SDL_ASSERTION_RETRY = 0,
    SDL_ASSERTION_BREAK = 1,
    SDL_ASSERTION_ABORT = 2,
    SDL_ASSERTION_IGNORE = 3,
    SDL_ASSERTION_ALWAYS_IGNORE = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_AssertData {
    pub always_ignore: ::std::os::raw::c_int,
    pub trigger_count: ::std::os::raw::c_uint,
    pub condition: *const ::std::os::raw::c_char,
    pub filename: *const ::std::os::raw::c_char,
    pub linenum: ::std::os::raw::c_int,
    pub function: *const ::std::os::raw::c_char,
    pub next: *const SDL_AssertData,
}
#[test]
fn bindgen_test_layout_SDL_AssertData() {
    assert_eq!(::std::mem::size_of::<SDL_AssertData>() , 48usize , concat ! (
               "Size of: " , stringify ! ( SDL_AssertData ) ));
    assert_eq! (::std::mem::align_of::<SDL_AssertData>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SDL_AssertData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AssertData ) ) . always_ignore as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AssertData ) , "::"
                , stringify ! ( always_ignore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AssertData ) ) . trigger_count as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AssertData ) , "::"
                , stringify ! ( trigger_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AssertData ) ) . condition as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AssertData ) , "::"
                , stringify ! ( condition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AssertData ) ) . filename as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AssertData ) , "::"
                , stringify ! ( filename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AssertData ) ) . linenum as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AssertData ) , "::"
                , stringify ! ( linenum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AssertData ) ) . function as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AssertData ) , "::"
                , stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AssertData ) ) . next as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AssertData ) , "::"
                , stringify ! ( next ) ));
}
impl Clone for SDL_AssertData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn SDL_ReportAssertion(arg1: *mut SDL_AssertData,
                               arg2: *const ::std::os::raw::c_char,
                               arg3: *const ::std::os::raw::c_char,
                               arg4: ::std::os::raw::c_int)
     -> SDL_AssertState;
}
pub type SDL_AssertionHandler =
    ::std::option::Option<unsafe extern "C" fn(data: *const SDL_AssertData,
                                               userdata:
                                                   *mut ::std::os::raw::c_void)
                              -> SDL_AssertState>;
extern "C" {
    /// \brief Set an application-defined assertion handler.
///
/// This allows an app to show its own assertion UI and/or force the
/// response to an assertion failure. If the app doesn't provide this, SDL
/// will try to do the right thing, popping up a system-specific GUI dialog,
/// and probably minimizing any fullscreen windows.
///
/// This callback may fire from any thread, but it runs wrapped in a mutex, so
/// it will only fire from one thread at a time.
///
/// Setting the callback to NULL restores SDL's original internal handler.
///
/// This callback is NOT reset to SDL's internal handler upon SDL_Quit()!
///
/// Return SDL_AssertState value of how to handle the assertion failure.
///
/// \param handler Callback function, called when an assertion fails.
/// \param userdata A pointer passed to the callback as-is.
    pub fn SDL_SetAssertionHandler(handler: SDL_AssertionHandler,
                                   userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// \brief Get the default assertion handler.
///
/// This returns the function pointer that is called by default when an
/// assertion is triggered. This is an internal function provided by SDL,
/// that is used for assertions when SDL_SetAssertionHandler() hasn't been
/// used to provide a different function.
///
/// \return The default SDL_AssertionHandler that is called when an assert triggers.
    pub fn SDL_GetDefaultAssertionHandler() -> SDL_AssertionHandler;
}
extern "C" {
    /// \brief Get the current assertion handler.
///
/// This returns the function pointer that is called when an assertion is
/// triggered. This is either the value last passed to
/// SDL_SetAssertionHandler(), or if no application-specified function is
/// set, is equivalent to calling SDL_GetDefaultAssertionHandler().
///
/// \param puserdata Pointer to a void*, which will store the "userdata"
/// pointer that was passed to SDL_SetAssertionHandler().
/// This value will always be NULL for the default handler.
/// If you don't care about this data, it is safe to pass
/// a NULL pointer to this function to ignore it.
/// \return The SDL_AssertionHandler that is called when an assert triggers.
    pub fn SDL_GetAssertionHandler(puserdata:
                                       *mut *mut ::std::os::raw::c_void)
     -> SDL_AssertionHandler;
}
extern "C" {
    /// \brief Get a list of all assertion failures.
///
/// Get all assertions triggered since last call to SDL_ResetAssertionReport(),
/// or the start of the program.
///
/// The proper way to examine this data looks something like this:
///
/// <code>
/// const SDL_AssertData *item = SDL_GetAssertionReport();
/// while (item) {
/// printf("'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\n",
/// item->condition, item->function, item->filename,
/// item->linenum, item->trigger_count,
/// item->always_ignore ? "yes" : "no");
/// item = item->next;
/// }
/// </code>
///
/// \return List of all assertions.
/// \sa SDL_ResetAssertionReport
    pub fn SDL_GetAssertionReport() -> *const SDL_AssertData;
}
extern "C" {
    /// \brief Reset the list of all assertion failures.
///
/// Reset list of all assertions triggered.
///
/// \sa SDL_GetAssertionReport
    pub fn SDL_ResetAssertionReport();
}
pub type SDL_SpinLock = ::std::os::raw::c_int;
extern "C" {
    /// \brief Try to lock a spin lock by setting it to a non-zero value.
///
/// \param lock Points to the lock.
///
/// \return SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already held.
    pub fn SDL_AtomicTryLock(lock: *mut SDL_SpinLock) -> SDL_bool;
}
extern "C" {
    /// \brief Lock a spin lock by setting it to a non-zero value.
///
/// \param lock Points to the lock.
    pub fn SDL_AtomicLock(lock: *mut SDL_SpinLock);
}
extern "C" {
    /// \brief Unlock a spin lock by setting it to 0. Always returns immediately
///
/// \param lock Points to the lock.
    pub fn SDL_AtomicUnlock(lock: *mut SDL_SpinLock);
}
extern "C" {
    /// Memory barriers are designed to prevent reads and writes from being
/// reordered by the compiler and being seen out of order on multi-core CPUs.
///
/// A typical pattern would be for thread A to write some data and a flag,
/// and for thread B to read the flag and get the data. In this case you
/// would insert a release barrier between writing the data and the flag,
/// guaranteeing that the data write completes no later than the flag is
/// written, and you would insert an acquire barrier between reading the
/// flag and reading the data, to ensure that all the reads associated
/// with the flag have completed.
///
/// In this pattern you should always see a release barrier paired with
/// an acquire barrier and you should gate the data reads/writes with a
/// single flag variable.
///
/// For more information on these semantics, take a look at the blog post:
/// http://preshing.com/20120913/acquire-and-release-semantics
    pub fn SDL_MemoryBarrierReleaseFunction();
}
extern "C" {
    pub fn SDL_MemoryBarrierAcquireFunction();
}
/// \brief A type representing an atomic integer value.  It is a struct
/// so people don't accidentally use numeric operations on it.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_atomic_t {
    pub value: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_atomic_t() {
    assert_eq!(::std::mem::size_of::<SDL_atomic_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( SDL_atomic_t ) ));
    assert_eq! (::std::mem::align_of::<SDL_atomic_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( SDL_atomic_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_atomic_t ) ) . value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_atomic_t ) , "::" ,
                stringify ! ( value ) ));
}
impl Clone for SDL_atomic_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// \brief Set an atomic variable to a new value if it is currently an old value.
///
/// \return SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.
///
/// \note If you don't know what this function is for, you shouldn't use it!
    pub fn SDL_AtomicCAS(a: *mut SDL_atomic_t, oldval: ::std::os::raw::c_int,
                         newval: ::std::os::raw::c_int) -> SDL_bool;
}
extern "C" {
    /// \brief Set an atomic variable to a value.
///
/// \return The previous value of the atomic variable.
    pub fn SDL_AtomicSet(a: *mut SDL_atomic_t, v: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the value of an atomic variable
    pub fn SDL_AtomicGet(a: *mut SDL_atomic_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Add to an atomic variable.
///
/// \return The previous value of the atomic variable.
///
/// \note This same style can be used for any number operation
    pub fn SDL_AtomicAdd(a: *mut SDL_atomic_t, v: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set a pointer to a new value if it is currently an old value.
///
/// \return SDL_TRUE if the pointer was set, SDL_FALSE otherwise.
///
/// \note If you don't know what this function is for, you shouldn't use it!
    pub fn SDL_AtomicCASPtr(a: *mut *mut ::std::os::raw::c_void,
                            oldval: *mut ::std::os::raw::c_void,
                            newval: *mut ::std::os::raw::c_void) -> SDL_bool;
}
extern "C" {
    /// \brief Set a pointer to a value atomically.
///
/// \return The previous value of the pointer.
    pub fn SDL_AtomicSetPtr(a: *mut *mut ::std::os::raw::c_void,
                            v: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// \brief Get the value of a pointer atomically.
    pub fn SDL_AtomicGetPtr(a: *mut *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_SetError(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_GetError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_ClearError();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_errorcode {
    SDL_ENOMEM = 0,
    SDL_EFREAD = 1,
    SDL_EFWRITE = 2,
    SDL_EFSEEK = 3,
    SDL_UNSUPPORTED = 4,
    SDL_LASTERROR = 5,
}
extern "C" {
    pub fn SDL_Error(code: SDL_errorcode) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_mutex {
    _unused: [u8; 0],
}
extern "C" {
    /// Create a mutex, initialized unlocked.
    pub fn SDL_CreateMutex() -> *mut SDL_mutex;
}
extern "C" {
    pub fn SDL_LockMutex(mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Try to lock the mutex
///
/// \return 0, SDL_MUTEX_TIMEDOUT, or -1 on error
    pub fn SDL_TryLockMutex(mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_UnlockMutex(mutex: *mut SDL_mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Destroy a mutex.
    pub fn SDL_DestroyMutex(mutex: *mut SDL_mutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_semaphore {
    _unused: [u8; 0],
}
pub type SDL_sem = SDL_semaphore;
extern "C" {
    /// Create a semaphore, initialized with value, returns NULL on failure.
    pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_sem;
}
extern "C" {
    /// Destroy a semaphore.
    pub fn SDL_DestroySemaphore(sem: *mut SDL_sem);
}
extern "C" {
    /// This function suspends the calling thread until the semaphore pointed
/// to by \c sem has a positive count. It then atomically decreases the
/// semaphore count.
    pub fn SDL_SemWait(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Non-blocking variant of SDL_SemWait().
///
/// \return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait would
/// block, and -1 on error.
    pub fn SDL_SemTryWait(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Variant of SDL_SemWait() with a timeout in milliseconds.
///
/// \return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait does not
/// succeed in the allotted time, and -1 on error.
///
/// \warning On some platforms this function is implemented by looping with a
/// delay of 1 ms, and so should be avoided if possible.
    pub fn SDL_SemWaitTimeout(sem: *mut SDL_sem, ms: Uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Atomically increases the semaphore's count (not blocking).
///
/// \return 0, or -1 on error.
    pub fn SDL_SemPost(sem: *mut SDL_sem) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Returns the current count of the semaphore.
    pub fn SDL_SemValue(sem: *mut SDL_sem) -> Uint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_cond {
    _unused: [u8; 0],
}
extern "C" {
    /// Create a condition variable.
///
/// Typical use of condition variables:
///
/// Thread A:
/// SDL_LockMutex(lock);
/// while ( ! condition ) {
/// SDL_CondWait(cond, lock);
/// }
/// SDL_UnlockMutex(lock);
///
/// Thread B:
/// SDL_LockMutex(lock);
/// ...
/// condition = true;
/// ...
/// SDL_CondSignal(cond);
/// SDL_UnlockMutex(lock);
///
/// There is some discussion whether to signal the condition variable
/// with the mutex locked or not.  There is some potential performance
/// benefit to unlocking first on some platforms, but there are some
/// potential race conditions depending on how your code is structured.
///
/// In general it's safer to signal the condition variable while the
/// mutex is locked.
    pub fn SDL_CreateCond() -> *mut SDL_cond;
}
extern "C" {
    /// Destroy a condition variable.
    pub fn SDL_DestroyCond(cond: *mut SDL_cond);
}
extern "C" {
    /// Restart one of the threads that are waiting on the condition variable.
///
/// \return 0 or -1 on error.
    pub fn SDL_CondSignal(cond: *mut SDL_cond) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Restart all threads that are waiting on the condition variable.
///
/// \return 0 or -1 on error.
    pub fn SDL_CondBroadcast(cond: *mut SDL_cond) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Wait on the condition variable, unlocking the provided mutex.
///
/// \warning The mutex must be locked before entering this function!
///
/// The mutex is re-locked once the condition variable is signaled.
///
/// \return 0 when it is signaled, or -1 on error.
    pub fn SDL_CondWait(cond: *mut SDL_cond, mutex: *mut SDL_mutex)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Waits for at most \c ms milliseconds, and returns 0 if the condition
/// variable is signaled, ::SDL_MUTEX_TIMEDOUT if the condition is not
/// signaled in the allotted time, and -1 on error.
///
/// \warning On some platforms this function is implemented by looping with a
/// delay of 1 ms, and so should be avoided if possible.
    pub fn SDL_CondWaitTimeout(cond: *mut SDL_cond, mutex: *mut SDL_mutex,
                               ms: Uint32) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Thread {
    _unused: [u8; 0],
}
pub type SDL_threadID = ::std::os::raw::c_ulong;
pub type SDL_TLSID = ::std::os::raw::c_uint;
#[repr(u32)]
/// The SDL thread priority.
///
/// \note On many systems you require special privileges to set high priority.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_ThreadPriority {
    SDL_THREAD_PRIORITY_LOW = 0,
    SDL_THREAD_PRIORITY_NORMAL = 1,
    SDL_THREAD_PRIORITY_HIGH = 2,
}
/// The function passed to SDL_CreateThread().
/// It is passed a void* user context parameter and returns an int.
pub type SDL_ThreadFunction =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// Create a thread.
///
/// Thread naming is a little complicated: Most systems have very small
/// limits for the string length (Haiku has 32 bytes, Linux currently has 16,
/// Visual C++ 6.0 has nine!), and possibly other arbitrary rules. You'll
/// have to see what happens with your system's debugger. The name should be
/// UTF-8 (but using the naming limits of C identifiers is a better bet).
/// There are no requirements for thread naming conventions, so long as the
/// string is null-terminated UTF-8, but these guidelines are helpful in
/// choosing a name:
///
/// http://stackoverflow.com/questions/149932/naming-conventions-for-threads
///
/// If a system imposes requirements, SDL will try to munge the string for
/// it (truncate, etc), but the original string contents will be available
/// from SDL_GetThreadName().
    pub fn SDL_CreateThread(fn_: SDL_ThreadFunction,
                            name: *const ::std::os::raw::c_char,
                            data: *mut ::std::os::raw::c_void)
     -> *mut SDL_Thread;
}
extern "C" {
    /// Get the thread name, as it was specified in SDL_CreateThread().
/// This function returns a pointer to a UTF-8 string that names the
/// specified thread, or NULL if it doesn't have a name. This is internal
/// memory, not to be free()'d by the caller, and remains valid until the
/// specified thread is cleaned up by SDL_WaitThread().
    pub fn SDL_GetThreadName(thread: *mut SDL_Thread)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the thread identifier for the current thread.
    pub fn SDL_ThreadID() -> SDL_threadID;
}
extern "C" {
    /// Get the thread identifier for the specified thread.
///
/// Equivalent to SDL_ThreadID() if the specified thread is NULL.
    pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> SDL_threadID;
}
extern "C" {
    /// Set the priority for the current thread
    pub fn SDL_SetThreadPriority(priority: SDL_ThreadPriority)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Wait for a thread to finish. Threads that haven't been detached will
/// remain (as a "zombie") until this function cleans them up. Not doing so
/// is a resource leak.
///
/// Once a thread has been cleaned up through this function, the SDL_Thread
/// that references it becomes invalid and should not be referenced again.
/// As such, only one thread may call SDL_WaitThread() on another.
///
/// The return code for the thread function is placed in the area
/// pointed to by \c status, if \c status is not NULL.
///
/// You may not wait on a thread that has been used in a call to
/// SDL_DetachThread(). Use either that function or this one, but not
/// both, or behavior is undefined.
///
/// It is safe to pass NULL to this function; it is a no-op.
    pub fn SDL_WaitThread(thread: *mut SDL_Thread,
                          status: *mut ::std::os::raw::c_int);
}
extern "C" {
    /// A thread may be "detached" to signify that it should not remain until
/// another thread has called SDL_WaitThread() on it. Detaching a thread
/// is useful for long-running threads that nothing needs to synchronize
/// with or further manage. When a detached thread is done, it simply
/// goes away.
///
/// There is no way to recover the return code of a detached thread. If you
/// need this, don't detach the thread and instead use SDL_WaitThread().
///
/// Once a thread is detached, you should usually assume the SDL_Thread isn't
/// safe to reference again, as it will become invalid immediately upon
/// the detached thread's exit, instead of remaining until someone has called
/// SDL_WaitThread() to finally clean it up. As such, don't detach the same
/// thread more than once.
///
/// If a thread has already exited when passed to SDL_DetachThread(), it will
/// stop waiting for a call to SDL_WaitThread() and clean up immediately.
/// It is not safe to detach a thread that might be used with SDL_WaitThread().
///
/// You may not call SDL_WaitThread() on a thread that has been detached.
/// Use either that function or this one, but not both, or behavior is
/// undefined.
///
/// It is safe to pass NULL to this function; it is a no-op.
    pub fn SDL_DetachThread(thread: *mut SDL_Thread);
}
extern "C" {
    /// \brief Create an identifier that is globally visible to all threads but refers to data that is thread-specific.
///
/// \return The newly created thread local storage identifier, or 0 on error
///
/// \code
/// static SDL_SpinLock tls_lock;
/// static SDL_TLSID thread_local_storage;
///
/// void SetMyThreadData(void *value)
/// {
/// if (!thread_local_storage) {
/// SDL_AtomicLock(&tls_lock);
/// if (!thread_local_storage) {
/// thread_local_storage = SDL_TLSCreate();
/// }
/// SDL_AtomicUnlock(&tls_lock);
/// }
/// SDL_TLSSet(thread_local_storage, value, 0);
/// }
///
/// void *GetMyThreadData(void)
/// {
/// return SDL_TLSGet(thread_local_storage);
/// }
/// \endcode
///
/// \sa SDL_TLSGet()
/// \sa SDL_TLSSet()
    pub fn SDL_TLSCreate() -> SDL_TLSID;
}
extern "C" {
    /// \brief Get the value associated with a thread local storage ID for the current thread.
///
/// \param id The thread local storage ID
///
/// \return The value associated with the ID for the current thread, or NULL if no value has been set.
///
/// \sa SDL_TLSCreate()
/// \sa SDL_TLSSet()
    pub fn SDL_TLSGet(id: SDL_TLSID) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// \brief Set the value associated with a thread local storage ID for the current thread.
///
/// \param id The thread local storage ID
/// \param value The value to associate with the ID for the current thread
/// \param destructor A function called when the thread exits, to free the value.
///
/// \return 0 on success, -1 on error
///
/// \sa SDL_TLSCreate()
/// \sa SDL_TLSGet()
    pub fn SDL_TLSSet(id: SDL_TLSID, value: *const ::std::os::raw::c_void,
                      destructor:
                          ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_void)>)
     -> ::std::os::raw::c_int;
}
/// This is the read/write operation structure -- very basic.
#[repr(C)]
#[derive(Copy)]
pub struct SDL_RWops {
    /// Return the size of the file in this rwops, or -1 if unknown
    pub size: ::std::option::Option<unsafe extern "C" fn(context:
                                                             *mut SDL_RWops)
                                        -> Sint64>,
    /// Seek to \c offset relative to \c whence, one of stdio's whence values:
    /// RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END
    ///
    /// \return the final offset in the data stream, or -1 on error.
    pub seek: ::std::option::Option<unsafe extern "C" fn(context:
                                                             *mut SDL_RWops,
                                                         offset: Sint64,
                                                         whence:
                                                             ::std::os::raw::c_int)
                                        -> Sint64>,
    /// Read up to \c maxnum objects each of size \c size from the data
    /// stream to the area pointed at by \c ptr.
    ///
    /// \return the number of objects read, or 0 at error or end of file.
    pub read: ::std::option::Option<unsafe extern "C" fn(context:
                                                             *mut SDL_RWops,
                                                         ptr:
                                                             *mut ::std::os::raw::c_void,
                                                         size: usize,
                                                         maxnum: usize)
                                        -> usize>,
    /// Write exactly \c num objects each of size \c size from the area
    /// pointed at by \c ptr to data stream.
    ///
    /// \return the number of objects written, or 0 at error or end of file.
    pub write: ::std::option::Option<unsafe extern "C" fn(context:
                                                              *mut SDL_RWops,
                                                          ptr:
                                                              *const ::std::os::raw::c_void,
                                                          size: usize,
                                                          num: usize)
                                         -> usize>,
    /// Close and free an allocated SDL_RWops structure.
    ///
    /// \return 0 if successful or -1 on write error when flushing data.
    pub close: ::std::option::Option<unsafe extern "C" fn(context:
                                                              *mut SDL_RWops)
                                         -> ::std::os::raw::c_int>,
    pub type_: Uint32,
    pub hidden: SDL_RWops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union SDL_RWops__bindgen_ty_1 {
    pub mem: SDL_RWops__bindgen_ty_1__bindgen_ty_1,
    pub unknown: SDL_RWops__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
    pub base: *mut Uint8,
    pub here: *mut Uint8,
    pub stop: *mut Uint8,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) )
                . base as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) )
                . here as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                here ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) )
                . stop as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_RWops__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                stop ) ));
}
impl Clone for SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
    pub data1: *mut ::std::os::raw::c_void,
    pub data2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               SDL_RWops__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                SDL_RWops__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops__bindgen_ty_1__bindgen_ty_2 ) )
                . data1 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_RWops__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                data1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops__bindgen_ty_1__bindgen_ty_2 ) )
                . data2 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_RWops__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                data2 ) ));
}
impl Clone for SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<SDL_RWops__bindgen_ty_1>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( SDL_RWops__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<SDL_RWops__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_RWops__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops__bindgen_ty_1 ) ) . mem as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RWops__bindgen_ty_1
                ) , "::" , stringify ! ( mem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops__bindgen_ty_1 ) ) . unknown as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RWops__bindgen_ty_1
                ) , "::" , stringify ! ( unknown ) ));
}
impl Clone for SDL_RWops__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SDL_RWops() {
    assert_eq!(::std::mem::size_of::<SDL_RWops>() , 72usize , concat ! (
               "Size of: " , stringify ! ( SDL_RWops ) ));
    assert_eq! (::std::mem::align_of::<SDL_RWops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SDL_RWops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops ) ) . size as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RWops ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops ) ) . seek as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RWops ) , "::" ,
                stringify ! ( seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops ) ) . read as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RWops ) , "::" ,
                stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops ) ) . write as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RWops ) , "::" ,
                stringify ! ( write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops ) ) . close as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RWops ) , "::" ,
                stringify ! ( close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops ) ) . type_ as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RWops ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RWops ) ) . hidden as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RWops ) , "::" ,
                stringify ! ( hidden ) ));
}
impl Clone for SDL_RWops {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn SDL_RWFromFile(file: *const ::std::os::raw::c_char,
                          mode: *const ::std::os::raw::c_char)
     -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromFP(fp: *mut ::std::os::raw::c_void, autoclose: SDL_bool)
     -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromMem(mem: *mut ::std::os::raw::c_void,
                         size: ::std::os::raw::c_int) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromConstMem(mem: *const ::std::os::raw::c_void,
                              size: ::std::os::raw::c_int) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_AllocRW() -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_FreeRW(area: *mut SDL_RWops);
}
extern "C" {
    /// Load all the data from an SDL data stream.
///
/// The data is allocated with a zero byte at the end (null terminated)
///
/// If \c datasize is not NULL, it is filled with the size of the data read.
///
/// If \c freesrc is non-zero, the stream will be closed after being read.
///
/// The data should be freed with SDL_free().
///
/// \return the data, or NULL if there was an error.
    pub fn SDL_LoadFile_RW(src: *mut SDL_RWops, datasize: *mut usize,
                           freesrc: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn SDL_ReadU8(src: *mut SDL_RWops) -> Uint8;
}
extern "C" {
    pub fn SDL_ReadLE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    pub fn SDL_ReadBE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    pub fn SDL_ReadLE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    pub fn SDL_ReadBE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    pub fn SDL_ReadLE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    pub fn SDL_ReadBE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    pub fn SDL_WriteU8(dst: *mut SDL_RWops, value: Uint8) -> usize;
}
extern "C" {
    pub fn SDL_WriteLE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
    pub fn SDL_WriteBE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
    pub fn SDL_WriteLE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
    pub fn SDL_WriteBE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
    pub fn SDL_WriteLE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
extern "C" {
    pub fn SDL_WriteBE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
/// \brief Audio format flags.
///
/// These are what the 16 bits in SDL_AudioFormat currently mean...
/// (Unspecified bits are always zero).
///
/// \verbatim
/// ++-----------------------sample is signed if set
/// ||
/// ||       ++-----------sample is bigendian if set
/// ||       ||
/// ||       ||          ++---sample is float if set
/// ||       ||          ||
/// ||       ||          || +---sample bit size---+
/// ||       ||          || |                     |
/// 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
/// \endverbatim
///
/// There are macros in SDL 2.0 and later to query these bits.
pub type SDL_AudioFormat = Uint16;
/// This function is called when the audio device needs more data.
///
/// \param userdata An application-specific parameter saved in
/// the SDL_AudioSpec structure
/// \param stream A pointer to the audio data buffer.
/// \param len    The length of that buffer in bytes.
///
/// Once the callback returns, the buffer will no longer be valid.
/// Stereo samples are stored in a LRLRLR ordering.
///
/// You can choose to avoid callbacks and use SDL_QueueAudio() instead, if
/// you like. Just open your audio device with a NULL callback.
pub type SDL_AudioCallback =
    ::std::option::Option<unsafe extern "C" fn(userdata:
                                                   *mut ::std::os::raw::c_void,
                                               stream: *mut Uint8,
                                               len: ::std::os::raw::c_int)>;
/// The calculated values in this structure are calculated by SDL_OpenAudio().
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_AudioSpec {
    /// < DSP frequency -- samples per second
    pub freq: ::std::os::raw::c_int,
    /// < Audio data format
    pub format: SDL_AudioFormat,
    /// < Number of channels: 1 mono, 2 stereo
    pub channels: Uint8,
    /// < Audio buffer silence value (calculated)
    pub silence: Uint8,
    /// < Audio buffer size in sample FRAMES (total samples divided by channel count)
    pub samples: Uint16,
    /// < Necessary for some compile environments
    pub padding: Uint16,
    /// < Audio buffer size in bytes (calculated)
    pub size: Uint32,
    /// < Callback that feeds the audio device (NULL to use SDL_QueueAudio()).
    pub callback: SDL_AudioCallback,
    /// < Userdata passed to callback (ignored for NULL callbacks).
    pub userdata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_AudioSpec() {
    assert_eq!(::std::mem::size_of::<SDL_AudioSpec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( SDL_AudioSpec ) ));
    assert_eq! (::std::mem::align_of::<SDL_AudioSpec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SDL_AudioSpec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioSpec ) ) . freq as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioSpec ) , "::"
                , stringify ! ( freq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioSpec ) ) . format as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioSpec ) , "::"
                , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioSpec ) ) . channels as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioSpec ) , "::"
                , stringify ! ( channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioSpec ) ) . silence as * const _
                as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioSpec ) , "::"
                , stringify ! ( silence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioSpec ) ) . samples as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioSpec ) , "::"
                , stringify ! ( samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioSpec ) ) . padding as * const _
                as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioSpec ) , "::"
                , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioSpec ) ) . size as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioSpec ) , "::"
                , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioSpec ) ) . callback as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioSpec ) , "::"
                , stringify ! ( callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioSpec ) ) . userdata as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioSpec ) , "::"
                , stringify ! ( userdata ) ));
}
impl Clone for SDL_AudioSpec {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct SDL_AudioCVT {
    /// < Set to 1 if conversion possible
    pub needed: ::std::os::raw::c_int,
    /// < Source audio format
    pub src_format: SDL_AudioFormat,
    /// < Target audio format
    pub dst_format: SDL_AudioFormat,
    /// < Rate conversion increment
    pub rate_incr: f64,
    /// < Buffer to hold entire audio data
    pub buf: *mut Uint8,
    /// < Length of original audio buffer
    pub len: ::std::os::raw::c_int,
    /// < Length of converted audio buffer
    pub len_cvt: ::std::os::raw::c_int,
    /// < buffer must be len*len_mult big
    pub len_mult: ::std::os::raw::c_int,
    /// < Given len, final size is len*len_ratio
    pub len_ratio: f64,
    /// < NULL-terminated list of filter functions
    pub filters: [SDL_AudioFilter; 10usize],
    /// < Current audio conversion function
    pub filter_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_AudioCVT() {
    assert_eq!(::std::mem::size_of::<SDL_AudioCVT>() , 128usize , concat ! (
               "Size of: " , stringify ! ( SDL_AudioCVT ) ));
    assert_eq! (::std::mem::align_of::<SDL_AudioCVT>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( SDL_AudioCVT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioCVT ) ) . needed as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioCVT ) , "::" ,
                stringify ! ( needed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioCVT ) ) . src_format as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioCVT ) , "::" ,
                stringify ! ( src_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioCVT ) ) . dst_format as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioCVT ) , "::" ,
                stringify ! ( dst_format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioCVT ) ) . rate_incr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioCVT ) , "::" ,
                stringify ! ( rate_incr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioCVT ) ) . buf as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioCVT ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioCVT ) ) . len as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioCVT ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioCVT ) ) . len_cvt as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioCVT ) , "::" ,
                stringify ! ( len_cvt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioCVT ) ) . len_mult as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioCVT ) , "::" ,
                stringify ! ( len_mult ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioCVT ) ) . len_ratio as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioCVT ) , "::" ,
                stringify ! ( len_ratio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioCVT ) ) . filters as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioCVT ) , "::" ,
                stringify ! ( filters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioCVT ) ) . filter_index as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioCVT ) , "::" ,
                stringify ! ( filter_index ) ));
}
impl Clone for SDL_AudioCVT {
    fn clone(&self) -> Self { *self }
}
pub type SDL_AudioFilter =
    ::std::option::Option<unsafe extern "C" fn(cvt: *mut SDL_AudioCVT,
                                               format: SDL_AudioFormat)>;
extern "C" {
    pub fn SDL_GetNumAudioDrivers() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_GetAudioDriver(index: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn SDL_AudioInit(driver_name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_AudioQuit();
}
extern "C" {
    /// This function returns the name of the current audio driver, or NULL
/// if no driver has been initialized.
    pub fn SDL_GetCurrentAudioDriver() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// This function opens the audio device with the desired parameters, and
/// returns 0 if successful, placing the actual hardware parameters in the
/// structure pointed to by \c obtained.  If \c obtained is NULL, the audio
/// data passed to the callback function will be guaranteed to be in the
/// requested format, and will be automatically converted to the hardware
/// audio format if necessary.  This function returns -1 if it failed
/// to open the audio device, or couldn't set up the audio thread.
///
/// When filling in the desired audio spec structure,
/// - \c desired->freq should be the desired audio frequency in samples-per-
/// second.
/// - \c desired->format should be the desired audio format.
/// - \c desired->samples is the desired size of the audio buffer, in
/// samples.  This number should be a power of two, and may be adjusted by
/// the audio driver to a value more suitable for the hardware.  Good values
/// seem to range between 512 and 8096 inclusive, depending on the
/// application and CPU speed.  Smaller values yield faster response time,
/// but can lead to underflow if the application is doing heavy processing
/// and cannot fill the audio buffer in time.  A stereo sample consists of
/// both right and left channels in LR ordering.
/// Note that the number of samples is directly related to time by the
/// following formula:  \code ms = (samples*1000)/freq \endcode
/// - \c desired->size is the size in bytes of the audio buffer, and is
/// calculated by SDL_OpenAudio().
/// - \c desired->silence is the value used to set the buffer to silence,
/// and is calculated by SDL_OpenAudio().
/// - \c desired->callback should be set to a function that will be called
/// when the audio device is ready for more data.  It is passed a pointer
/// to the audio buffer, and the length in bytes of the audio buffer.
/// This function usually runs in a separate thread, and so you should
/// protect data structures that it accesses by calling SDL_LockAudio()
/// and SDL_UnlockAudio() in your code. Alternately, you may pass a NULL
/// pointer here, and call SDL_QueueAudio() with some frequency, to queue
/// more audio samples to be played (or for capture devices, call
/// SDL_DequeueAudio() with some frequency, to obtain audio samples).
/// - \c desired->userdata is passed as the first parameter to your callback
/// function. If you passed a NULL callback, this value is ignored.
///
/// The audio device starts out playing silence when it's opened, and should
/// be enabled for playing by calling \c SDL_PauseAudio(0) when you are ready
/// for your audio callback function to be called.  Since the audio driver
/// may modify the requested size of the audio buffer, you should allocate
/// any local mixing buffers after you open the audio device.
    pub fn SDL_OpenAudio(desired: *mut SDL_AudioSpec,
                         obtained: *mut SDL_AudioSpec)
     -> ::std::os::raw::c_int;
}
/// SDL Audio Device IDs.
///
/// A successful call to SDL_OpenAudio() is always device id 1, and legacy
/// SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls
/// always returns devices >= 2 on success. The legacy calls are good both
/// for backwards compatibility and when you don't care about multiple,
/// specific, or capture devices.
pub type SDL_AudioDeviceID = Uint32;
extern "C" {
    /// Get the number of available devices exposed by the current driver.
/// Only valid after a successfully initializing the audio subsystem.
/// Returns -1 if an explicit list of devices can't be determined; this is
/// not an error. For example, if SDL is set up to talk to a remote audio
/// server, it can't list every one available on the Internet, but it will
/// still allow a specific host to be specified to SDL_OpenAudioDevice().
///
/// In many common cases, when this function returns a value <= 0, it can still
/// successfully open the default device (NULL for first argument of
/// SDL_OpenAudioDevice()).
    pub fn SDL_GetNumAudioDevices(iscapture: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the human-readable name of a specific audio device.
/// Must be a value between 0 and (number of audio devices-1).
/// Only valid after a successfully initializing the audio subsystem.
/// The values returned by this function reflect the latest call to
/// SDL_GetNumAudioDevices(); recall that function to redetect available
/// hardware.
///
/// The string returned by this function is UTF-8 encoded, read-only, and
/// managed internally. You are not to free it. If you need to keep the
/// string for any length of time, you should make your own copy of it, as it
/// will be invalid next time any of several other SDL functions is called.
    pub fn SDL_GetAudioDeviceName(index: ::std::os::raw::c_int,
                                  iscapture: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Open a specific audio device. Passing in a device name of NULL requests
/// the most reasonable default (and is equivalent to calling SDL_OpenAudio()).
///
/// The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but
/// some drivers allow arbitrary and driver-specific strings, such as a
/// hostname/IP address for a remote audio server, or a filename in the
/// diskaudio driver.
///
/// \return 0 on error, a valid device ID that is >= 2 on success.
///
/// SDL_OpenAudio(), unlike this function, always acts on device ID 1.
    pub fn SDL_OpenAudioDevice(device: *const ::std::os::raw::c_char,
                               iscapture: ::std::os::raw::c_int,
                               desired: *const SDL_AudioSpec,
                               obtained: *mut SDL_AudioSpec,
                               allowed_changes: ::std::os::raw::c_int)
     -> SDL_AudioDeviceID;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_AudioStatus {
    SDL_AUDIO_STOPPED = 0,
    SDL_AUDIO_PLAYING = 1,
    SDL_AUDIO_PAUSED = 2,
}
extern "C" {
    pub fn SDL_GetAudioStatus() -> SDL_AudioStatus;
}
extern "C" {
    pub fn SDL_GetAudioDeviceStatus(dev: SDL_AudioDeviceID)
     -> SDL_AudioStatus;
}
extern "C" {
    pub fn SDL_PauseAudio(pause_on: ::std::os::raw::c_int);
}
extern "C" {
    pub fn SDL_PauseAudioDevice(dev: SDL_AudioDeviceID,
                                pause_on: ::std::os::raw::c_int);
}
extern "C" {
    /// This function loads a WAVE from the data source, automatically freeing
/// that source if \c freesrc is non-zero.  For example, to load a WAVE file,
/// you could do:
/// \code
/// SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);
/// \endcode
///
/// If this function succeeds, it returns the given SDL_AudioSpec,
/// filled with the audio data format of the wave data, and sets
/// \c *audio_buf to a malloc()'d buffer containing the audio data,
/// and sets \c *audio_len to the length of that audio buffer, in bytes.
/// You need to free the audio buffer with SDL_FreeWAV() when you are
/// done with it.
///
/// This function returns NULL and sets the SDL error message if the
/// wave file cannot be opened, uses an unknown data format, or is
/// corrupt.  Currently raw and MS-ADPCM WAVE files are supported.
    pub fn SDL_LoadWAV_RW(src: *mut SDL_RWops, freesrc: ::std::os::raw::c_int,
                          spec: *mut SDL_AudioSpec,
                          audio_buf: *mut *mut Uint8, audio_len: *mut Uint32)
     -> *mut SDL_AudioSpec;
}
extern "C" {
    /// This function frees data previously allocated with SDL_LoadWAV_RW()
    pub fn SDL_FreeWAV(audio_buf: *mut Uint8);
}
extern "C" {
    /// This function takes a source format and rate and a destination format
/// and rate, and initializes the \c cvt structure with information needed
/// by SDL_ConvertAudio() to convert a buffer of audio data from one format
/// to the other. An unsupported format causes an error and -1 will be returned.
///
/// \return 0 if no conversion is needed, 1 if the audio filter is set up,
/// or -1 on error.
    pub fn SDL_BuildAudioCVT(cvt: *mut SDL_AudioCVT,
                             src_format: SDL_AudioFormat, src_channels: Uint8,
                             src_rate: ::std::os::raw::c_int,
                             dst_format: SDL_AudioFormat, dst_channels: Uint8,
                             dst_rate: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Once you have initialized the \c cvt structure using SDL_BuildAudioCVT(),
/// created an audio buffer \c cvt->buf, and filled it with \c cvt->len bytes of
/// audio data in the source format, this function will convert it in-place
/// to the desired format.
///
/// The data conversion may expand the size of the audio data, so the buffer
/// \c cvt->buf should be allocated after the \c cvt structure is initialized by
/// SDL_BuildAudioCVT(), and should be \c cvt->len*cvt->len_mult bytes long.
///
/// \return 0 on success or -1 if \c cvt->buf is NULL.
    pub fn SDL_ConvertAudio(cvt: *mut SDL_AudioCVT) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This takes two audio buffers of the playing audio format and mixes
/// them, performing addition, volume adjustment, and overflow clipping.
/// The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME
/// for full audio volume.  Note this does not change hardware volume.
/// This is provided for convenience -- you can mix your own audio data.
    pub fn SDL_MixAudio(dst: *mut Uint8, src: *const Uint8, len: Uint32,
                        volume: ::std::os::raw::c_int);
}
extern "C" {
    /// This works like SDL_MixAudio(), but you specify the audio format instead of
/// using the format of audio device 1. Thus it can be used when no audio
/// device is open at all.
    pub fn SDL_MixAudioFormat(dst: *mut Uint8, src: *const Uint8,
                              format: SDL_AudioFormat, len: Uint32,
                              volume: ::std::os::raw::c_int);
}
extern "C" {
    /// Queue more audio on non-callback devices.
///
/// (If you are looking to retrieve queued audio from a non-callback capture
/// device, you want SDL_DequeueAudio() instead. This will return -1 to
/// signify an error if you use it with capture devices.)
///
/// SDL offers two ways to feed audio to the device: you can either supply a
/// callback that SDL triggers with some frequency to obtain more audio
/// (pull method), or you can supply no callback, and then SDL will expect
/// you to supply data at regular intervals (push method) with this function.
///
/// There are no limits on the amount of data you can queue, short of
/// exhaustion of address space. Queued data will drain to the device as
/// necessary without further intervention from you. If the device needs
/// audio but there is not enough queued, it will play silence to make up
/// the difference. This means you will have skips in your audio playback
/// if you aren't routinely queueing sufficient data.
///
/// This function copies the supplied data, so you are safe to free it when
/// the function returns. This function is thread-safe, but queueing to the
/// same device from two threads at once does not promise which buffer will
/// be queued first.
///
/// You may not queue audio on a device that is using an application-supplied
/// callback; doing so returns an error. You have to use the audio callback
/// or queue audio with this function, but not both.
///
/// You should not call SDL_LockAudio() on the device before queueing; SDL
/// handles locking internally for this function.
///
/// \param dev The device ID to which we will queue audio.
/// \param data The data to queue to the device for later playback.
/// \param len The number of bytes (not samples!) to which (data) points.
/// \return zero on success, -1 on error.
///
/// \sa SDL_GetQueuedAudioSize
/// \sa SDL_ClearQueuedAudio
    pub fn SDL_QueueAudio(dev: SDL_AudioDeviceID,
                          data: *const ::std::os::raw::c_void, len: Uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Dequeue more audio on non-callback devices.
///
/// (If you are looking to queue audio for output on a non-callback playback
/// device, you want SDL_QueueAudio() instead. This will always return 0
/// if you use it with playback devices.)
///
/// SDL offers two ways to retrieve audio from a capture device: you can
/// either supply a callback that SDL triggers with some frequency as the
/// device records more audio data, (push method), or you can supply no
/// callback, and then SDL will expect you to retrieve data at regular
/// intervals (pull method) with this function.
///
/// There are no limits on the amount of data you can queue, short of
/// exhaustion of address space. Data from the device will keep queuing as
/// necessary without further intervention from you. This means you will
/// eventually run out of memory if you aren't routinely dequeueing data.
///
/// Capture devices will not queue data when paused; if you are expecting
/// to not need captured audio for some length of time, use
/// SDL_PauseAudioDevice() to stop the capture device from queueing more
/// data. This can be useful during, say, level loading times. When
/// unpaused, capture devices will start queueing data from that point,
/// having flushed any capturable data available while paused.
///
/// This function is thread-safe, but dequeueing from the same device from
/// two threads at once does not promise which thread will dequeued data
/// first.
///
/// You may not dequeue audio from a device that is using an
/// application-supplied callback; doing so returns an error. You have to use
/// the audio callback, or dequeue audio with this function, but not both.
///
/// You should not call SDL_LockAudio() on the device before queueing; SDL
/// handles locking internally for this function.
///
/// \param dev The device ID from which we will dequeue audio.
/// \param data A pointer into where audio data should be copied.
/// \param len The number of bytes (not samples!) to which (data) points.
/// \return number of bytes dequeued, which could be less than requested.
///
/// \sa SDL_GetQueuedAudioSize
/// \sa SDL_ClearQueuedAudio
    pub fn SDL_DequeueAudio(dev: SDL_AudioDeviceID,
                            data: *mut ::std::os::raw::c_void, len: Uint32)
     -> Uint32;
}
extern "C" {
    /// Get the number of bytes of still-queued audio.
///
/// For playback device:
///
/// This is the number of bytes that have been queued for playback with
/// SDL_QueueAudio(), but have not yet been sent to the hardware. This
/// number may shrink at any time, so this only informs of pending data.
///
/// Once we've sent it to the hardware, this function can not decide the
/// exact byte boundary of what has been played. It's possible that we just
/// gave the hardware several kilobytes right before you called this
/// function, but it hasn't played any of it yet, or maybe half of it, etc.
///
/// For capture devices:
///
/// This is the number of bytes that have been captured by the device and
/// are waiting for you to dequeue. This number may grow at any time, so
/// this only informs of the lower-bound of available data.
///
/// You may not queue audio on a device that is using an application-supplied
/// callback; calling this function on such a device always returns 0.
/// You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use
/// the audio callback, but not both.
///
/// You should not call SDL_LockAudio() on the device before querying; SDL
/// handles locking internally for this function.
///
/// \param dev The device ID of which we will query queued audio size.
/// \return Number of bytes (not samples!) of queued audio.
///
/// \sa SDL_QueueAudio
/// \sa SDL_ClearQueuedAudio
    pub fn SDL_GetQueuedAudioSize(dev: SDL_AudioDeviceID) -> Uint32;
}
extern "C" {
    /// Drop any queued audio data. For playback devices, this is any queued data
/// still waiting to be submitted to the hardware. For capture devices, this
/// is any data that was queued by the device that hasn't yet been dequeued by
/// the application.
///
/// Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For
/// playback devices, the hardware will start playing silence if more audio
/// isn't queued. Unpaused capture devices will start filling the queue again
/// as soon as they have more data available (which, depending on the state
/// of the hardware and the thread, could be before this function call
/// returns!).
///
/// This will not prevent playback of queued audio that's already been sent
/// to the hardware, as we can not undo that, so expect there to be some
/// fraction of a second of audio that might still be heard. This can be
/// useful if you want to, say, drop any pending music during a level change
/// in your game.
///
/// You may not queue audio on a device that is using an application-supplied
/// callback; calling this function on such a device is always a no-op.
/// You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use
/// the audio callback, but not both.
///
/// You should not call SDL_LockAudio() on the device before clearing the
/// queue; SDL handles locking internally for this function.
///
/// This function always succeeds and thus returns void.
///
/// \param dev The device ID of which to clear the audio queue.
///
/// \sa SDL_QueueAudio
/// \sa SDL_GetQueuedAudioSize
    pub fn SDL_ClearQueuedAudio(dev: SDL_AudioDeviceID);
}
extern "C" {
    pub fn SDL_LockAudio();
}
extern "C" {
    pub fn SDL_LockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    pub fn SDL_UnlockAudio();
}
extern "C" {
    pub fn SDL_UnlockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    /// This function shuts down audio processing and closes the audio device.
    pub fn SDL_CloseAudio();
}
extern "C" {
    pub fn SDL_CloseAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    /// \brief Put UTF-8 text into the clipboard
///
/// \sa SDL_GetClipboardText()
    pub fn SDL_SetClipboardText(text: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get UTF-8 text from the clipboard, which must be freed with SDL_free()
///
/// \sa SDL_SetClipboardText()
    pub fn SDL_GetClipboardText() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Returns a flag indicating whether the clipboard exists and contains a text string that is non-empty
///
/// \sa SDL_GetClipboardText()
    pub fn SDL_HasClipboardText() -> SDL_bool;
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(::std::mem::size_of::<__pthread_rwlock_arch_t>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_rwlock_arch_t ) ));
    assert_eq! (::std::mem::align_of::<__pthread_rwlock_arch_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_rwlock_arch_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __readers
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __writers
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __writers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) .
                __wrphase_futex as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __wrphase_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) .
                __writers_futex as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __writers_futex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad3 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad4 as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) .
                __cur_writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __cur_writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __shared as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __rwelision
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad1 as *
                const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __pad2 as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_rwlock_arch_t ) ) . __flags as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_rwlock_arch_t
                ) , "::" , stringify ! ( __flags ) ));
}
impl Clone for __pthread_rwlock_arch_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<__pthread_mutex_s>() , 40usize , concat !
               ( "Size of: " , stringify ! ( __pthread_mutex_s ) ));
    assert_eq! (::std::mem::align_of::<__pthread_mutex_s>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( __pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __lock as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __count as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __owner as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __nusers as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __kind as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __spins as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __elision as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_mutex_s ) ) . __list as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_mutex_s ) ,
                "::" , stringify ! ( __list ) ));
}
impl Clone for __pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const __pthread_cond_s__bindgen_ty_1__bindgen_ty_1
                ) ) . __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const __pthread_cond_s__bindgen_ty_1__bindgen_ty_1
                ) ) . __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( __high ) ));
}
impl Clone for __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1 ) ) .
                __wseq as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! ( __wseq
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_1 ) ) .
                __wseq32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_1 ) , "::" , stringify ! (
                __wseq32 ) ));
}
impl Clone for __pthread_cond_s__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const __pthread_cond_s__bindgen_ty_2__bindgen_ty_1
                ) ) . __low as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( __low ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const __pthread_cond_s__bindgen_ty_2__bindgen_ty_1
                ) ) . __high as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( __high ) ));
}
impl Clone for __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( __pthread_cond_s__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __pthread_cond_s__bindgen_ty_2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2 ) ) .
                __g1_start as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! (
                __g1_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s__bindgen_ty_2 ) ) .
                __g1_start32 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __pthread_cond_s__bindgen_ty_2 ) , "::" , stringify ! (
                __g1_start32 ) ));
}
impl Clone for __pthread_cond_s__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(::std::mem::size_of::<__pthread_cond_s>() , 48usize , concat !
               ( "Size of: " , stringify ! ( __pthread_cond_s ) ));
    assert_eq! (::std::mem::align_of::<__pthread_cond_s>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __pthread_cond_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s ) ) . __g_refs as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cond_s ) ,
                "::" , stringify ! ( __g_refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s ) ) . __g_size as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cond_s ) ,
                "::" , stringify ! ( __g_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s ) ) . __g1_orig_size as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cond_s ) ,
                "::" , stringify ! ( __g1_orig_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s ) ) . __wrefs as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cond_s ) ,
                "::" , stringify ! ( __wrefs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_cond_s ) ) . __g_signals as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_cond_s ) ,
                "::" , stringify ! ( __g_signals ) ));
}
impl Clone for __pthread_cond_s {
    fn clone(&self) -> Self { *self }
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
extern "C" {
    /// This function returns the number of CPU cores available.
    pub fn SDL_GetCPUCount() -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function returns the L1 cache line size of the CPU
///
/// This is useful for determining multi-threaded structure padding
/// or SIMD prefetch sizes.
    pub fn SDL_GetCPUCacheLineSize() -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function returns true if the CPU has the RDTSC instruction.
    pub fn SDL_HasRDTSC() -> SDL_bool;
}
extern "C" {
    /// This function returns true if the CPU has AltiVec features.
    pub fn SDL_HasAltiVec() -> SDL_bool;
}
extern "C" {
    /// This function returns true if the CPU has MMX features.
    pub fn SDL_HasMMX() -> SDL_bool;
}
extern "C" {
    /// This function returns true if the CPU has 3DNow! features.
    pub fn SDL_Has3DNow() -> SDL_bool;
}
extern "C" {
    /// This function returns true if the CPU has SSE features.
    pub fn SDL_HasSSE() -> SDL_bool;
}
extern "C" {
    /// This function returns true if the CPU has SSE2 features.
    pub fn SDL_HasSSE2() -> SDL_bool;
}
extern "C" {
    /// This function returns true if the CPU has SSE3 features.
    pub fn SDL_HasSSE3() -> SDL_bool;
}
extern "C" {
    /// This function returns true if the CPU has SSE4.1 features.
    pub fn SDL_HasSSE41() -> SDL_bool;
}
extern "C" {
    /// This function returns true if the CPU has SSE4.2 features.
    pub fn SDL_HasSSE42() -> SDL_bool;
}
extern "C" {
    /// This function returns true if the CPU has AVX features.
    pub fn SDL_HasAVX() -> SDL_bool;
}
extern "C" {
    /// This function returns true if the CPU has AVX2 features.
    pub fn SDL_HasAVX2() -> SDL_bool;
}
extern "C" {
    /// This function returns true if the CPU has NEON (ARM SIMD) features.
    pub fn SDL_HasNEON() -> SDL_bool;
}
extern "C" {
    /// This function returns the amount of RAM configured in the system, in MB.
    pub fn SDL_GetSystemRAM() -> ::std::os::raw::c_int;
}
pub const SDL_PIXELTYPE_UNKNOWN: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_UNKNOWN;
pub const SDL_PIXELTYPE_INDEX1: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_INDEX1;
pub const SDL_PIXELTYPE_INDEX4: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_INDEX4;
pub const SDL_PIXELTYPE_INDEX8: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_INDEX8;
pub const SDL_PIXELTYPE_PACKED8: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_PACKED8;
pub const SDL_PIXELTYPE_PACKED16: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_PACKED16;
pub const SDL_PIXELTYPE_PACKED32: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_PACKED32;
pub const SDL_PIXELTYPE_ARRAYU8: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_ARRAYU8;
pub const SDL_PIXELTYPE_ARRAYU16: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_ARRAYU16;
pub const SDL_PIXELTYPE_ARRAYU32: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_ARRAYU32;
pub const SDL_PIXELTYPE_ARRAYF16: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_ARRAYF16;
pub const SDL_PIXELTYPE_ARRAYF32: _bindgen_ty_1 =
    _bindgen_ty_1::SDL_PIXELTYPE_ARRAYF32;
#[repr(u32)]
/// Pixel type.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    SDL_PIXELTYPE_UNKNOWN = 0,
    SDL_PIXELTYPE_INDEX1 = 1,
    SDL_PIXELTYPE_INDEX4 = 2,
    SDL_PIXELTYPE_INDEX8 = 3,
    SDL_PIXELTYPE_PACKED8 = 4,
    SDL_PIXELTYPE_PACKED16 = 5,
    SDL_PIXELTYPE_PACKED32 = 6,
    SDL_PIXELTYPE_ARRAYU8 = 7,
    SDL_PIXELTYPE_ARRAYU16 = 8,
    SDL_PIXELTYPE_ARRAYU32 = 9,
    SDL_PIXELTYPE_ARRAYF16 = 10,
    SDL_PIXELTYPE_ARRAYF32 = 11,
}
pub const SDL_BITMAPORDER_NONE: _bindgen_ty_2 =
    _bindgen_ty_2::SDL_BITMAPORDER_NONE;
pub const SDL_BITMAPORDER_4321: _bindgen_ty_2 =
    _bindgen_ty_2::SDL_BITMAPORDER_4321;
pub const SDL_BITMAPORDER_1234: _bindgen_ty_2 =
    _bindgen_ty_2::SDL_BITMAPORDER_1234;
#[repr(u32)]
/// Bitmap pixel order, high bit -> low bit.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    SDL_BITMAPORDER_NONE = 0,
    SDL_BITMAPORDER_4321 = 1,
    SDL_BITMAPORDER_1234 = 2,
}
pub const SDL_PACKEDORDER_NONE: _bindgen_ty_3 =
    _bindgen_ty_3::SDL_PACKEDORDER_NONE;
pub const SDL_PACKEDORDER_XRGB: _bindgen_ty_3 =
    _bindgen_ty_3::SDL_PACKEDORDER_XRGB;
pub const SDL_PACKEDORDER_RGBX: _bindgen_ty_3 =
    _bindgen_ty_3::SDL_PACKEDORDER_RGBX;
pub const SDL_PACKEDORDER_ARGB: _bindgen_ty_3 =
    _bindgen_ty_3::SDL_PACKEDORDER_ARGB;
pub const SDL_PACKEDORDER_RGBA: _bindgen_ty_3 =
    _bindgen_ty_3::SDL_PACKEDORDER_RGBA;
pub const SDL_PACKEDORDER_XBGR: _bindgen_ty_3 =
    _bindgen_ty_3::SDL_PACKEDORDER_XBGR;
pub const SDL_PACKEDORDER_BGRX: _bindgen_ty_3 =
    _bindgen_ty_3::SDL_PACKEDORDER_BGRX;
pub const SDL_PACKEDORDER_ABGR: _bindgen_ty_3 =
    _bindgen_ty_3::SDL_PACKEDORDER_ABGR;
pub const SDL_PACKEDORDER_BGRA: _bindgen_ty_3 =
    _bindgen_ty_3::SDL_PACKEDORDER_BGRA;
#[repr(u32)]
/// Packed component order, high bit -> low bit.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    SDL_PACKEDORDER_NONE = 0,
    SDL_PACKEDORDER_XRGB = 1,
    SDL_PACKEDORDER_RGBX = 2,
    SDL_PACKEDORDER_ARGB = 3,
    SDL_PACKEDORDER_RGBA = 4,
    SDL_PACKEDORDER_XBGR = 5,
    SDL_PACKEDORDER_BGRX = 6,
    SDL_PACKEDORDER_ABGR = 7,
    SDL_PACKEDORDER_BGRA = 8,
}
pub const SDL_ARRAYORDER_NONE: _bindgen_ty_4 =
    _bindgen_ty_4::SDL_ARRAYORDER_NONE;
pub const SDL_ARRAYORDER_RGB: _bindgen_ty_4 =
    _bindgen_ty_4::SDL_ARRAYORDER_RGB;
pub const SDL_ARRAYORDER_RGBA: _bindgen_ty_4 =
    _bindgen_ty_4::SDL_ARRAYORDER_RGBA;
pub const SDL_ARRAYORDER_ARGB: _bindgen_ty_4 =
    _bindgen_ty_4::SDL_ARRAYORDER_ARGB;
pub const SDL_ARRAYORDER_BGR: _bindgen_ty_4 =
    _bindgen_ty_4::SDL_ARRAYORDER_BGR;
pub const SDL_ARRAYORDER_BGRA: _bindgen_ty_4 =
    _bindgen_ty_4::SDL_ARRAYORDER_BGRA;
pub const SDL_ARRAYORDER_ABGR: _bindgen_ty_4 =
    _bindgen_ty_4::SDL_ARRAYORDER_ABGR;
#[repr(u32)]
/// Array component order, low byte -> high byte.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    SDL_ARRAYORDER_NONE = 0,
    SDL_ARRAYORDER_RGB = 1,
    SDL_ARRAYORDER_RGBA = 2,
    SDL_ARRAYORDER_ARGB = 3,
    SDL_ARRAYORDER_BGR = 4,
    SDL_ARRAYORDER_BGRA = 5,
    SDL_ARRAYORDER_ABGR = 6,
}
pub const SDL_PACKEDLAYOUT_NONE: _bindgen_ty_5 =
    _bindgen_ty_5::SDL_PACKEDLAYOUT_NONE;
pub const SDL_PACKEDLAYOUT_332: _bindgen_ty_5 =
    _bindgen_ty_5::SDL_PACKEDLAYOUT_332;
pub const SDL_PACKEDLAYOUT_4444: _bindgen_ty_5 =
    _bindgen_ty_5::SDL_PACKEDLAYOUT_4444;
pub const SDL_PACKEDLAYOUT_1555: _bindgen_ty_5 =
    _bindgen_ty_5::SDL_PACKEDLAYOUT_1555;
pub const SDL_PACKEDLAYOUT_5551: _bindgen_ty_5 =
    _bindgen_ty_5::SDL_PACKEDLAYOUT_5551;
pub const SDL_PACKEDLAYOUT_565: _bindgen_ty_5 =
    _bindgen_ty_5::SDL_PACKEDLAYOUT_565;
pub const SDL_PACKEDLAYOUT_8888: _bindgen_ty_5 =
    _bindgen_ty_5::SDL_PACKEDLAYOUT_8888;
pub const SDL_PACKEDLAYOUT_2101010: _bindgen_ty_5 =
    _bindgen_ty_5::SDL_PACKEDLAYOUT_2101010;
pub const SDL_PACKEDLAYOUT_1010102: _bindgen_ty_5 =
    _bindgen_ty_5::SDL_PACKEDLAYOUT_1010102;
#[repr(u32)]
/// Packed component layout.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    SDL_PACKEDLAYOUT_NONE = 0,
    SDL_PACKEDLAYOUT_332 = 1,
    SDL_PACKEDLAYOUT_4444 = 2,
    SDL_PACKEDLAYOUT_1555 = 3,
    SDL_PACKEDLAYOUT_5551 = 4,
    SDL_PACKEDLAYOUT_565 = 5,
    SDL_PACKEDLAYOUT_8888 = 6,
    SDL_PACKEDLAYOUT_2101010 = 7,
    SDL_PACKEDLAYOUT_1010102 = 8,
}
pub const SDL_PIXELFORMAT_UNKNOWN: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_UNKNOWN;
pub const SDL_PIXELFORMAT_INDEX1LSB: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_INDEX1LSB;
pub const SDL_PIXELFORMAT_INDEX1MSB: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_INDEX1MSB;
pub const SDL_PIXELFORMAT_INDEX4LSB: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_INDEX4LSB;
pub const SDL_PIXELFORMAT_INDEX4MSB: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_INDEX4MSB;
pub const SDL_PIXELFORMAT_INDEX8: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_INDEX8;
pub const SDL_PIXELFORMAT_RGB332: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_RGB332;
pub const SDL_PIXELFORMAT_RGB444: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_RGB444;
pub const SDL_PIXELFORMAT_RGB555: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_RGB555;
pub const SDL_PIXELFORMAT_BGR555: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_BGR555;
pub const SDL_PIXELFORMAT_ARGB4444: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_ARGB4444;
pub const SDL_PIXELFORMAT_RGBA4444: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_RGBA4444;
pub const SDL_PIXELFORMAT_ABGR4444: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_ABGR4444;
pub const SDL_PIXELFORMAT_BGRA4444: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_BGRA4444;
pub const SDL_PIXELFORMAT_ARGB1555: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_ARGB1555;
pub const SDL_PIXELFORMAT_RGBA5551: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_RGBA5551;
pub const SDL_PIXELFORMAT_ABGR1555: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_ABGR1555;
pub const SDL_PIXELFORMAT_BGRA5551: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_BGRA5551;
pub const SDL_PIXELFORMAT_RGB565: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_RGB565;
pub const SDL_PIXELFORMAT_BGR565: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_BGR565;
pub const SDL_PIXELFORMAT_RGB24: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_RGB24;
pub const SDL_PIXELFORMAT_BGR24: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_BGR24;
pub const SDL_PIXELFORMAT_RGB888: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_RGB888;
pub const SDL_PIXELFORMAT_RGBX8888: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_RGBX8888;
pub const SDL_PIXELFORMAT_BGR888: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_BGR888;
pub const SDL_PIXELFORMAT_BGRX8888: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_BGRX8888;
pub const SDL_PIXELFORMAT_ARGB8888: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_ARGB8888;
pub const SDL_PIXELFORMAT_RGBA8888: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_RGBA8888;
pub const SDL_PIXELFORMAT_ABGR8888: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_ABGR8888;
pub const SDL_PIXELFORMAT_BGRA8888: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_BGRA8888;
pub const SDL_PIXELFORMAT_ARGB2101010: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_ARGB2101010;
pub const SDL_PIXELFORMAT_RGBA32: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_ABGR8888;
pub const SDL_PIXELFORMAT_ARGB32: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_BGRA8888;
pub const SDL_PIXELFORMAT_BGRA32: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_ARGB8888;
pub const SDL_PIXELFORMAT_ABGR32: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_RGBA8888;
pub const SDL_PIXELFORMAT_YV12: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_YV12;
pub const SDL_PIXELFORMAT_IYUV: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_IYUV;
pub const SDL_PIXELFORMAT_YUY2: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_YUY2;
pub const SDL_PIXELFORMAT_UYVY: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_UYVY;
pub const SDL_PIXELFORMAT_YVYU: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_YVYU;
pub const SDL_PIXELFORMAT_NV12: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_NV12;
pub const SDL_PIXELFORMAT_NV21: _bindgen_ty_6 =
    _bindgen_ty_6::SDL_PIXELFORMAT_NV21;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    SDL_PIXELFORMAT_UNKNOWN = 0,
    SDL_PIXELFORMAT_INDEX1LSB = 286261504,
    SDL_PIXELFORMAT_INDEX1MSB = 287310080,
    SDL_PIXELFORMAT_INDEX4LSB = 303039488,
    SDL_PIXELFORMAT_INDEX4MSB = 304088064,
    SDL_PIXELFORMAT_INDEX8 = 318769153,
    SDL_PIXELFORMAT_RGB332 = 336660481,
    SDL_PIXELFORMAT_RGB444 = 353504258,
    SDL_PIXELFORMAT_RGB555 = 353570562,
    SDL_PIXELFORMAT_BGR555 = 357764866,
    SDL_PIXELFORMAT_ARGB4444 = 355602434,
    SDL_PIXELFORMAT_RGBA4444 = 356651010,
    SDL_PIXELFORMAT_ABGR4444 = 359796738,
    SDL_PIXELFORMAT_BGRA4444 = 360845314,
    SDL_PIXELFORMAT_ARGB1555 = 355667970,
    SDL_PIXELFORMAT_RGBA5551 = 356782082,
    SDL_PIXELFORMAT_ABGR1555 = 359862274,
    SDL_PIXELFORMAT_BGRA5551 = 360976386,
    SDL_PIXELFORMAT_RGB565 = 353701890,
    SDL_PIXELFORMAT_BGR565 = 357896194,
    SDL_PIXELFORMAT_RGB24 = 386930691,
    SDL_PIXELFORMAT_BGR24 = 390076419,
    SDL_PIXELFORMAT_RGB888 = 370546692,
    SDL_PIXELFORMAT_RGBX8888 = 371595268,
    SDL_PIXELFORMAT_BGR888 = 374740996,
    SDL_PIXELFORMAT_BGRX8888 = 375789572,
    SDL_PIXELFORMAT_ARGB8888 = 372645892,
    SDL_PIXELFORMAT_RGBA8888 = 373694468,
    SDL_PIXELFORMAT_ABGR8888 = 376840196,
    SDL_PIXELFORMAT_BGRA8888 = 377888772,
    SDL_PIXELFORMAT_ARGB2101010 = 372711428,
    SDL_PIXELFORMAT_YV12 = 842094169,
    SDL_PIXELFORMAT_IYUV = 1448433993,
    SDL_PIXELFORMAT_YUY2 = 844715353,
    SDL_PIXELFORMAT_UYVY = 1498831189,
    SDL_PIXELFORMAT_YVYU = 1431918169,
    SDL_PIXELFORMAT_NV12 = 842094158,
    SDL_PIXELFORMAT_NV21 = 825382478,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_Color {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
    pub a: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_Color() {
    assert_eq!(::std::mem::size_of::<SDL_Color>() , 4usize , concat ! (
               "Size of: " , stringify ! ( SDL_Color ) ));
    assert_eq! (::std::mem::align_of::<SDL_Color>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( SDL_Color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Color ) ) . r as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Color ) , "::" ,
                stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Color ) ) . g as * const _ as usize }
                , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Color ) , "::" ,
                stringify ! ( g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Color ) ) . b as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Color ) , "::" ,
                stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Color ) ) . a as * const _ as usize }
                , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Color ) , "::" ,
                stringify ! ( a ) ));
}
impl Clone for SDL_Color {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_Palette {
    pub ncolors: ::std::os::raw::c_int,
    pub colors: *mut SDL_Color,
    pub version: Uint32,
    pub refcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Palette() {
    assert_eq!(::std::mem::size_of::<SDL_Palette>() , 24usize , concat ! (
               "Size of: " , stringify ! ( SDL_Palette ) ));
    assert_eq! (::std::mem::align_of::<SDL_Palette>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SDL_Palette ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Palette ) ) . ncolors as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Palette ) , "::" ,
                stringify ! ( ncolors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Palette ) ) . colors as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Palette ) , "::" ,
                stringify ! ( colors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Palette ) ) . version as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Palette ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Palette ) ) . refcount as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Palette ) , "::" ,
                stringify ! ( refcount ) ));
}
impl Clone for SDL_Palette {
    fn clone(&self) -> Self { *self }
}
/// \note Everything in the pixel format structure is read-only.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_PixelFormat {
    pub format: Uint32,
    pub palette: *mut SDL_Palette,
    pub BitsPerPixel: Uint8,
    pub BytesPerPixel: Uint8,
    pub padding: [Uint8; 2usize],
    pub Rmask: Uint32,
    pub Gmask: Uint32,
    pub Bmask: Uint32,
    pub Amask: Uint32,
    pub Rloss: Uint8,
    pub Gloss: Uint8,
    pub Bloss: Uint8,
    pub Aloss: Uint8,
    pub Rshift: Uint8,
    pub Gshift: Uint8,
    pub Bshift: Uint8,
    pub Ashift: Uint8,
    pub refcount: ::std::os::raw::c_int,
    pub next: *mut SDL_PixelFormat,
}
#[test]
fn bindgen_test_layout_SDL_PixelFormat() {
    assert_eq!(::std::mem::size_of::<SDL_PixelFormat>() , 56usize , concat ! (
               "Size of: " , stringify ! ( SDL_PixelFormat ) ));
    assert_eq! (::std::mem::align_of::<SDL_PixelFormat>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SDL_PixelFormat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . format as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . palette as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( palette ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . BitsPerPixel as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( BitsPerPixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . BytesPerPixel as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( BytesPerPixel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . padding as * const
                _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( padding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Rmask as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Rmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Gmask as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Gmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Bmask as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Bmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Amask as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Amask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Rloss as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Rloss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Gloss as * const _
                as usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Gloss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Bloss as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Bloss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Aloss as * const _
                as usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Aloss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Rshift as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Rshift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Gshift as * const _
                as usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Gshift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Bshift as * const _
                as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Bshift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . Ashift as * const _
                as usize } , 43usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( Ashift ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . refcount as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_PixelFormat ) ) . next as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_PixelFormat ) ,
                "::" , stringify ! ( next ) ));
}
impl Clone for SDL_PixelFormat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// \brief Get the human readable name of a pixel format
    pub fn SDL_GetPixelFormatName(format: Uint32)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Convert one of the enumerated pixel formats to a bpp and RGBA masks.
///
/// \return SDL_TRUE, or SDL_FALSE if the conversion wasn't possible.
///
/// \sa SDL_MasksToPixelFormatEnum()
    pub fn SDL_PixelFormatEnumToMasks(format: Uint32,
                                      bpp: *mut ::std::os::raw::c_int,
                                      Rmask: *mut Uint32, Gmask: *mut Uint32,
                                      Bmask: *mut Uint32, Amask: *mut Uint32)
     -> SDL_bool;
}
extern "C" {
    /// \brief Convert a bpp and RGBA masks to an enumerated pixel format.
///
/// \return The pixel format, or ::SDL_PIXELFORMAT_UNKNOWN if the conversion
/// wasn't possible.
///
/// \sa SDL_PixelFormatEnumToMasks()
    pub fn SDL_MasksToPixelFormatEnum(bpp: ::std::os::raw::c_int,
                                      Rmask: Uint32, Gmask: Uint32,
                                      Bmask: Uint32, Amask: Uint32) -> Uint32;
}
extern "C" {
    /// \brief Create an SDL_PixelFormat structure from a pixel format enum.
    pub fn SDL_AllocFormat(pixel_format: Uint32) -> *mut SDL_PixelFormat;
}
extern "C" {
    /// \brief Free an SDL_PixelFormat structure.
    pub fn SDL_FreeFormat(format: *mut SDL_PixelFormat);
}
extern "C" {
    /// \brief Create a palette structure with the specified number of color
/// entries.
///
/// \return A new palette, or NULL if there wasn't enough memory.
///
/// \note The palette entries are initialized to white.
///
/// \sa SDL_FreePalette()
    pub fn SDL_AllocPalette(ncolors: ::std::os::raw::c_int)
     -> *mut SDL_Palette;
}
extern "C" {
    /// \brief Set the palette for a pixel format structure.
    pub fn SDL_SetPixelFormatPalette(format: *mut SDL_PixelFormat,
                                     palette: *mut SDL_Palette)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set a range of colors in a palette.
///
/// \param palette    The palette to modify.
/// \param colors     An array of colors to copy into the palette.
/// \param firstcolor The index of the first palette entry to modify.
/// \param ncolors    The number of entries to modify.
///
/// \return 0 on success, or -1 if not all of the colors could be set.
    pub fn SDL_SetPaletteColors(palette: *mut SDL_Palette,
                                colors: *const SDL_Color,
                                firstcolor: ::std::os::raw::c_int,
                                ncolors: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Free a palette created with SDL_AllocPalette().
///
/// \sa SDL_AllocPalette()
    pub fn SDL_FreePalette(palette: *mut SDL_Palette);
}
extern "C" {
    /// \brief Maps an RGB triple to an opaque pixel value for a given pixel format.
///
/// \sa SDL_MapRGBA
    pub fn SDL_MapRGB(format: *const SDL_PixelFormat, r: Uint8, g: Uint8,
                      b: Uint8) -> Uint32;
}
extern "C" {
    /// \brief Maps an RGBA quadruple to a pixel value for a given pixel format.
///
/// \sa SDL_MapRGB
    pub fn SDL_MapRGBA(format: *const SDL_PixelFormat, r: Uint8, g: Uint8,
                       b: Uint8, a: Uint8) -> Uint32;
}
extern "C" {
    /// \brief Get the RGB components from a pixel of the specified format.
///
/// \sa SDL_GetRGBA
    pub fn SDL_GetRGB(pixel: Uint32, format: *const SDL_PixelFormat,
                      r: *mut Uint8, g: *mut Uint8, b: *mut Uint8);
}
extern "C" {
    /// \brief Get the RGBA components from a pixel of the specified format.
///
/// \sa SDL_GetRGB
    pub fn SDL_GetRGBA(pixel: Uint32, format: *const SDL_PixelFormat,
                       r: *mut Uint8, g: *mut Uint8, b: *mut Uint8,
                       a: *mut Uint8);
}
extern "C" {
    /// \brief Calculate a 256 entry gamma ramp for a gamma value.
    pub fn SDL_CalculateGammaRamp(gamma: f32, ramp: *mut Uint16);
}
/// \brief  The structure that defines a point
///
/// \sa SDL_EnclosePoints
/// \sa SDL_PointInRect
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_Point {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Point() {
    assert_eq!(::std::mem::size_of::<SDL_Point>() , 8usize , concat ! (
               "Size of: " , stringify ! ( SDL_Point ) ));
    assert_eq! (::std::mem::align_of::<SDL_Point>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( SDL_Point ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Point ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Point ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Point ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Point ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for SDL_Point {
    fn clone(&self) -> Self { *self }
}
/// \brief A rectangle, with the origin at the upper left.
///
/// \sa SDL_RectEmpty
/// \sa SDL_RectEquals
/// \sa SDL_HasIntersection
/// \sa SDL_IntersectRect
/// \sa SDL_UnionRect
/// \sa SDL_EnclosePoints
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_Rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
    pub h: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Rect() {
    assert_eq!(::std::mem::size_of::<SDL_Rect>() , 16usize , concat ! (
               "Size of: " , stringify ! ( SDL_Rect ) ));
    assert_eq! (::std::mem::align_of::<SDL_Rect>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( SDL_Rect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Rect ) ) . x as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Rect ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Rect ) ) . y as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Rect ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Rect ) ) . w as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Rect ) , "::" ,
                stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Rect ) ) . h as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Rect ) , "::" ,
                stringify ! ( h ) ));
}
impl Clone for SDL_Rect {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// \brief Determine whether two rectangles intersect.
///
/// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
    pub fn SDL_HasIntersection(A: *const SDL_Rect, B: *const SDL_Rect)
     -> SDL_bool;
}
extern "C" {
    /// \brief Calculate the intersection of two rectangles.
///
/// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
    pub fn SDL_IntersectRect(A: *const SDL_Rect, B: *const SDL_Rect,
                             result: *mut SDL_Rect) -> SDL_bool;
}
extern "C" {
    /// \brief Calculate the union of two rectangles.
    pub fn SDL_UnionRect(A: *const SDL_Rect, B: *const SDL_Rect,
                         result: *mut SDL_Rect);
}
extern "C" {
    /// \brief Calculate a minimal rectangle enclosing a set of points
///
/// \return SDL_TRUE if any points were within the clipping rect
    pub fn SDL_EnclosePoints(points: *const SDL_Point,
                             count: ::std::os::raw::c_int,
                             clip: *const SDL_Rect, result: *mut SDL_Rect)
     -> SDL_bool;
}
extern "C" {
    /// \brief Calculate the intersection of a rectangle and line segment.
///
/// \return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.
    pub fn SDL_IntersectRectAndLine(rect: *const SDL_Rect,
                                    X1: *mut ::std::os::raw::c_int,
                                    Y1: *mut ::std::os::raw::c_int,
                                    X2: *mut ::std::os::raw::c_int,
                                    Y2: *mut ::std::os::raw::c_int)
     -> SDL_bool;
}
#[repr(u32)]
/// \brief The blend mode used in SDL_RenderCopy() and drawing operations.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_BlendMode {
    SDL_BLENDMODE_NONE = 0,
    SDL_BLENDMODE_BLEND = 1,
    SDL_BLENDMODE_ADD = 2,
    SDL_BLENDMODE_MOD = 4,
    SDL_BLENDMODE_INVALID = 2147483647,
}
#[repr(u32)]
/// \brief The blend operation used when combining source and destination pixel components
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_BlendOperation {
    SDL_BLENDOPERATION_ADD = 1,
    SDL_BLENDOPERATION_SUBTRACT = 2,
    SDL_BLENDOPERATION_REV_SUBTRACT = 3,
    SDL_BLENDOPERATION_MINIMUM = 4,
    SDL_BLENDOPERATION_MAXIMUM = 5,
}
#[repr(u32)]
/// \brief The normalized factor used to multiply pixel components
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_BlendFactor {
    SDL_BLENDFACTOR_ZERO = 1,
    SDL_BLENDFACTOR_ONE = 2,
    SDL_BLENDFACTOR_SRC_COLOR = 3,
    SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4,
    SDL_BLENDFACTOR_SRC_ALPHA = 5,
    SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6,
    SDL_BLENDFACTOR_DST_COLOR = 7,
    SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8,
    SDL_BLENDFACTOR_DST_ALPHA = 9,
    SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10,
}
extern "C" {
    /// \brief Create a custom blend mode, which may or may not be supported by a given renderer
///
/// \param srcColorFactor
/// \param dstColorFactor
/// \param colorOperation
/// \param srcAlphaFactor
/// \param dstAlphaFactor
/// \param alphaOperation
///
/// The result of the blend mode operation will be:
/// dstRGB = dstRGB * dstColorFactor colorOperation srcRGB * srcColorFactor
/// and
/// dstA = dstA * dstAlphaFactor alphaOperation srcA * srcAlphaFactor
    pub fn SDL_ComposeCustomBlendMode(srcColorFactor: SDL_BlendFactor,
                                      dstColorFactor: SDL_BlendFactor,
                                      colorOperation: SDL_BlendOperation,
                                      srcAlphaFactor: SDL_BlendFactor,
                                      dstAlphaFactor: SDL_BlendFactor,
                                      alphaOperation: SDL_BlendOperation)
     -> SDL_BlendMode;
}
/// \brief A collection of pixels used in software blitting.
///
/// \note  This structure should be treated as read-only, except for \c pixels,
/// which, if not NULL, contains the raw pixel data for the surface.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_Surface {
    /// < Read-only
    pub flags: Uint32,
    /// < Read-only
    pub format: *mut SDL_PixelFormat,
    /// < Read-only
    pub w: ::std::os::raw::c_int,
    /// < Read-only
    pub h: ::std::os::raw::c_int,
    /// < Read-only
    pub pitch: ::std::os::raw::c_int,
    /// < Read-write
    pub pixels: *mut ::std::os::raw::c_void,
    /// < Read-write
    pub userdata: *mut ::std::os::raw::c_void,
    /// < Read-only
    pub locked: ::std::os::raw::c_int,
    /// < Read-only
    pub lock_data: *mut ::std::os::raw::c_void,
    /// < Read-only
    pub clip_rect: SDL_Rect,
    /// < Private
    pub map: *mut SDL_BlitMap,
    /// < Read-mostly
    pub refcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Surface() {
    assert_eq!(::std::mem::size_of::<SDL_Surface>() , 96usize , concat ! (
               "Size of: " , stringify ! ( SDL_Surface ) ));
    assert_eq! (::std::mem::align_of::<SDL_Surface>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SDL_Surface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . format as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . w as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . h as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . pitch as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( pitch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . pixels as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( pixels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . userdata as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( userdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . locked as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( locked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . lock_data as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( lock_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . clip_rect as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( clip_rect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . map as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Surface ) ) . refcount as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Surface ) , "::" ,
                stringify ! ( refcount ) ));
}
impl Clone for SDL_Surface {
    fn clone(&self) -> Self { *self }
}
/// \brief The type of function used for surface blitting functions.
pub type SDL_blit =
    ::std::option::Option<unsafe extern "C" fn(src: *mut SDL_Surface,
                                               srcrect: *mut SDL_Rect,
                                               dst: *mut SDL_Surface,
                                               dstrect: *mut SDL_Rect)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// Allocate and free an RGB surface.
///
/// If the depth is 4 or 8 bits, an empty palette is allocated for the surface.
/// If the depth is greater than 8 bits, the pixel format is set using the
/// flags '[RGB]mask'.
///
/// If the function runs out of memory, it will return NULL.
///
/// \param flags The \c flags are obsolete and should be set to 0.
/// \param width The width in pixels of the surface to create.
/// \param height The height in pixels of the surface to create.
/// \param depth The depth in bits of the surface to create.
/// \param Rmask The red mask of the surface to create.
/// \param Gmask The green mask of the surface to create.
/// \param Bmask The blue mask of the surface to create.
/// \param Amask The alpha mask of the surface to create.
    pub fn SDL_CreateRGBSurface(flags: Uint32, width: ::std::os::raw::c_int,
                                height: ::std::os::raw::c_int,
                                depth: ::std::os::raw::c_int, Rmask: Uint32,
                                Gmask: Uint32, Bmask: Uint32, Amask: Uint32)
     -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateRGBSurfaceWithFormat(flags: Uint32,
                                          width: ::std::os::raw::c_int,
                                          height: ::std::os::raw::c_int,
                                          depth: ::std::os::raw::c_int,
                                          format: Uint32) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateRGBSurfaceFrom(pixels: *mut ::std::os::raw::c_void,
                                    width: ::std::os::raw::c_int,
                                    height: ::std::os::raw::c_int,
                                    depth: ::std::os::raw::c_int,
                                    pitch: ::std::os::raw::c_int,
                                    Rmask: Uint32, Gmask: Uint32,
                                    Bmask: Uint32, Amask: Uint32)
     -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateRGBSurfaceWithFormatFrom(pixels:
                                                  *mut ::std::os::raw::c_void,
                                              width: ::std::os::raw::c_int,
                                              height: ::std::os::raw::c_int,
                                              depth: ::std::os::raw::c_int,
                                              pitch: ::std::os::raw::c_int,
                                              format: Uint32)
     -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_FreeSurface(surface: *mut SDL_Surface);
}
extern "C" {
    /// \brief Set the palette used by a surface.
///
/// \return 0, or -1 if the surface format doesn't use a palette.
///
/// \note A single palette can be shared with many surfaces.
    pub fn SDL_SetSurfacePalette(surface: *mut SDL_Surface,
                                 palette: *mut SDL_Palette)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Sets up a surface for directly accessing the pixels.
///
/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write
/// to and read from \c surface->pixels, using the pixel format stored in
/// \c surface->format.  Once you are done accessing the surface, you should
/// use SDL_UnlockSurface() to release it.
///
/// Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates
/// to 0, then you can read and write to the surface at any time, and the
/// pixel format of the surface will not change.
///
/// No operating system or library calls should be made between lock/unlock
/// pairs, as critical system locks may be held during this time.
///
/// SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked.
///
/// \sa SDL_UnlockSurface()
    pub fn SDL_LockSurface(surface: *mut SDL_Surface)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \sa SDL_LockSurface()
    pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
extern "C" {
    /// Load a surface from a seekable SDL data stream (memory or file).
///
/// If \c freesrc is non-zero, the stream will be closed after being read.
///
/// The new surface should be freed with SDL_FreeSurface().
///
/// \return the new surface, or NULL if there was an error.
    pub fn SDL_LoadBMP_RW(src: *mut SDL_RWops, freesrc: ::std::os::raw::c_int)
     -> *mut SDL_Surface;
}
extern "C" {
    /// Save a surface to a seekable SDL data stream (memory or file).
///
/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
/// BMP directly. Other RGB formats with 8-bit or higher get converted to a
/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
/// not supported.
///
/// If \c freedst is non-zero, the stream will be closed after being written.
///
/// \return 0 if successful or -1 if there was an error.
    pub fn SDL_SaveBMP_RW(surface: *mut SDL_Surface, dst: *mut SDL_RWops,
                          freedst: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Sets the RLE acceleration hint for a surface.
///
/// \return 0 on success, or -1 if the surface is not valid
///
/// \note If RLE is enabled, colorkey and alpha blending blits are much faster,
/// but the surface must be locked before directly accessing the pixels.
    pub fn SDL_SetSurfaceRLE(surface: *mut SDL_Surface,
                             flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Sets the color key (transparent pixel) in a blittable surface.
///
/// \param surface The surface to update
/// \param flag Non-zero to enable colorkey and 0 to disable colorkey
/// \param key The transparent pixel in the native surface format
///
/// \return 0 on success, or -1 if the surface is not valid
///
/// You can pass SDL_RLEACCEL to enable RLE accelerated blits.
    pub fn SDL_SetColorKey(surface: *mut SDL_Surface,
                           flag: ::std::os::raw::c_int, key: Uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Gets the color key (transparent pixel) in a blittable surface.
///
/// \param surface The surface to update
/// \param key A pointer filled in with the transparent pixel in the native
/// surface format
///
/// \return 0 on success, or -1 if the surface is not valid or colorkey is not
/// enabled.
    pub fn SDL_GetColorKey(surface: *mut SDL_Surface, key: *mut Uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set an additional color value used in blit operations.
///
/// \param surface The surface to update.
/// \param r The red color value multiplied into blit operations.
/// \param g The green color value multiplied into blit operations.
/// \param b The blue color value multiplied into blit operations.
///
/// \return 0 on success, or -1 if the surface is not valid.
///
/// \sa SDL_GetSurfaceColorMod()
    pub fn SDL_SetSurfaceColorMod(surface: *mut SDL_Surface, r: Uint8,
                                  g: Uint8, b: Uint8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the additional color value used in blit operations.
///
/// \param surface The surface to query.
/// \param r A pointer filled in with the current red color value.
/// \param g A pointer filled in with the current green color value.
/// \param b A pointer filled in with the current blue color value.
///
/// \return 0 on success, or -1 if the surface is not valid.
///
/// \sa SDL_SetSurfaceColorMod()
    pub fn SDL_GetSurfaceColorMod(surface: *mut SDL_Surface, r: *mut Uint8,
                                  g: *mut Uint8, b: *mut Uint8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set an additional alpha value used in blit operations.
///
/// \param surface The surface to update.
/// \param alpha The alpha value multiplied into blit operations.
///
/// \return 0 on success, or -1 if the surface is not valid.
///
/// \sa SDL_GetSurfaceAlphaMod()
    pub fn SDL_SetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: Uint8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the additional alpha value used in blit operations.
///
/// \param surface The surface to query.
/// \param alpha A pointer filled in with the current alpha value.
///
/// \return 0 on success, or -1 if the surface is not valid.
///
/// \sa SDL_SetSurfaceAlphaMod()
    pub fn SDL_GetSurfaceAlphaMod(surface: *mut SDL_Surface,
                                  alpha: *mut Uint8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set the blend mode used for blit operations.
///
/// \param surface The surface to update.
/// \param blendMode ::SDL_BlendMode to use for blit blending.
///
/// \return 0 on success, or -1 if the parameters are not valid.
///
/// \sa SDL_GetSurfaceBlendMode()
    pub fn SDL_SetSurfaceBlendMode(surface: *mut SDL_Surface,
                                   blendMode: SDL_BlendMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the blend mode used for blit operations.
///
/// \param surface   The surface to query.
/// \param blendMode A pointer filled in with the current blend mode.
///
/// \return 0 on success, or -1 if the surface is not valid.
///
/// \sa SDL_SetSurfaceBlendMode()
    pub fn SDL_GetSurfaceBlendMode(surface: *mut SDL_Surface,
                                   blendMode: *mut SDL_BlendMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Sets the clipping rectangle for the destination surface in a blit.
///
/// If the clip rectangle is NULL, clipping will be disabled.
///
/// If the clip rectangle doesn't intersect the surface, the function will
/// return SDL_FALSE and blits will be completely clipped.  Otherwise the
/// function returns SDL_TRUE and blits to the surface will be clipped to
/// the intersection of the surface area and the clipping rectangle.
///
/// Note that blits are automatically clipped to the edges of the source
/// and destination surfaces.
    pub fn SDL_SetClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect)
     -> SDL_bool;
}
extern "C" {
    /// Gets the clipping rectangle for the destination surface in a blit.
///
/// \c rect must be a pointer to a valid rectangle which will be filled
/// with the correct values.
    pub fn SDL_GetClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect);
}
extern "C" {
    pub fn SDL_DuplicateSurface(surface: *mut SDL_Surface)
     -> *mut SDL_Surface;
}
extern "C" {
    /// Creates a new surface of the specified format, and then copies and maps
/// the given surface to it so the blit of the converted surface will be as
/// fast as possible.  If this function fails, it returns NULL.
///
/// The \c flags parameter is passed to SDL_CreateRGBSurface() and has those
/// semantics.  You can also pass ::SDL_RLEACCEL in the flags parameter and
/// SDL will try to RLE accelerate colorkey and alpha blits in the resulting
/// surface.
    pub fn SDL_ConvertSurface(src: *mut SDL_Surface,
                              fmt: *const SDL_PixelFormat, flags: Uint32)
     -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_ConvertSurfaceFormat(src: *mut SDL_Surface,
                                    pixel_format: Uint32, flags: Uint32)
     -> *mut SDL_Surface;
}
extern "C" {
    /// \brief Copy a block of pixels of one format to another format
///
/// \return 0 on success, or -1 if there was an error
    pub fn SDL_ConvertPixels(width: ::std::os::raw::c_int,
                             height: ::std::os::raw::c_int,
                             src_format: Uint32,
                             src: *const ::std::os::raw::c_void,
                             src_pitch: ::std::os::raw::c_int,
                             dst_format: Uint32,
                             dst: *mut ::std::os::raw::c_void,
                             dst_pitch: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Performs a fast fill of the given rectangle with \c color.
///
/// If \c rect is NULL, the whole surface will be filled with \c color.
///
/// The color should be a pixel of the format used by the surface, and
/// can be generated by the SDL_MapRGB() function.
///
/// \return 0 on success, or -1 on error.
    pub fn SDL_FillRect(dst: *mut SDL_Surface, rect: *const SDL_Rect,
                        color: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SDL_FillRects(dst: *mut SDL_Surface, rects: *const SDL_Rect,
                         count: ::std::os::raw::c_int, color: Uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// This is the public blit function, SDL_BlitSurface(), and it performs
/// rectangle validation and clipping before passing it to SDL_LowerBlit()
    pub fn SDL_UpperBlit(src: *mut SDL_Surface, srcrect: *const SDL_Rect,
                         dst: *mut SDL_Surface, dstrect: *mut SDL_Rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// This is a semi-private blit function and it performs low-level surface
/// blitting only.
    pub fn SDL_LowerBlit(src: *mut SDL_Surface, srcrect: *mut SDL_Rect,
                         dst: *mut SDL_Surface, dstrect: *mut SDL_Rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Perform a fast, low quality, stretch blit between two surfaces of the
/// same pixel format.
///
/// \note This function uses a static buffer, and is not thread-safe.
    pub fn SDL_SoftStretch(src: *mut SDL_Surface, srcrect: *const SDL_Rect,
                           dst: *mut SDL_Surface, dstrect: *const SDL_Rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// This is the public scaled blit function, SDL_BlitScaled(), and it performs
/// rectangle validation and clipping before passing it to SDL_LowerBlitScaled()
    pub fn SDL_UpperBlitScaled(src: *mut SDL_Surface,
                               srcrect: *const SDL_Rect,
                               dst: *mut SDL_Surface, dstrect: *mut SDL_Rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// This is a semi-private blit function and it performs low-level surface
/// scaled blitting only.
    pub fn SDL_LowerBlitScaled(src: *mut SDL_Surface, srcrect: *mut SDL_Rect,
                               dst: *mut SDL_Surface, dstrect: *mut SDL_Rect)
     -> ::std::os::raw::c_int;
}
/// \brief  The structure that defines a display mode
///
/// \sa SDL_GetNumDisplayModes()
/// \sa SDL_GetDisplayMode()
/// \sa SDL_GetDesktopDisplayMode()
/// \sa SDL_GetCurrentDisplayMode()
/// \sa SDL_GetClosestDisplayMode()
/// \sa SDL_SetWindowDisplayMode()
/// \sa SDL_GetWindowDisplayMode()
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_DisplayMode {
    /// < pixel format
    pub format: Uint32,
    /// < width, in screen coordinates
    pub w: ::std::os::raw::c_int,
    /// < height, in screen coordinates
    pub h: ::std::os::raw::c_int,
    /// < refresh rate (or zero for unspecified)
    pub refresh_rate: ::std::os::raw::c_int,
    /// < driver-specific data, initialize to 0
    pub driverdata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_DisplayMode() {
    assert_eq!(::std::mem::size_of::<SDL_DisplayMode>() , 24usize , concat ! (
               "Size of: " , stringify ! ( SDL_DisplayMode ) ));
    assert_eq! (::std::mem::align_of::<SDL_DisplayMode>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SDL_DisplayMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DisplayMode ) ) . format as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DisplayMode ) ,
                "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DisplayMode ) ) . w as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DisplayMode ) ,
                "::" , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DisplayMode ) ) . h as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DisplayMode ) ,
                "::" , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DisplayMode ) ) . refresh_rate as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DisplayMode ) ,
                "::" , stringify ! ( refresh_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DisplayMode ) ) . driverdata as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DisplayMode ) ,
                "::" , stringify ! ( driverdata ) ));
}
impl Clone for SDL_DisplayMode {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Window {
    _unused: [u8; 0],
}
#[repr(u32)]
/// \brief The flags on a window
///
/// \sa SDL_GetWindowFlags()
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_WindowFlags {
    SDL_WINDOW_FULLSCREEN = 1,
    SDL_WINDOW_OPENGL = 2,
    SDL_WINDOW_SHOWN = 4,
    SDL_WINDOW_HIDDEN = 8,
    SDL_WINDOW_BORDERLESS = 16,
    SDL_WINDOW_RESIZABLE = 32,
    SDL_WINDOW_MINIMIZED = 64,
    SDL_WINDOW_MAXIMIZED = 128,
    SDL_WINDOW_INPUT_GRABBED = 256,
    SDL_WINDOW_INPUT_FOCUS = 512,
    SDL_WINDOW_MOUSE_FOCUS = 1024,
    SDL_WINDOW_FULLSCREEN_DESKTOP = 4097,
    SDL_WINDOW_FOREIGN = 2048,
    SDL_WINDOW_ALLOW_HIGHDPI = 8192,
    SDL_WINDOW_MOUSE_CAPTURE = 16384,
    SDL_WINDOW_ALWAYS_ON_TOP = 32768,
    SDL_WINDOW_SKIP_TASKBAR = 65536,
    SDL_WINDOW_UTILITY = 131072,
    SDL_WINDOW_TOOLTIP = 262144,
    SDL_WINDOW_POPUP_MENU = 524288,
    SDL_WINDOW_VULKAN = 268435456,
}
#[repr(u32)]
/// \brief Event subtype for window events
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_WindowEventID {
    SDL_WINDOWEVENT_NONE = 0,
    SDL_WINDOWEVENT_SHOWN = 1,
    SDL_WINDOWEVENT_HIDDEN = 2,
    SDL_WINDOWEVENT_EXPOSED = 3,
    SDL_WINDOWEVENT_MOVED = 4,
    SDL_WINDOWEVENT_RESIZED = 5,
    SDL_WINDOWEVENT_SIZE_CHANGED = 6,
    SDL_WINDOWEVENT_MINIMIZED = 7,
    SDL_WINDOWEVENT_MAXIMIZED = 8,
    SDL_WINDOWEVENT_RESTORED = 9,
    SDL_WINDOWEVENT_ENTER = 10,
    SDL_WINDOWEVENT_LEAVE = 11,
    SDL_WINDOWEVENT_FOCUS_GAINED = 12,
    SDL_WINDOWEVENT_FOCUS_LOST = 13,
    SDL_WINDOWEVENT_CLOSE = 14,
    SDL_WINDOWEVENT_TAKE_FOCUS = 15,
    SDL_WINDOWEVENT_HIT_TEST = 16,
}
/// \brief An opaque handle to an OpenGL context.
pub type SDL_GLContext = *mut ::std::os::raw::c_void;
#[repr(u32)]
/// \brief OpenGL configuration attributes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLattr {
    SDL_GL_RED_SIZE = 0,
    SDL_GL_GREEN_SIZE = 1,
    SDL_GL_BLUE_SIZE = 2,
    SDL_GL_ALPHA_SIZE = 3,
    SDL_GL_BUFFER_SIZE = 4,
    SDL_GL_DOUBLEBUFFER = 5,
    SDL_GL_DEPTH_SIZE = 6,
    SDL_GL_STENCIL_SIZE = 7,
    SDL_GL_ACCUM_RED_SIZE = 8,
    SDL_GL_ACCUM_GREEN_SIZE = 9,
    SDL_GL_ACCUM_BLUE_SIZE = 10,
    SDL_GL_ACCUM_ALPHA_SIZE = 11,
    SDL_GL_STEREO = 12,
    SDL_GL_MULTISAMPLEBUFFERS = 13,
    SDL_GL_MULTISAMPLESAMPLES = 14,
    SDL_GL_ACCELERATED_VISUAL = 15,
    SDL_GL_RETAINED_BACKING = 16,
    SDL_GL_CONTEXT_MAJOR_VERSION = 17,
    SDL_GL_CONTEXT_MINOR_VERSION = 18,
    SDL_GL_CONTEXT_EGL = 19,
    SDL_GL_CONTEXT_FLAGS = 20,
    SDL_GL_CONTEXT_PROFILE_MASK = 21,
    SDL_GL_SHARE_WITH_CURRENT_CONTEXT = 22,
    SDL_GL_FRAMEBUFFER_SRGB_CAPABLE = 23,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR = 24,
    SDL_GL_CONTEXT_RESET_NOTIFICATION = 25,
    SDL_GL_CONTEXT_NO_ERROR = 26,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLprofile {
    SDL_GL_CONTEXT_PROFILE_CORE = 1,
    SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 2,
    SDL_GL_CONTEXT_PROFILE_ES = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLcontextFlag {
    SDL_GL_CONTEXT_DEBUG_FLAG = 1,
    SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 2,
    SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 4,
    SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLcontextReleaseFlag {
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GLContextResetNotification {
    SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0,
    SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = 1,
}
extern "C" {
    /// \brief Get the number of video drivers compiled into SDL
///
/// \sa SDL_GetVideoDriver()
    pub fn SDL_GetNumVideoDrivers() -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the name of a built in video driver.
///
/// \note The video drivers are presented in the order in which they are
/// normally checked during initialization.
///
/// \sa SDL_GetNumVideoDrivers()
    pub fn SDL_GetVideoDriver(index: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Initialize the video subsystem, optionally specifying a video driver.
///
/// \param driver_name Initialize a specific driver by name, or NULL for the
/// default video driver.
///
/// \return 0 on success, -1 on error
///
/// This function initializes the video subsystem; setting up a connection
/// to the window manager, etc, and determines the available display modes
/// and pixel formats, but does not initialize a window or graphics mode.
///
/// \sa SDL_VideoQuit()
    pub fn SDL_VideoInit(driver_name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Shuts down the video subsystem.
///
/// This function closes all windows, and restores the original video mode.
///
/// \sa SDL_VideoInit()
    pub fn SDL_VideoQuit();
}
extern "C" {
    /// \brief Returns the name of the currently initialized video driver.
///
/// \return The name of the current video driver or NULL if no driver
/// has been initialized
///
/// \sa SDL_GetNumVideoDrivers()
/// \sa SDL_GetVideoDriver()
    pub fn SDL_GetCurrentVideoDriver() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Returns the number of available video displays.
///
/// \sa SDL_GetDisplayBounds()
    pub fn SDL_GetNumVideoDisplays() -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the name of a display in UTF-8 encoding
///
/// \return The name of a display, or NULL for an invalid display index.
///
/// \sa SDL_GetNumVideoDisplays()
    pub fn SDL_GetDisplayName(displayIndex: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Get the desktop area represented by a display, with the primary
/// display located at 0,0
///
/// \return 0 on success, or -1 if the index is out of range.
///
/// \sa SDL_GetNumVideoDisplays()
    pub fn SDL_GetDisplayBounds(displayIndex: ::std::os::raw::c_int,
                                rect: *mut SDL_Rect) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the dots/pixels-per-inch for a display
///
/// \note Diagonal, horizontal and vertical DPI can all be optionally
/// returned if the parameter is non-NULL.
///
/// \return 0 on success, or -1 if no DPI information is available or the index is out of range.
///
/// \sa SDL_GetNumVideoDisplays()
    pub fn SDL_GetDisplayDPI(displayIndex: ::std::os::raw::c_int,
                             ddpi: *mut f32, hdpi: *mut f32, vdpi: *mut f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the usable desktop area represented by a display, with the
/// primary display located at 0,0
///
/// This is the same area as SDL_GetDisplayBounds() reports, but with portions
/// reserved by the system removed. For example, on Mac OS X, this subtracts
/// the area occupied by the menu bar and dock.
///
/// Setting a window to be fullscreen generally bypasses these unusable areas,
/// so these are good guidelines for the maximum space available to a
/// non-fullscreen window.
///
/// \return 0 on success, or -1 if the index is out of range.
///
/// \sa SDL_GetDisplayBounds()
/// \sa SDL_GetNumVideoDisplays()
    pub fn SDL_GetDisplayUsableBounds(displayIndex: ::std::os::raw::c_int,
                                      rect: *mut SDL_Rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Returns the number of available display modes.
///
/// \sa SDL_GetDisplayMode()
    pub fn SDL_GetNumDisplayModes(displayIndex: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Fill in information about a specific display mode.
///
/// \note The display modes are sorted in this priority:
/// \li bits per pixel -> more colors to fewer colors
/// \li width -> largest to smallest
/// \li height -> largest to smallest
/// \li refresh rate -> highest to lowest
///
/// \sa SDL_GetNumDisplayModes()
    pub fn SDL_GetDisplayMode(displayIndex: ::std::os::raw::c_int,
                              modeIndex: ::std::os::raw::c_int,
                              mode: *mut SDL_DisplayMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Fill in information about the desktop display mode.
    pub fn SDL_GetDesktopDisplayMode(displayIndex: ::std::os::raw::c_int,
                                     mode: *mut SDL_DisplayMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Fill in information about the current display mode.
    pub fn SDL_GetCurrentDisplayMode(displayIndex: ::std::os::raw::c_int,
                                     mode: *mut SDL_DisplayMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the closest match to the requested display mode.
///
/// \param displayIndex The index of display from which mode should be queried.
/// \param mode The desired display mode
/// \param closest A pointer to a display mode to be filled in with the closest
/// match of the available display modes.
///
/// \return The passed in value \c closest, or NULL if no matching video mode
/// was available.
///
/// The available display modes are scanned, and \c closest is filled in with the
/// closest mode matching the requested mode and returned.  The mode format and
/// refresh_rate default to the desktop mode if they are 0.  The modes are
/// scanned with size being first priority, format being second priority, and
/// finally checking the refresh_rate.  If all the available modes are too
/// small, then NULL is returned.
///
/// \sa SDL_GetNumDisplayModes()
/// \sa SDL_GetDisplayMode()
    pub fn SDL_GetClosestDisplayMode(displayIndex: ::std::os::raw::c_int,
                                     mode: *const SDL_DisplayMode,
                                     closest: *mut SDL_DisplayMode)
     -> *mut SDL_DisplayMode;
}
extern "C" {
    /// \brief Get the display index associated with a window.
///
/// \return the display index of the display containing the center of the
/// window, or -1 on error.
    pub fn SDL_GetWindowDisplayIndex(window: *mut SDL_Window)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set the display mode used when a fullscreen window is visible.
///
/// By default the window's dimensions and the desktop format and refresh rate
/// are used.
///
/// \param window The window for which the display mode should be set.
/// \param mode The mode to use, or NULL for the default mode.
///
/// \return 0 on success, or -1 if setting the display mode failed.
///
/// \sa SDL_GetWindowDisplayMode()
/// \sa SDL_SetWindowFullscreen()
    pub fn SDL_SetWindowDisplayMode(window: *mut SDL_Window,
                                    mode: *const SDL_DisplayMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Fill in information about the display mode used when a fullscreen
/// window is visible.
///
/// \sa SDL_SetWindowDisplayMode()
/// \sa SDL_SetWindowFullscreen()
    pub fn SDL_GetWindowDisplayMode(window: *mut SDL_Window,
                                    mode: *mut SDL_DisplayMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the pixel format associated with the window.
    pub fn SDL_GetWindowPixelFormat(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    /// \brief Create a window with the specified position, dimensions, and flags.
///
/// \param title The title of the window, in UTF-8 encoding.
/// \param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
/// ::SDL_WINDOWPOS_UNDEFINED.
/// \param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
/// ::SDL_WINDOWPOS_UNDEFINED.
/// \param w     The width of the window, in screen coordinates.
/// \param h     The height of the window, in screen coordinates.
/// \param flags The flags for the window, a mask of any of the following:
/// ::SDL_WINDOW_FULLSCREEN,    ::SDL_WINDOW_OPENGL,
/// ::SDL_WINDOW_HIDDEN,        ::SDL_WINDOW_BORDERLESS,
/// ::SDL_WINDOW_RESIZABLE,     ::SDL_WINDOW_MAXIMIZED,
/// ::SDL_WINDOW_MINIMIZED,     ::SDL_WINDOW_INPUT_GRABBED,
/// ::SDL_WINDOW_ALLOW_HIGHDPI, ::SDL_WINDOW_VULKAN.
///
/// \return The created window, or NULL if window creation failed.
///
/// If the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its size
/// in pixels may differ from its size in screen coordinates on platforms with
/// high-DPI support (e.g. iOS and Mac OS X). Use SDL_GetWindowSize() to query
/// the client area's size in screen coordinates, and SDL_GL_GetDrawableSize(),
/// SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to query the
/// drawable size in pixels.
///
/// If the window is created with any of the SDL_WINDOW_OPENGL or
/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
/// corrensponding UnloadLibrary function is called by SDL_DestroyWindow().
///
/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.
///
/// \note On non-Apple devices, SDL requires you to either not link to the
/// Vulkan loader or link to a dynamic library version. This limitation
/// may be removed in a future version of SDL.
///
/// \sa SDL_DestroyWindow()
/// \sa SDL_GL_LoadLibrary()
/// \sa SDL_Vulkan_LoadLibrary()
    pub fn SDL_CreateWindow(title: *const ::std::os::raw::c_char,
                            x: ::std::os::raw::c_int,
                            y: ::std::os::raw::c_int,
                            w: ::std::os::raw::c_int,
                            h: ::std::os::raw::c_int, flags: Uint32)
     -> *mut SDL_Window;
}
extern "C" {
    /// \brief Create an SDL window from an existing native window.
///
/// \param data A pointer to driver-dependent window creation data
///
/// \return The created window, or NULL if window creation failed.
///
/// \sa SDL_DestroyWindow()
    pub fn SDL_CreateWindowFrom(data: *const ::std::os::raw::c_void)
     -> *mut SDL_Window;
}
extern "C" {
    /// \brief Get the numeric ID of a window, for logging purposes.
    pub fn SDL_GetWindowID(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    /// \brief Get a window from a stored ID, or NULL if it doesn't exist.
    pub fn SDL_GetWindowFromID(id: Uint32) -> *mut SDL_Window;
}
extern "C" {
    /// \brief Get the window flags.
    pub fn SDL_GetWindowFlags(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    /// \brief Set the title of a window, in UTF-8 format.
///
/// \sa SDL_GetWindowTitle()
    pub fn SDL_SetWindowTitle(window: *mut SDL_Window,
                              title: *const ::std::os::raw::c_char);
}
extern "C" {
    /// \brief Get the title of a window, in UTF-8 format.
///
/// \sa SDL_SetWindowTitle()
    pub fn SDL_GetWindowTitle(window: *mut SDL_Window)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Set the icon for a window.
///
/// \param window The window for which the icon should be set.
/// \param icon The icon for the window.
    pub fn SDL_SetWindowIcon(window: *mut SDL_Window, icon: *mut SDL_Surface);
}
extern "C" {
    /// \brief Associate an arbitrary named pointer with a window.
///
/// \param window   The window to associate with the pointer.
/// \param name     The name of the pointer.
/// \param userdata The associated pointer.
///
/// \return The previous value associated with 'name'
///
/// \note The name is case-sensitive.
///
/// \sa SDL_GetWindowData()
    pub fn SDL_SetWindowData(window: *mut SDL_Window,
                             name: *const ::std::os::raw::c_char,
                             userdata: *mut ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// \brief Retrieve the data pointer associated with a window.
///
/// \param window   The window to query.
/// \param name     The name of the pointer.
///
/// \return The value associated with 'name'
///
/// \sa SDL_SetWindowData()
    pub fn SDL_GetWindowData(window: *mut SDL_Window,
                             name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// \brief Set the position of a window.
///
/// \param window   The window to reposition.
/// \param x        The x coordinate of the window in screen coordinates, or
/// ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.
/// \param y        The y coordinate of the window in screen coordinates, or
/// ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.
///
/// \note The window coordinate origin is the upper left of the display.
///
/// \sa SDL_GetWindowPosition()
    pub fn SDL_SetWindowPosition(window: *mut SDL_Window,
                                 x: ::std::os::raw::c_int,
                                 y: ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Get the position of a window.
///
/// \param window   The window to query.
/// \param x        Pointer to variable for storing the x position, in screen
/// coordinates. May be NULL.
/// \param y        Pointer to variable for storing the y position, in screen
/// coordinates. May be NULL.
///
/// \sa SDL_SetWindowPosition()
    pub fn SDL_GetWindowPosition(window: *mut SDL_Window,
                                 x: *mut ::std::os::raw::c_int,
                                 y: *mut ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Set the size of a window's client area.
///
/// \param window   The window to resize.
/// \param w        The width of the window, in screen coordinates. Must be >0.
/// \param h        The height of the window, in screen coordinates. Must be >0.
///
/// \note Fullscreen windows automatically match the size of the display mode,
/// and you should use SDL_SetWindowDisplayMode() to change their size.
///
/// The window size in screen coordinates may differ from the size in pixels, if
/// the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with
/// high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or
/// SDL_GetRendererOutputSize() to get the real client area size in pixels.
///
/// \sa SDL_GetWindowSize()
/// \sa SDL_SetWindowDisplayMode()
    pub fn SDL_SetWindowSize(window: *mut SDL_Window,
                             w: ::std::os::raw::c_int,
                             h: ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Get the size of a window's client area.
///
/// \param window   The window to query.
/// \param w        Pointer to variable for storing the width, in screen
/// coordinates. May be NULL.
/// \param h        Pointer to variable for storing the height, in screen
/// coordinates. May be NULL.
///
/// The window size in screen coordinates may differ from the size in pixels, if
/// the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with
/// high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or
/// SDL_GetRendererOutputSize() to get the real client area size in pixels.
///
/// \sa SDL_SetWindowSize()
    pub fn SDL_GetWindowSize(window: *mut SDL_Window,
                             w: *mut ::std::os::raw::c_int,
                             h: *mut ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Get the size of a window's borders (decorations) around the client area.
///
/// \param window The window to query.
/// \param top Pointer to variable for storing the size of the top border. NULL is permitted.
/// \param left Pointer to variable for storing the size of the left border. NULL is permitted.
/// \param bottom Pointer to variable for storing the size of the bottom border. NULL is permitted.
/// \param right Pointer to variable for storing the size of the right border. NULL is permitted.
///
/// \return 0 on success, or -1 if getting this information is not supported.
///
/// \note if this function fails (returns -1), the size values will be
/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as
/// if the window in question was borderless.
    pub fn SDL_GetWindowBordersSize(window: *mut SDL_Window,
                                    top: *mut ::std::os::raw::c_int,
                                    left: *mut ::std::os::raw::c_int,
                                    bottom: *mut ::std::os::raw::c_int,
                                    right: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set the minimum size of a window's client area.
///
/// \param window    The window to set a new minimum size.
/// \param min_w     The minimum width of the window, must be >0
/// \param min_h     The minimum height of the window, must be >0
///
/// \note You can't change the minimum size of a fullscreen window, it
/// automatically matches the size of the display mode.
///
/// \sa SDL_GetWindowMinimumSize()
/// \sa SDL_SetWindowMaximumSize()
    pub fn SDL_SetWindowMinimumSize(window: *mut SDL_Window,
                                    min_w: ::std::os::raw::c_int,
                                    min_h: ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Get the minimum size of a window's client area.
///
/// \param window   The window to query.
/// \param w        Pointer to variable for storing the minimum width, may be NULL
/// \param h        Pointer to variable for storing the minimum height, may be NULL
///
/// \sa SDL_GetWindowMaximumSize()
/// \sa SDL_SetWindowMinimumSize()
    pub fn SDL_GetWindowMinimumSize(window: *mut SDL_Window,
                                    w: *mut ::std::os::raw::c_int,
                                    h: *mut ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Set the maximum size of a window's client area.
///
/// \param window    The window to set a new maximum size.
/// \param max_w     The maximum width of the window, must be >0
/// \param max_h     The maximum height of the window, must be >0
///
/// \note You can't change the maximum size of a fullscreen window, it
/// automatically matches the size of the display mode.
///
/// \sa SDL_GetWindowMaximumSize()
/// \sa SDL_SetWindowMinimumSize()
    pub fn SDL_SetWindowMaximumSize(window: *mut SDL_Window,
                                    max_w: ::std::os::raw::c_int,
                                    max_h: ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Get the maximum size of a window's client area.
///
/// \param window   The window to query.
/// \param w        Pointer to variable for storing the maximum width, may be NULL
/// \param h        Pointer to variable for storing the maximum height, may be NULL
///
/// \sa SDL_GetWindowMinimumSize()
/// \sa SDL_SetWindowMaximumSize()
    pub fn SDL_GetWindowMaximumSize(window: *mut SDL_Window,
                                    w: *mut ::std::os::raw::c_int,
                                    h: *mut ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Set the border state of a window.
///
/// This will add or remove the window's SDL_WINDOW_BORDERLESS flag and
/// add or remove the border from the actual window. This is a no-op if the
/// window's border already matches the requested state.
///
/// \param window The window of which to change the border state.
/// \param bordered SDL_FALSE to remove border, SDL_TRUE to add border.
///
/// \note You can't change the border state of a fullscreen window.
///
/// \sa SDL_GetWindowFlags()
    pub fn SDL_SetWindowBordered(window: *mut SDL_Window, bordered: SDL_bool);
}
extern "C" {
    /// \brief Set the user-resizable state of a window.
///
/// This will add or remove the window's SDL_WINDOW_RESIZABLE flag and
/// allow/disallow user resizing of the window. This is a no-op if the
/// window's resizable state already matches the requested state.
///
/// \param window The window of which to change the resizable state.
/// \param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow.
///
/// \note You can't change the resizable state of a fullscreen window.
///
/// \sa SDL_GetWindowFlags()
    pub fn SDL_SetWindowResizable(window: *mut SDL_Window,
                                  resizable: SDL_bool);
}
extern "C" {
    /// \brief Show a window.
///
/// \sa SDL_HideWindow()
    pub fn SDL_ShowWindow(window: *mut SDL_Window);
}
extern "C" {
    /// \brief Hide a window.
///
/// \sa SDL_ShowWindow()
    pub fn SDL_HideWindow(window: *mut SDL_Window);
}
extern "C" {
    /// \brief Raise a window above other windows and set the input focus.
    pub fn SDL_RaiseWindow(window: *mut SDL_Window);
}
extern "C" {
    /// \brief Make a window as large as possible.
///
/// \sa SDL_RestoreWindow()
    pub fn SDL_MaximizeWindow(window: *mut SDL_Window);
}
extern "C" {
    /// \brief Minimize a window to an iconic representation.
///
/// \sa SDL_RestoreWindow()
    pub fn SDL_MinimizeWindow(window: *mut SDL_Window);
}
extern "C" {
    /// \brief Restore the size and position of a minimized or maximized window.
///
/// \sa SDL_MaximizeWindow()
/// \sa SDL_MinimizeWindow()
    pub fn SDL_RestoreWindow(window: *mut SDL_Window);
}
extern "C" {
    /// \brief Set a window's fullscreen state.
///
/// \return 0 on success, or -1 if setting the display mode failed.
///
/// \sa SDL_SetWindowDisplayMode()
/// \sa SDL_GetWindowDisplayMode()
    pub fn SDL_SetWindowFullscreen(window: *mut SDL_Window, flags: Uint32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the SDL surface associated with the window.
///
/// \return The window's framebuffer surface, or NULL on error.
///
/// A new surface will be created with the optimal format for the window,
/// if necessary. This surface will be freed when the window is destroyed.
///
/// \note You may not combine this with 3D or the rendering API on this window.
///
/// \sa SDL_UpdateWindowSurface()
/// \sa SDL_UpdateWindowSurfaceRects()
    pub fn SDL_GetWindowSurface(window: *mut SDL_Window) -> *mut SDL_Surface;
}
extern "C" {
    /// \brief Copy the window surface to the screen.
///
/// \return 0 on success, or -1 on error.
///
/// \sa SDL_GetWindowSurface()
/// \sa SDL_UpdateWindowSurfaceRects()
    pub fn SDL_UpdateWindowSurface(window: *mut SDL_Window)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Copy a number of rectangles on the window surface to the screen.
///
/// \return 0 on success, or -1 on error.
///
/// \sa SDL_GetWindowSurface()
/// \sa SDL_UpdateWindowSurface()
    pub fn SDL_UpdateWindowSurfaceRects(window: *mut SDL_Window,
                                        rects: *const SDL_Rect,
                                        numrects: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set a window's input grab mode.
///
/// \param window The window for which the input grab mode should be set.
/// \param grabbed This is SDL_TRUE to grab input, and SDL_FALSE to release input.
///
/// If the caller enables a grab while another window is currently grabbed,
/// the other window loses its grab in favor of the caller's window.
///
/// \sa SDL_GetWindowGrab()
    pub fn SDL_SetWindowGrab(window: *mut SDL_Window, grabbed: SDL_bool);
}
extern "C" {
    /// \brief Get a window's input grab mode.
///
/// \return This returns SDL_TRUE if input is grabbed, and SDL_FALSE otherwise.
///
/// \sa SDL_SetWindowGrab()
    pub fn SDL_GetWindowGrab(window: *mut SDL_Window) -> SDL_bool;
}
extern "C" {
    /// \brief Get the window that currently has an input grab enabled.
///
/// \return This returns the window if input is grabbed, and NULL otherwise.
///
/// \sa SDL_SetWindowGrab()
    pub fn SDL_GetGrabbedWindow() -> *mut SDL_Window;
}
extern "C" {
    /// \brief Set the brightness (gamma correction) for a window.
///
/// \return 0 on success, or -1 if setting the brightness isn't supported.
///
/// \sa SDL_GetWindowBrightness()
/// \sa SDL_SetWindowGammaRamp()
    pub fn SDL_SetWindowBrightness(window: *mut SDL_Window, brightness: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the brightness (gamma correction) for a window.
///
/// \return The last brightness value passed to SDL_SetWindowBrightness()
///
/// \sa SDL_SetWindowBrightness()
    pub fn SDL_GetWindowBrightness(window: *mut SDL_Window) -> f32;
}
extern "C" {
    /// \brief Set the opacity for a window
///
/// \param window The window which will be made transparent or opaque
/// \param opacity Opacity (0.0f - transparent, 1.0f - opaque) This will be
/// clamped internally between 0.0f and 1.0f.
///
/// \return 0 on success, or -1 if setting the opacity isn't supported.
///
/// \sa SDL_GetWindowOpacity()
    pub fn SDL_SetWindowOpacity(window: *mut SDL_Window, opacity: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the opacity of a window.
///
/// If transparency isn't supported on this platform, opacity will be reported
/// as 1.0f without error.
///
/// \param window The window in question.
/// \param out_opacity Opacity (0.0f - transparent, 1.0f - opaque)
///
/// \return 0 on success, or -1 on error (invalid window, etc).
///
/// \sa SDL_SetWindowOpacity()
    pub fn SDL_GetWindowOpacity(window: *mut SDL_Window,
                                out_opacity: *mut f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Sets the window as a modal for another window (TODO: reconsider this function and/or its name)
///
/// \param modal_window The window that should be modal
/// \param parent_window The parent window
///
/// \return 0 on success, or -1 otherwise.
    pub fn SDL_SetWindowModalFor(modal_window: *mut SDL_Window,
                                 parent_window: *mut SDL_Window)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Explicitly sets input focus to the window.
///
/// You almost certainly want SDL_RaiseWindow() instead of this function. Use
/// this with caution, as you might give focus to a window that's completely
/// obscured by other windows.
///
/// \param window The window that should get the input focus
///
/// \return 0 on success, or -1 otherwise.
/// \sa SDL_RaiseWindow()
    pub fn SDL_SetWindowInputFocus(window: *mut SDL_Window)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set the gamma ramp for a window.
///
/// \param window The window for which the gamma ramp should be set.
/// \param red The translation table for the red channel, or NULL.
/// \param green The translation table for the green channel, or NULL.
/// \param blue The translation table for the blue channel, or NULL.
///
/// \return 0 on success, or -1 if gamma ramps are unsupported.
///
/// Set the gamma translation table for the red, green, and blue channels
/// of the video hardware.  Each table is an array of 256 16-bit quantities,
/// representing a mapping between the input and output for that channel.
/// The input is the index into the array, and the output is the 16-bit
/// gamma value at that index, scaled to the output color precision.
///
/// \sa SDL_GetWindowGammaRamp()
    pub fn SDL_SetWindowGammaRamp(window: *mut SDL_Window, red: *const Uint16,
                                  green: *const Uint16, blue: *const Uint16)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the gamma ramp for a window.
///
/// \param window The window from which the gamma ramp should be queried.
/// \param red   A pointer to a 256 element array of 16-bit quantities to hold
/// the translation table for the red channel, or NULL.
/// \param green A pointer to a 256 element array of 16-bit quantities to hold
/// the translation table for the green channel, or NULL.
/// \param blue  A pointer to a 256 element array of 16-bit quantities to hold
/// the translation table for the blue channel, or NULL.
///
/// \return 0 on success, or -1 if gamma ramps are unsupported.
///
/// \sa SDL_SetWindowGammaRamp()
    pub fn SDL_GetWindowGammaRamp(window: *mut SDL_Window, red: *mut Uint16,
                                  green: *mut Uint16, blue: *mut Uint16)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// \brief Possible return values from the SDL_HitTest callback.
///
/// \sa SDL_HitTest
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_HitTestResult {
    SDL_HITTEST_NORMAL = 0,
    SDL_HITTEST_DRAGGABLE = 1,
    SDL_HITTEST_RESIZE_TOPLEFT = 2,
    SDL_HITTEST_RESIZE_TOP = 3,
    SDL_HITTEST_RESIZE_TOPRIGHT = 4,
    SDL_HITTEST_RESIZE_RIGHT = 5,
    SDL_HITTEST_RESIZE_BOTTOMRIGHT = 6,
    SDL_HITTEST_RESIZE_BOTTOM = 7,
    SDL_HITTEST_RESIZE_BOTTOMLEFT = 8,
    SDL_HITTEST_RESIZE_LEFT = 9,
}
/// \brief Callback used for hit-testing.
///
/// \sa SDL_SetWindowHitTest
pub type SDL_HitTest =
    ::std::option::Option<unsafe extern "C" fn(win: *mut SDL_Window,
                                               area: *const SDL_Point,
                                               data:
                                                   *mut ::std::os::raw::c_void)
                              -> SDL_HitTestResult>;
extern "C" {
    /// \brief Provide a callback that decides if a window region has special properties.
///
/// Normally windows are dragged and resized by decorations provided by the
/// system window manager (a title bar, borders, etc), but for some apps, it
/// makes sense to drag them from somewhere else inside the window itself; for
/// example, one might have a borderless window that wants to be draggable
/// from any part, or simulate its own title bar, etc.
///
/// This function lets the app provide a callback that designates pieces of
/// a given window as special. This callback is run during event processing
/// if we need to tell the OS to treat a region of the window specially; the
/// use of this callback is known as "hit testing."
///
/// Mouse input may not be delivered to your application if it is within
/// a special area; the OS will often apply that input to moving the window or
/// resizing the window and not deliver it to the application.
///
/// Specifying NULL for a callback disables hit-testing. Hit-testing is
/// disabled by default.
///
/// Platforms that don't support this functionality will return -1
/// unconditionally, even if you're attempting to disable hit-testing.
///
/// Your callback may fire at any time, and its firing does not indicate any
/// specific behavior (for example, on Windows, this certainly might fire
/// when the OS is deciding whether to drag your window, but it fires for lots
/// of other reasons, too, some unrelated to anything you probably care about
/// _and when the mouse isn't actually at the location it is testing_).
/// Since this can fire at any time, you should try to keep your callback
/// efficient, devoid of allocations, etc.
///
/// \param window The window to set hit-testing on.
/// \param callback The callback to call when doing a hit-test.
/// \param callback_data An app-defined void pointer passed to the callback.
/// \return 0 on success, -1 on error (including unsupported).
    pub fn SDL_SetWindowHitTest(window: *mut SDL_Window,
                                callback: SDL_HitTest,
                                callback_data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Destroy a window.
    pub fn SDL_DestroyWindow(window: *mut SDL_Window);
}
extern "C" {
    /// \brief Returns whether the screensaver is currently enabled (default off).
///
/// \sa SDL_EnableScreenSaver()
/// \sa SDL_DisableScreenSaver()
    pub fn SDL_IsScreenSaverEnabled() -> SDL_bool;
}
extern "C" {
    /// \brief Allow the screen to be blanked by a screensaver
///
/// \sa SDL_IsScreenSaverEnabled()
/// \sa SDL_DisableScreenSaver()
    pub fn SDL_EnableScreenSaver();
}
extern "C" {
    /// \brief Prevent the screen from being blanked by a screensaver
///
/// \sa SDL_IsScreenSaverEnabled()
/// \sa SDL_EnableScreenSaver()
    pub fn SDL_DisableScreenSaver();
}
extern "C" {
    /// \brief Dynamically load an OpenGL library.
///
/// \param path The platform dependent OpenGL library name, or NULL to open the
/// default OpenGL library.
///
/// \return 0 on success, or -1 if the library couldn't be loaded.
///
/// This should be done after initializing the video driver, but before
/// creating any OpenGL windows.  If no OpenGL library is loaded, the default
/// library will be loaded upon creation of the first OpenGL window.
///
/// \note If you do this, you need to retrieve all of the GL functions used in
/// your program from the dynamic library using SDL_GL_GetProcAddress().
///
/// \sa SDL_GL_GetProcAddress()
/// \sa SDL_GL_UnloadLibrary()
    pub fn SDL_GL_LoadLibrary(path: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the address of an OpenGL function.
    pub fn SDL_GL_GetProcAddress(proc_: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// \brief Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
///
/// \sa SDL_GL_LoadLibrary()
    pub fn SDL_GL_UnloadLibrary();
}
extern "C" {
    /// \brief Return true if an OpenGL extension is supported for the current
/// context.
    pub fn SDL_GL_ExtensionSupported(extension: *const ::std::os::raw::c_char)
     -> SDL_bool;
}
extern "C" {
    /// \brief Reset all previously set OpenGL context attributes to their default values
    pub fn SDL_GL_ResetAttributes();
}
extern "C" {
    /// \brief Set an OpenGL window attribute before window creation.
///
/// \return 0 on success, or -1 if the attribute could not be set.
    pub fn SDL_GL_SetAttribute(attr: SDL_GLattr, value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the actual value for an attribute from the current context.
///
/// \return 0 on success, or -1 if the attribute could not be retrieved.
/// The integer at \c value will be modified in either case.
    pub fn SDL_GL_GetAttribute(attr: SDL_GLattr,
                               value: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Create an OpenGL context for use with an OpenGL window, and make it
/// current.
///
/// \sa SDL_GL_DeleteContext()
    pub fn SDL_GL_CreateContext(window: *mut SDL_Window) -> SDL_GLContext;
}
extern "C" {
    /// \brief Set up an OpenGL context for rendering into an OpenGL window.
///
/// \note The context must have been created with a compatible window.
    pub fn SDL_GL_MakeCurrent(window: *mut SDL_Window, context: SDL_GLContext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the currently active OpenGL window.
    pub fn SDL_GL_GetCurrentWindow() -> *mut SDL_Window;
}
extern "C" {
    /// \brief Get the currently active OpenGL context.
    pub fn SDL_GL_GetCurrentContext() -> SDL_GLContext;
}
extern "C" {
    /// \brief Get the size of a window's underlying drawable in pixels (for use
/// with glViewport).
///
/// \param window   Window from which the drawable size should be queried
/// \param w        Pointer to variable for storing the width in pixels, may be NULL
/// \param h        Pointer to variable for storing the height in pixels, may be NULL
///
/// This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI
/// drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a
/// platform with high-DPI support (Apple calls this "Retina"), and not disabled
/// by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.
///
/// \sa SDL_GetWindowSize()
/// \sa SDL_CreateWindow()
    pub fn SDL_GL_GetDrawableSize(window: *mut SDL_Window,
                                  w: *mut ::std::os::raw::c_int,
                                  h: *mut ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Set the swap interval for the current OpenGL context.
///
/// \param interval 0 for immediate updates, 1 for updates synchronized with the
/// vertical retrace. If the system supports it, you may
/// specify -1 to allow late swaps to happen immediately
/// instead of waiting for the next retrace.
///
/// \return 0 on success, or -1 if setting the swap interval is not supported.
///
/// \sa SDL_GL_GetSwapInterval()
    pub fn SDL_GL_SetSwapInterval(interval: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the swap interval for the current OpenGL context.
///
/// \return 0 if there is no vertical retrace synchronization, 1 if the buffer
/// swap is synchronized with the vertical retrace, and -1 if late
/// swaps happen immediately instead of waiting for the next retrace.
/// If the system can't determine the swap interval, or there isn't a
/// valid current context, this will return 0 as a safe default.
///
/// \sa SDL_GL_SetSwapInterval()
    pub fn SDL_GL_GetSwapInterval() -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Swap the OpenGL buffers for a window, if double-buffering is
/// supported.
    pub fn SDL_GL_SwapWindow(window: *mut SDL_Window);
}
extern "C" {
    /// \brief Delete an OpenGL context.
///
/// \sa SDL_GL_CreateContext()
    pub fn SDL_GL_DeleteContext(context: SDL_GLContext);
}
#[repr(u32)]
/// \brief The SDL keyboard scancode representation.
///
/// Values of this type are used to represent keyboard keys, among other places
/// in the \link SDL_Keysym::scancode key.keysym.scancode \endlink field of the
/// SDL_Event structure.
///
/// The values in this enumeration are based on the USB usage page standard:
/// http://www.usb.org/developers/hidpage/Hut1_12v2.pdf
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_Scancode {
    SDL_SCANCODE_UNKNOWN = 0,
    SDL_SCANCODE_A = 4,
    SDL_SCANCODE_B = 5,
    SDL_SCANCODE_C = 6,
    SDL_SCANCODE_D = 7,
    SDL_SCANCODE_E = 8,
    SDL_SCANCODE_F = 9,
    SDL_SCANCODE_G = 10,
    SDL_SCANCODE_H = 11,
    SDL_SCANCODE_I = 12,
    SDL_SCANCODE_J = 13,
    SDL_SCANCODE_K = 14,
    SDL_SCANCODE_L = 15,
    SDL_SCANCODE_M = 16,
    SDL_SCANCODE_N = 17,
    SDL_SCANCODE_O = 18,
    SDL_SCANCODE_P = 19,
    SDL_SCANCODE_Q = 20,
    SDL_SCANCODE_R = 21,
    SDL_SCANCODE_S = 22,
    SDL_SCANCODE_T = 23,
    SDL_SCANCODE_U = 24,
    SDL_SCANCODE_V = 25,
    SDL_SCANCODE_W = 26,
    SDL_SCANCODE_X = 27,
    SDL_SCANCODE_Y = 28,
    SDL_SCANCODE_Z = 29,
    SDL_SCANCODE_1 = 30,
    SDL_SCANCODE_2 = 31,
    SDL_SCANCODE_3 = 32,
    SDL_SCANCODE_4 = 33,
    SDL_SCANCODE_5 = 34,
    SDL_SCANCODE_6 = 35,
    SDL_SCANCODE_7 = 36,
    SDL_SCANCODE_8 = 37,
    SDL_SCANCODE_9 = 38,
    SDL_SCANCODE_0 = 39,
    SDL_SCANCODE_RETURN = 40,
    SDL_SCANCODE_ESCAPE = 41,
    SDL_SCANCODE_BACKSPACE = 42,
    SDL_SCANCODE_TAB = 43,
    SDL_SCANCODE_SPACE = 44,
    SDL_SCANCODE_MINUS = 45,
    SDL_SCANCODE_EQUALS = 46,
    SDL_SCANCODE_LEFTBRACKET = 47,
    SDL_SCANCODE_RIGHTBRACKET = 48,
    SDL_SCANCODE_BACKSLASH = 49,
    SDL_SCANCODE_NONUSHASH = 50,
    SDL_SCANCODE_SEMICOLON = 51,
    SDL_SCANCODE_APOSTROPHE = 52,
    SDL_SCANCODE_GRAVE = 53,
    SDL_SCANCODE_COMMA = 54,
    SDL_SCANCODE_PERIOD = 55,
    SDL_SCANCODE_SLASH = 56,
    SDL_SCANCODE_CAPSLOCK = 57,
    SDL_SCANCODE_F1 = 58,
    SDL_SCANCODE_F2 = 59,
    SDL_SCANCODE_F3 = 60,
    SDL_SCANCODE_F4 = 61,
    SDL_SCANCODE_F5 = 62,
    SDL_SCANCODE_F6 = 63,
    SDL_SCANCODE_F7 = 64,
    SDL_SCANCODE_F8 = 65,
    SDL_SCANCODE_F9 = 66,
    SDL_SCANCODE_F10 = 67,
    SDL_SCANCODE_F11 = 68,
    SDL_SCANCODE_F12 = 69,
    SDL_SCANCODE_PRINTSCREEN = 70,
    SDL_SCANCODE_SCROLLLOCK = 71,
    SDL_SCANCODE_PAUSE = 72,
    SDL_SCANCODE_INSERT = 73,
    SDL_SCANCODE_HOME = 74,
    SDL_SCANCODE_PAGEUP = 75,
    SDL_SCANCODE_DELETE = 76,
    SDL_SCANCODE_END = 77,
    SDL_SCANCODE_PAGEDOWN = 78,
    SDL_SCANCODE_RIGHT = 79,
    SDL_SCANCODE_LEFT = 80,
    SDL_SCANCODE_DOWN = 81,
    SDL_SCANCODE_UP = 82,
    SDL_SCANCODE_NUMLOCKCLEAR = 83,
    SDL_SCANCODE_KP_DIVIDE = 84,
    SDL_SCANCODE_KP_MULTIPLY = 85,
    SDL_SCANCODE_KP_MINUS = 86,
    SDL_SCANCODE_KP_PLUS = 87,
    SDL_SCANCODE_KP_ENTER = 88,
    SDL_SCANCODE_KP_1 = 89,
    SDL_SCANCODE_KP_2 = 90,
    SDL_SCANCODE_KP_3 = 91,
    SDL_SCANCODE_KP_4 = 92,
    SDL_SCANCODE_KP_5 = 93,
    SDL_SCANCODE_KP_6 = 94,
    SDL_SCANCODE_KP_7 = 95,
    SDL_SCANCODE_KP_8 = 96,
    SDL_SCANCODE_KP_9 = 97,
    SDL_SCANCODE_KP_0 = 98,
    SDL_SCANCODE_KP_PERIOD = 99,
    SDL_SCANCODE_NONUSBACKSLASH = 100,
    SDL_SCANCODE_APPLICATION = 101,
    SDL_SCANCODE_POWER = 102,
    SDL_SCANCODE_KP_EQUALS = 103,
    SDL_SCANCODE_F13 = 104,
    SDL_SCANCODE_F14 = 105,
    SDL_SCANCODE_F15 = 106,
    SDL_SCANCODE_F16 = 107,
    SDL_SCANCODE_F17 = 108,
    SDL_SCANCODE_F18 = 109,
    SDL_SCANCODE_F19 = 110,
    SDL_SCANCODE_F20 = 111,
    SDL_SCANCODE_F21 = 112,
    SDL_SCANCODE_F22 = 113,
    SDL_SCANCODE_F23 = 114,
    SDL_SCANCODE_F24 = 115,
    SDL_SCANCODE_EXECUTE = 116,
    SDL_SCANCODE_HELP = 117,
    SDL_SCANCODE_MENU = 118,
    SDL_SCANCODE_SELECT = 119,
    SDL_SCANCODE_STOP = 120,
    SDL_SCANCODE_AGAIN = 121,
    SDL_SCANCODE_UNDO = 122,
    SDL_SCANCODE_CUT = 123,
    SDL_SCANCODE_COPY = 124,
    SDL_SCANCODE_PASTE = 125,
    SDL_SCANCODE_FIND = 126,
    SDL_SCANCODE_MUTE = 127,
    SDL_SCANCODE_VOLUMEUP = 128,
    SDL_SCANCODE_VOLUMEDOWN = 129,
    SDL_SCANCODE_KP_COMMA = 133,
    SDL_SCANCODE_KP_EQUALSAS400 = 134,
    SDL_SCANCODE_INTERNATIONAL1 = 135,
    SDL_SCANCODE_INTERNATIONAL2 = 136,
    SDL_SCANCODE_INTERNATIONAL3 = 137,
    SDL_SCANCODE_INTERNATIONAL4 = 138,
    SDL_SCANCODE_INTERNATIONAL5 = 139,
    SDL_SCANCODE_INTERNATIONAL6 = 140,
    SDL_SCANCODE_INTERNATIONAL7 = 141,
    SDL_SCANCODE_INTERNATIONAL8 = 142,
    SDL_SCANCODE_INTERNATIONAL9 = 143,
    SDL_SCANCODE_LANG1 = 144,
    SDL_SCANCODE_LANG2 = 145,
    SDL_SCANCODE_LANG3 = 146,
    SDL_SCANCODE_LANG4 = 147,
    SDL_SCANCODE_LANG5 = 148,
    SDL_SCANCODE_LANG6 = 149,
    SDL_SCANCODE_LANG7 = 150,
    SDL_SCANCODE_LANG8 = 151,
    SDL_SCANCODE_LANG9 = 152,
    SDL_SCANCODE_ALTERASE = 153,
    SDL_SCANCODE_SYSREQ = 154,
    SDL_SCANCODE_CANCEL = 155,
    SDL_SCANCODE_CLEAR = 156,
    SDL_SCANCODE_PRIOR = 157,
    SDL_SCANCODE_RETURN2 = 158,
    SDL_SCANCODE_SEPARATOR = 159,
    SDL_SCANCODE_OUT = 160,
    SDL_SCANCODE_OPER = 161,
    SDL_SCANCODE_CLEARAGAIN = 162,
    SDL_SCANCODE_CRSEL = 163,
    SDL_SCANCODE_EXSEL = 164,
    SDL_SCANCODE_KP_00 = 176,
    SDL_SCANCODE_KP_000 = 177,
    SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
    SDL_SCANCODE_DECIMALSEPARATOR = 179,
    SDL_SCANCODE_CURRENCYUNIT = 180,
    SDL_SCANCODE_CURRENCYSUBUNIT = 181,
    SDL_SCANCODE_KP_LEFTPAREN = 182,
    SDL_SCANCODE_KP_RIGHTPAREN = 183,
    SDL_SCANCODE_KP_LEFTBRACE = 184,
    SDL_SCANCODE_KP_RIGHTBRACE = 185,
    SDL_SCANCODE_KP_TAB = 186,
    SDL_SCANCODE_KP_BACKSPACE = 187,
    SDL_SCANCODE_KP_A = 188,
    SDL_SCANCODE_KP_B = 189,
    SDL_SCANCODE_KP_C = 190,
    SDL_SCANCODE_KP_D = 191,
    SDL_SCANCODE_KP_E = 192,
    SDL_SCANCODE_KP_F = 193,
    SDL_SCANCODE_KP_XOR = 194,
    SDL_SCANCODE_KP_POWER = 195,
    SDL_SCANCODE_KP_PERCENT = 196,
    SDL_SCANCODE_KP_LESS = 197,
    SDL_SCANCODE_KP_GREATER = 198,
    SDL_SCANCODE_KP_AMPERSAND = 199,
    SDL_SCANCODE_KP_DBLAMPERSAND = 200,
    SDL_SCANCODE_KP_VERTICALBAR = 201,
    SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
    SDL_SCANCODE_KP_COLON = 203,
    SDL_SCANCODE_KP_HASH = 204,
    SDL_SCANCODE_KP_SPACE = 205,
    SDL_SCANCODE_KP_AT = 206,
    SDL_SCANCODE_KP_EXCLAM = 207,
    SDL_SCANCODE_KP_MEMSTORE = 208,
    SDL_SCANCODE_KP_MEMRECALL = 209,
    SDL_SCANCODE_KP_MEMCLEAR = 210,
    SDL_SCANCODE_KP_MEMADD = 211,
    SDL_SCANCODE_KP_MEMSUBTRACT = 212,
    SDL_SCANCODE_KP_MEMMULTIPLY = 213,
    SDL_SCANCODE_KP_MEMDIVIDE = 214,
    SDL_SCANCODE_KP_PLUSMINUS = 215,
    SDL_SCANCODE_KP_CLEAR = 216,
    SDL_SCANCODE_KP_CLEARENTRY = 217,
    SDL_SCANCODE_KP_BINARY = 218,
    SDL_SCANCODE_KP_OCTAL = 219,
    SDL_SCANCODE_KP_DECIMAL = 220,
    SDL_SCANCODE_KP_HEXADECIMAL = 221,
    SDL_SCANCODE_LCTRL = 224,
    SDL_SCANCODE_LSHIFT = 225,
    SDL_SCANCODE_LALT = 226,
    SDL_SCANCODE_LGUI = 227,
    SDL_SCANCODE_RCTRL = 228,
    SDL_SCANCODE_RSHIFT = 229,
    SDL_SCANCODE_RALT = 230,
    SDL_SCANCODE_RGUI = 231,
    SDL_SCANCODE_MODE = 257,
    SDL_SCANCODE_AUDIONEXT = 258,
    SDL_SCANCODE_AUDIOPREV = 259,
    SDL_SCANCODE_AUDIOSTOP = 260,
    SDL_SCANCODE_AUDIOPLAY = 261,
    SDL_SCANCODE_AUDIOMUTE = 262,
    SDL_SCANCODE_MEDIASELECT = 263,
    SDL_SCANCODE_WWW = 264,
    SDL_SCANCODE_MAIL = 265,
    SDL_SCANCODE_CALCULATOR = 266,
    SDL_SCANCODE_COMPUTER = 267,
    SDL_SCANCODE_AC_SEARCH = 268,
    SDL_SCANCODE_AC_HOME = 269,
    SDL_SCANCODE_AC_BACK = 270,
    SDL_SCANCODE_AC_FORWARD = 271,
    SDL_SCANCODE_AC_STOP = 272,
    SDL_SCANCODE_AC_REFRESH = 273,
    SDL_SCANCODE_AC_BOOKMARKS = 274,
    SDL_SCANCODE_BRIGHTNESSDOWN = 275,
    SDL_SCANCODE_BRIGHTNESSUP = 276,
    SDL_SCANCODE_DISPLAYSWITCH = 277,
    SDL_SCANCODE_KBDILLUMTOGGLE = 278,
    SDL_SCANCODE_KBDILLUMDOWN = 279,
    SDL_SCANCODE_KBDILLUMUP = 280,
    SDL_SCANCODE_EJECT = 281,
    SDL_SCANCODE_SLEEP = 282,
    SDL_SCANCODE_APP1 = 283,
    SDL_SCANCODE_APP2 = 284,
    SDL_SCANCODE_AUDIOREWIND = 285,
    SDL_SCANCODE_AUDIOFASTFORWARD = 286,
    SDL_NUM_SCANCODES = 512,
}
/// \brief The SDL virtual key representation.
///
/// Values of this type are used to represent keyboard keys using the current
/// layout of the keyboard.  These values include Unicode values representing
/// the unmodified character that would be generated by pressing the key, or
/// an SDLK_* constant for those keys that do not generate characters.
///
/// A special exception is the number keys at the top of the keyboard which
/// always map to SDLK_0...SDLK_9, regardless of layout.
pub type SDL_Keycode = Sint32;
pub const SDLK_UNKNOWN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_UNKNOWN;
pub const SDLK_RETURN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_RETURN;
pub const SDLK_ESCAPE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_ESCAPE;
pub const SDLK_BACKSPACE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_BACKSPACE;
pub const SDLK_TAB: _bindgen_ty_7 = _bindgen_ty_7::SDLK_TAB;
pub const SDLK_SPACE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_SPACE;
pub const SDLK_EXCLAIM: _bindgen_ty_7 = _bindgen_ty_7::SDLK_EXCLAIM;
pub const SDLK_QUOTEDBL: _bindgen_ty_7 = _bindgen_ty_7::SDLK_QUOTEDBL;
pub const SDLK_HASH: _bindgen_ty_7 = _bindgen_ty_7::SDLK_HASH;
pub const SDLK_PERCENT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_PERCENT;
pub const SDLK_DOLLAR: _bindgen_ty_7 = _bindgen_ty_7::SDLK_DOLLAR;
pub const SDLK_AMPERSAND: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AMPERSAND;
pub const SDLK_QUOTE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_QUOTE;
pub const SDLK_LEFTPAREN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_LEFTPAREN;
pub const SDLK_RIGHTPAREN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_RIGHTPAREN;
pub const SDLK_ASTERISK: _bindgen_ty_7 = _bindgen_ty_7::SDLK_ASTERISK;
pub const SDLK_PLUS: _bindgen_ty_7 = _bindgen_ty_7::SDLK_PLUS;
pub const SDLK_COMMA: _bindgen_ty_7 = _bindgen_ty_7::SDLK_COMMA;
pub const SDLK_MINUS: _bindgen_ty_7 = _bindgen_ty_7::SDLK_MINUS;
pub const SDLK_PERIOD: _bindgen_ty_7 = _bindgen_ty_7::SDLK_PERIOD;
pub const SDLK_SLASH: _bindgen_ty_7 = _bindgen_ty_7::SDLK_SLASH;
pub const SDLK_0: _bindgen_ty_7 = _bindgen_ty_7::SDLK_0;
pub const SDLK_1: _bindgen_ty_7 = _bindgen_ty_7::SDLK_1;
pub const SDLK_2: _bindgen_ty_7 = _bindgen_ty_7::SDLK_2;
pub const SDLK_3: _bindgen_ty_7 = _bindgen_ty_7::SDLK_3;
pub const SDLK_4: _bindgen_ty_7 = _bindgen_ty_7::SDLK_4;
pub const SDLK_5: _bindgen_ty_7 = _bindgen_ty_7::SDLK_5;
pub const SDLK_6: _bindgen_ty_7 = _bindgen_ty_7::SDLK_6;
pub const SDLK_7: _bindgen_ty_7 = _bindgen_ty_7::SDLK_7;
pub const SDLK_8: _bindgen_ty_7 = _bindgen_ty_7::SDLK_8;
pub const SDLK_9: _bindgen_ty_7 = _bindgen_ty_7::SDLK_9;
pub const SDLK_COLON: _bindgen_ty_7 = _bindgen_ty_7::SDLK_COLON;
pub const SDLK_SEMICOLON: _bindgen_ty_7 = _bindgen_ty_7::SDLK_SEMICOLON;
pub const SDLK_LESS: _bindgen_ty_7 = _bindgen_ty_7::SDLK_LESS;
pub const SDLK_EQUALS: _bindgen_ty_7 = _bindgen_ty_7::SDLK_EQUALS;
pub const SDLK_GREATER: _bindgen_ty_7 = _bindgen_ty_7::SDLK_GREATER;
pub const SDLK_QUESTION: _bindgen_ty_7 = _bindgen_ty_7::SDLK_QUESTION;
pub const SDLK_AT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AT;
pub const SDLK_LEFTBRACKET: _bindgen_ty_7 = _bindgen_ty_7::SDLK_LEFTBRACKET;
pub const SDLK_BACKSLASH: _bindgen_ty_7 = _bindgen_ty_7::SDLK_BACKSLASH;
pub const SDLK_RIGHTBRACKET: _bindgen_ty_7 = _bindgen_ty_7::SDLK_RIGHTBRACKET;
pub const SDLK_CARET: _bindgen_ty_7 = _bindgen_ty_7::SDLK_CARET;
pub const SDLK_UNDERSCORE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_UNDERSCORE;
pub const SDLK_BACKQUOTE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_BACKQUOTE;
pub const SDLK_a: _bindgen_ty_7 = _bindgen_ty_7::SDLK_a;
pub const SDLK_b: _bindgen_ty_7 = _bindgen_ty_7::SDLK_b;
pub const SDLK_c: _bindgen_ty_7 = _bindgen_ty_7::SDLK_c;
pub const SDLK_d: _bindgen_ty_7 = _bindgen_ty_7::SDLK_d;
pub const SDLK_e: _bindgen_ty_7 = _bindgen_ty_7::SDLK_e;
pub const SDLK_f: _bindgen_ty_7 = _bindgen_ty_7::SDLK_f;
pub const SDLK_g: _bindgen_ty_7 = _bindgen_ty_7::SDLK_g;
pub const SDLK_h: _bindgen_ty_7 = _bindgen_ty_7::SDLK_h;
pub const SDLK_i: _bindgen_ty_7 = _bindgen_ty_7::SDLK_i;
pub const SDLK_j: _bindgen_ty_7 = _bindgen_ty_7::SDLK_j;
pub const SDLK_k: _bindgen_ty_7 = _bindgen_ty_7::SDLK_k;
pub const SDLK_l: _bindgen_ty_7 = _bindgen_ty_7::SDLK_l;
pub const SDLK_m: _bindgen_ty_7 = _bindgen_ty_7::SDLK_m;
pub const SDLK_n: _bindgen_ty_7 = _bindgen_ty_7::SDLK_n;
pub const SDLK_o: _bindgen_ty_7 = _bindgen_ty_7::SDLK_o;
pub const SDLK_p: _bindgen_ty_7 = _bindgen_ty_7::SDLK_p;
pub const SDLK_q: _bindgen_ty_7 = _bindgen_ty_7::SDLK_q;
pub const SDLK_r: _bindgen_ty_7 = _bindgen_ty_7::SDLK_r;
pub const SDLK_s: _bindgen_ty_7 = _bindgen_ty_7::SDLK_s;
pub const SDLK_t: _bindgen_ty_7 = _bindgen_ty_7::SDLK_t;
pub const SDLK_u: _bindgen_ty_7 = _bindgen_ty_7::SDLK_u;
pub const SDLK_v: _bindgen_ty_7 = _bindgen_ty_7::SDLK_v;
pub const SDLK_w: _bindgen_ty_7 = _bindgen_ty_7::SDLK_w;
pub const SDLK_x: _bindgen_ty_7 = _bindgen_ty_7::SDLK_x;
pub const SDLK_y: _bindgen_ty_7 = _bindgen_ty_7::SDLK_y;
pub const SDLK_z: _bindgen_ty_7 = _bindgen_ty_7::SDLK_z;
pub const SDLK_CAPSLOCK: _bindgen_ty_7 = _bindgen_ty_7::SDLK_CAPSLOCK;
pub const SDLK_F1: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F1;
pub const SDLK_F2: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F2;
pub const SDLK_F3: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F3;
pub const SDLK_F4: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F4;
pub const SDLK_F5: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F5;
pub const SDLK_F6: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F6;
pub const SDLK_F7: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F7;
pub const SDLK_F8: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F8;
pub const SDLK_F9: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F9;
pub const SDLK_F10: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F10;
pub const SDLK_F11: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F11;
pub const SDLK_F12: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F12;
pub const SDLK_PRINTSCREEN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_PRINTSCREEN;
pub const SDLK_SCROLLLOCK: _bindgen_ty_7 = _bindgen_ty_7::SDLK_SCROLLLOCK;
pub const SDLK_PAUSE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_PAUSE;
pub const SDLK_INSERT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_INSERT;
pub const SDLK_HOME: _bindgen_ty_7 = _bindgen_ty_7::SDLK_HOME;
pub const SDLK_PAGEUP: _bindgen_ty_7 = _bindgen_ty_7::SDLK_PAGEUP;
pub const SDLK_DELETE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_DELETE;
pub const SDLK_END: _bindgen_ty_7 = _bindgen_ty_7::SDLK_END;
pub const SDLK_PAGEDOWN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_PAGEDOWN;
pub const SDLK_RIGHT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_RIGHT;
pub const SDLK_LEFT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_LEFT;
pub const SDLK_DOWN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_DOWN;
pub const SDLK_UP: _bindgen_ty_7 = _bindgen_ty_7::SDLK_UP;
pub const SDLK_NUMLOCKCLEAR: _bindgen_ty_7 = _bindgen_ty_7::SDLK_NUMLOCKCLEAR;
pub const SDLK_KP_DIVIDE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_DIVIDE;
pub const SDLK_KP_MULTIPLY: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_MULTIPLY;
pub const SDLK_KP_MINUS: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_MINUS;
pub const SDLK_KP_PLUS: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_PLUS;
pub const SDLK_KP_ENTER: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_ENTER;
pub const SDLK_KP_1: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_1;
pub const SDLK_KP_2: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_2;
pub const SDLK_KP_3: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_3;
pub const SDLK_KP_4: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_4;
pub const SDLK_KP_5: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_5;
pub const SDLK_KP_6: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_6;
pub const SDLK_KP_7: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_7;
pub const SDLK_KP_8: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_8;
pub const SDLK_KP_9: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_9;
pub const SDLK_KP_0: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_0;
pub const SDLK_KP_PERIOD: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_PERIOD;
pub const SDLK_APPLICATION: _bindgen_ty_7 = _bindgen_ty_7::SDLK_APPLICATION;
pub const SDLK_POWER: _bindgen_ty_7 = _bindgen_ty_7::SDLK_POWER;
pub const SDLK_KP_EQUALS: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_EQUALS;
pub const SDLK_F13: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F13;
pub const SDLK_F14: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F14;
pub const SDLK_F15: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F15;
pub const SDLK_F16: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F16;
pub const SDLK_F17: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F17;
pub const SDLK_F18: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F18;
pub const SDLK_F19: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F19;
pub const SDLK_F20: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F20;
pub const SDLK_F21: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F21;
pub const SDLK_F22: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F22;
pub const SDLK_F23: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F23;
pub const SDLK_F24: _bindgen_ty_7 = _bindgen_ty_7::SDLK_F24;
pub const SDLK_EXECUTE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_EXECUTE;
pub const SDLK_HELP: _bindgen_ty_7 = _bindgen_ty_7::SDLK_HELP;
pub const SDLK_MENU: _bindgen_ty_7 = _bindgen_ty_7::SDLK_MENU;
pub const SDLK_SELECT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_SELECT;
pub const SDLK_STOP: _bindgen_ty_7 = _bindgen_ty_7::SDLK_STOP;
pub const SDLK_AGAIN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AGAIN;
pub const SDLK_UNDO: _bindgen_ty_7 = _bindgen_ty_7::SDLK_UNDO;
pub const SDLK_CUT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_CUT;
pub const SDLK_COPY: _bindgen_ty_7 = _bindgen_ty_7::SDLK_COPY;
pub const SDLK_PASTE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_PASTE;
pub const SDLK_FIND: _bindgen_ty_7 = _bindgen_ty_7::SDLK_FIND;
pub const SDLK_MUTE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_MUTE;
pub const SDLK_VOLUMEUP: _bindgen_ty_7 = _bindgen_ty_7::SDLK_VOLUMEUP;
pub const SDLK_VOLUMEDOWN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_VOLUMEDOWN;
pub const SDLK_KP_COMMA: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_COMMA;
pub const SDLK_KP_EQUALSAS400: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_KP_EQUALSAS400;
pub const SDLK_ALTERASE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_ALTERASE;
pub const SDLK_SYSREQ: _bindgen_ty_7 = _bindgen_ty_7::SDLK_SYSREQ;
pub const SDLK_CANCEL: _bindgen_ty_7 = _bindgen_ty_7::SDLK_CANCEL;
pub const SDLK_CLEAR: _bindgen_ty_7 = _bindgen_ty_7::SDLK_CLEAR;
pub const SDLK_PRIOR: _bindgen_ty_7 = _bindgen_ty_7::SDLK_PRIOR;
pub const SDLK_RETURN2: _bindgen_ty_7 = _bindgen_ty_7::SDLK_RETURN2;
pub const SDLK_SEPARATOR: _bindgen_ty_7 = _bindgen_ty_7::SDLK_SEPARATOR;
pub const SDLK_OUT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_OUT;
pub const SDLK_OPER: _bindgen_ty_7 = _bindgen_ty_7::SDLK_OPER;
pub const SDLK_CLEARAGAIN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_CLEARAGAIN;
pub const SDLK_CRSEL: _bindgen_ty_7 = _bindgen_ty_7::SDLK_CRSEL;
pub const SDLK_EXSEL: _bindgen_ty_7 = _bindgen_ty_7::SDLK_EXSEL;
pub const SDLK_KP_00: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_00;
pub const SDLK_KP_000: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_000;
pub const SDLK_THOUSANDSSEPARATOR: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_THOUSANDSSEPARATOR;
pub const SDLK_DECIMALSEPARATOR: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_DECIMALSEPARATOR;
pub const SDLK_CURRENCYUNIT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_CURRENCYUNIT;
pub const SDLK_CURRENCYSUBUNIT: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_CURRENCYSUBUNIT;
pub const SDLK_KP_LEFTPAREN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_LEFTPAREN;
pub const SDLK_KP_RIGHTPAREN: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_KP_RIGHTPAREN;
pub const SDLK_KP_LEFTBRACE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_LEFTBRACE;
pub const SDLK_KP_RIGHTBRACE: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_KP_RIGHTBRACE;
pub const SDLK_KP_TAB: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_TAB;
pub const SDLK_KP_BACKSPACE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_BACKSPACE;
pub const SDLK_KP_A: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_A;
pub const SDLK_KP_B: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_B;
pub const SDLK_KP_C: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_C;
pub const SDLK_KP_D: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_D;
pub const SDLK_KP_E: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_E;
pub const SDLK_KP_F: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_F;
pub const SDLK_KP_XOR: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_XOR;
pub const SDLK_KP_POWER: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_POWER;
pub const SDLK_KP_PERCENT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_PERCENT;
pub const SDLK_KP_LESS: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_LESS;
pub const SDLK_KP_GREATER: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_GREATER;
pub const SDLK_KP_AMPERSAND: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_AMPERSAND;
pub const SDLK_KP_DBLAMPERSAND: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_KP_DBLAMPERSAND;
pub const SDLK_KP_VERTICALBAR: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_KP_VERTICALBAR;
pub const SDLK_KP_DBLVERTICALBAR: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_KP_DBLVERTICALBAR;
pub const SDLK_KP_COLON: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_COLON;
pub const SDLK_KP_HASH: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_HASH;
pub const SDLK_KP_SPACE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_SPACE;
pub const SDLK_KP_AT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_AT;
pub const SDLK_KP_EXCLAM: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_EXCLAM;
pub const SDLK_KP_MEMSTORE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_MEMSTORE;
pub const SDLK_KP_MEMRECALL: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_MEMRECALL;
pub const SDLK_KP_MEMCLEAR: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_MEMCLEAR;
pub const SDLK_KP_MEMADD: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_MEMADD;
pub const SDLK_KP_MEMSUBTRACT: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_KP_MEMSUBTRACT;
pub const SDLK_KP_MEMMULTIPLY: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_KP_MEMMULTIPLY;
pub const SDLK_KP_MEMDIVIDE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_MEMDIVIDE;
pub const SDLK_KP_PLUSMINUS: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_PLUSMINUS;
pub const SDLK_KP_CLEAR: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_CLEAR;
pub const SDLK_KP_CLEARENTRY: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_KP_CLEARENTRY;
pub const SDLK_KP_BINARY: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_BINARY;
pub const SDLK_KP_OCTAL: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_OCTAL;
pub const SDLK_KP_DECIMAL: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KP_DECIMAL;
pub const SDLK_KP_HEXADECIMAL: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_KP_HEXADECIMAL;
pub const SDLK_LCTRL: _bindgen_ty_7 = _bindgen_ty_7::SDLK_LCTRL;
pub const SDLK_LSHIFT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_LSHIFT;
pub const SDLK_LALT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_LALT;
pub const SDLK_LGUI: _bindgen_ty_7 = _bindgen_ty_7::SDLK_LGUI;
pub const SDLK_RCTRL: _bindgen_ty_7 = _bindgen_ty_7::SDLK_RCTRL;
pub const SDLK_RSHIFT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_RSHIFT;
pub const SDLK_RALT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_RALT;
pub const SDLK_RGUI: _bindgen_ty_7 = _bindgen_ty_7::SDLK_RGUI;
pub const SDLK_MODE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_MODE;
pub const SDLK_AUDIONEXT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AUDIONEXT;
pub const SDLK_AUDIOPREV: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AUDIOPREV;
pub const SDLK_AUDIOSTOP: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AUDIOSTOP;
pub const SDLK_AUDIOPLAY: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AUDIOPLAY;
pub const SDLK_AUDIOMUTE: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AUDIOMUTE;
pub const SDLK_MEDIASELECT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_MEDIASELECT;
pub const SDLK_WWW: _bindgen_ty_7 = _bindgen_ty_7::SDLK_WWW;
pub const SDLK_MAIL: _bindgen_ty_7 = _bindgen_ty_7::SDLK_MAIL;
pub const SDLK_CALCULATOR: _bindgen_ty_7 = _bindgen_ty_7::SDLK_CALCULATOR;
pub const SDLK_COMPUTER: _bindgen_ty_7 = _bindgen_ty_7::SDLK_COMPUTER;
pub const SDLK_AC_SEARCH: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AC_SEARCH;
pub const SDLK_AC_HOME: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AC_HOME;
pub const SDLK_AC_BACK: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AC_BACK;
pub const SDLK_AC_FORWARD: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AC_FORWARD;
pub const SDLK_AC_STOP: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AC_STOP;
pub const SDLK_AC_REFRESH: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AC_REFRESH;
pub const SDLK_AC_BOOKMARKS: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AC_BOOKMARKS;
pub const SDLK_BRIGHTNESSDOWN: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_BRIGHTNESSDOWN;
pub const SDLK_BRIGHTNESSUP: _bindgen_ty_7 = _bindgen_ty_7::SDLK_BRIGHTNESSUP;
pub const SDLK_DISPLAYSWITCH: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_DISPLAYSWITCH;
pub const SDLK_KBDILLUMTOGGLE: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_KBDILLUMTOGGLE;
pub const SDLK_KBDILLUMDOWN: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KBDILLUMDOWN;
pub const SDLK_KBDILLUMUP: _bindgen_ty_7 = _bindgen_ty_7::SDLK_KBDILLUMUP;
pub const SDLK_EJECT: _bindgen_ty_7 = _bindgen_ty_7::SDLK_EJECT;
pub const SDLK_SLEEP: _bindgen_ty_7 = _bindgen_ty_7::SDLK_SLEEP;
pub const SDLK_APP1: _bindgen_ty_7 = _bindgen_ty_7::SDLK_APP1;
pub const SDLK_APP2: _bindgen_ty_7 = _bindgen_ty_7::SDLK_APP2;
pub const SDLK_AUDIOREWIND: _bindgen_ty_7 = _bindgen_ty_7::SDLK_AUDIOREWIND;
pub const SDLK_AUDIOFASTFORWARD: _bindgen_ty_7 =
    _bindgen_ty_7::SDLK_AUDIOFASTFORWARD;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 {
    SDLK_UNKNOWN = 0,
    SDLK_RETURN = 13,
    SDLK_ESCAPE = 27,
    SDLK_BACKSPACE = 8,
    SDLK_TAB = 9,
    SDLK_SPACE = 32,
    SDLK_EXCLAIM = 33,
    SDLK_QUOTEDBL = 34,
    SDLK_HASH = 35,
    SDLK_PERCENT = 37,
    SDLK_DOLLAR = 36,
    SDLK_AMPERSAND = 38,
    SDLK_QUOTE = 39,
    SDLK_LEFTPAREN = 40,
    SDLK_RIGHTPAREN = 41,
    SDLK_ASTERISK = 42,
    SDLK_PLUS = 43,
    SDLK_COMMA = 44,
    SDLK_MINUS = 45,
    SDLK_PERIOD = 46,
    SDLK_SLASH = 47,
    SDLK_0 = 48,
    SDLK_1 = 49,
    SDLK_2 = 50,
    SDLK_3 = 51,
    SDLK_4 = 52,
    SDLK_5 = 53,
    SDLK_6 = 54,
    SDLK_7 = 55,
    SDLK_8 = 56,
    SDLK_9 = 57,
    SDLK_COLON = 58,
    SDLK_SEMICOLON = 59,
    SDLK_LESS = 60,
    SDLK_EQUALS = 61,
    SDLK_GREATER = 62,
    SDLK_QUESTION = 63,
    SDLK_AT = 64,
    SDLK_LEFTBRACKET = 91,
    SDLK_BACKSLASH = 92,
    SDLK_RIGHTBRACKET = 93,
    SDLK_CARET = 94,
    SDLK_UNDERSCORE = 95,
    SDLK_BACKQUOTE = 96,
    SDLK_a = 97,
    SDLK_b = 98,
    SDLK_c = 99,
    SDLK_d = 100,
    SDLK_e = 101,
    SDLK_f = 102,
    SDLK_g = 103,
    SDLK_h = 104,
    SDLK_i = 105,
    SDLK_j = 106,
    SDLK_k = 107,
    SDLK_l = 108,
    SDLK_m = 109,
    SDLK_n = 110,
    SDLK_o = 111,
    SDLK_p = 112,
    SDLK_q = 113,
    SDLK_r = 114,
    SDLK_s = 115,
    SDLK_t = 116,
    SDLK_u = 117,
    SDLK_v = 118,
    SDLK_w = 119,
    SDLK_x = 120,
    SDLK_y = 121,
    SDLK_z = 122,
    SDLK_CAPSLOCK = 1073741881,
    SDLK_F1 = 1073741882,
    SDLK_F2 = 1073741883,
    SDLK_F3 = 1073741884,
    SDLK_F4 = 1073741885,
    SDLK_F5 = 1073741886,
    SDLK_F6 = 1073741887,
    SDLK_F7 = 1073741888,
    SDLK_F8 = 1073741889,
    SDLK_F9 = 1073741890,
    SDLK_F10 = 1073741891,
    SDLK_F11 = 1073741892,
    SDLK_F12 = 1073741893,
    SDLK_PRINTSCREEN = 1073741894,
    SDLK_SCROLLLOCK = 1073741895,
    SDLK_PAUSE = 1073741896,
    SDLK_INSERT = 1073741897,
    SDLK_HOME = 1073741898,
    SDLK_PAGEUP = 1073741899,
    SDLK_DELETE = 127,
    SDLK_END = 1073741901,
    SDLK_PAGEDOWN = 1073741902,
    SDLK_RIGHT = 1073741903,
    SDLK_LEFT = 1073741904,
    SDLK_DOWN = 1073741905,
    SDLK_UP = 1073741906,
    SDLK_NUMLOCKCLEAR = 1073741907,
    SDLK_KP_DIVIDE = 1073741908,
    SDLK_KP_MULTIPLY = 1073741909,
    SDLK_KP_MINUS = 1073741910,
    SDLK_KP_PLUS = 1073741911,
    SDLK_KP_ENTER = 1073741912,
    SDLK_KP_1 = 1073741913,
    SDLK_KP_2 = 1073741914,
    SDLK_KP_3 = 1073741915,
    SDLK_KP_4 = 1073741916,
    SDLK_KP_5 = 1073741917,
    SDLK_KP_6 = 1073741918,
    SDLK_KP_7 = 1073741919,
    SDLK_KP_8 = 1073741920,
    SDLK_KP_9 = 1073741921,
    SDLK_KP_0 = 1073741922,
    SDLK_KP_PERIOD = 1073741923,
    SDLK_APPLICATION = 1073741925,
    SDLK_POWER = 1073741926,
    SDLK_KP_EQUALS = 1073741927,
    SDLK_F13 = 1073741928,
    SDLK_F14 = 1073741929,
    SDLK_F15 = 1073741930,
    SDLK_F16 = 1073741931,
    SDLK_F17 = 1073741932,
    SDLK_F18 = 1073741933,
    SDLK_F19 = 1073741934,
    SDLK_F20 = 1073741935,
    SDLK_F21 = 1073741936,
    SDLK_F22 = 1073741937,
    SDLK_F23 = 1073741938,
    SDLK_F24 = 1073741939,
    SDLK_EXECUTE = 1073741940,
    SDLK_HELP = 1073741941,
    SDLK_MENU = 1073741942,
    SDLK_SELECT = 1073741943,
    SDLK_STOP = 1073741944,
    SDLK_AGAIN = 1073741945,
    SDLK_UNDO = 1073741946,
    SDLK_CUT = 1073741947,
    SDLK_COPY = 1073741948,
    SDLK_PASTE = 1073741949,
    SDLK_FIND = 1073741950,
    SDLK_MUTE = 1073741951,
    SDLK_VOLUMEUP = 1073741952,
    SDLK_VOLUMEDOWN = 1073741953,
    SDLK_KP_COMMA = 1073741957,
    SDLK_KP_EQUALSAS400 = 1073741958,
    SDLK_ALTERASE = 1073741977,
    SDLK_SYSREQ = 1073741978,
    SDLK_CANCEL = 1073741979,
    SDLK_CLEAR = 1073741980,
    SDLK_PRIOR = 1073741981,
    SDLK_RETURN2 = 1073741982,
    SDLK_SEPARATOR = 1073741983,
    SDLK_OUT = 1073741984,
    SDLK_OPER = 1073741985,
    SDLK_CLEARAGAIN = 1073741986,
    SDLK_CRSEL = 1073741987,
    SDLK_EXSEL = 1073741988,
    SDLK_KP_00 = 1073742000,
    SDLK_KP_000 = 1073742001,
    SDLK_THOUSANDSSEPARATOR = 1073742002,
    SDLK_DECIMALSEPARATOR = 1073742003,
    SDLK_CURRENCYUNIT = 1073742004,
    SDLK_CURRENCYSUBUNIT = 1073742005,
    SDLK_KP_LEFTPAREN = 1073742006,
    SDLK_KP_RIGHTPAREN = 1073742007,
    SDLK_KP_LEFTBRACE = 1073742008,
    SDLK_KP_RIGHTBRACE = 1073742009,
    SDLK_KP_TAB = 1073742010,
    SDLK_KP_BACKSPACE = 1073742011,
    SDLK_KP_A = 1073742012,
    SDLK_KP_B = 1073742013,
    SDLK_KP_C = 1073742014,
    SDLK_KP_D = 1073742015,
    SDLK_KP_E = 1073742016,
    SDLK_KP_F = 1073742017,
    SDLK_KP_XOR = 1073742018,
    SDLK_KP_POWER = 1073742019,
    SDLK_KP_PERCENT = 1073742020,
    SDLK_KP_LESS = 1073742021,
    SDLK_KP_GREATER = 1073742022,
    SDLK_KP_AMPERSAND = 1073742023,
    SDLK_KP_DBLAMPERSAND = 1073742024,
    SDLK_KP_VERTICALBAR = 1073742025,
    SDLK_KP_DBLVERTICALBAR = 1073742026,
    SDLK_KP_COLON = 1073742027,
    SDLK_KP_HASH = 1073742028,
    SDLK_KP_SPACE = 1073742029,
    SDLK_KP_AT = 1073742030,
    SDLK_KP_EXCLAM = 1073742031,
    SDLK_KP_MEMSTORE = 1073742032,
    SDLK_KP_MEMRECALL = 1073742033,
    SDLK_KP_MEMCLEAR = 1073742034,
    SDLK_KP_MEMADD = 1073742035,
    SDLK_KP_MEMSUBTRACT = 1073742036,
    SDLK_KP_MEMMULTIPLY = 1073742037,
    SDLK_KP_MEMDIVIDE = 1073742038,
    SDLK_KP_PLUSMINUS = 1073742039,
    SDLK_KP_CLEAR = 1073742040,
    SDLK_KP_CLEARENTRY = 1073742041,
    SDLK_KP_BINARY = 1073742042,
    SDLK_KP_OCTAL = 1073742043,
    SDLK_KP_DECIMAL = 1073742044,
    SDLK_KP_HEXADECIMAL = 1073742045,
    SDLK_LCTRL = 1073742048,
    SDLK_LSHIFT = 1073742049,
    SDLK_LALT = 1073742050,
    SDLK_LGUI = 1073742051,
    SDLK_RCTRL = 1073742052,
    SDLK_RSHIFT = 1073742053,
    SDLK_RALT = 1073742054,
    SDLK_RGUI = 1073742055,
    SDLK_MODE = 1073742081,
    SDLK_AUDIONEXT = 1073742082,
    SDLK_AUDIOPREV = 1073742083,
    SDLK_AUDIOSTOP = 1073742084,
    SDLK_AUDIOPLAY = 1073742085,
    SDLK_AUDIOMUTE = 1073742086,
    SDLK_MEDIASELECT = 1073742087,
    SDLK_WWW = 1073742088,
    SDLK_MAIL = 1073742089,
    SDLK_CALCULATOR = 1073742090,
    SDLK_COMPUTER = 1073742091,
    SDLK_AC_SEARCH = 1073742092,
    SDLK_AC_HOME = 1073742093,
    SDLK_AC_BACK = 1073742094,
    SDLK_AC_FORWARD = 1073742095,
    SDLK_AC_STOP = 1073742096,
    SDLK_AC_REFRESH = 1073742097,
    SDLK_AC_BOOKMARKS = 1073742098,
    SDLK_BRIGHTNESSDOWN = 1073742099,
    SDLK_BRIGHTNESSUP = 1073742100,
    SDLK_DISPLAYSWITCH = 1073742101,
    SDLK_KBDILLUMTOGGLE = 1073742102,
    SDLK_KBDILLUMDOWN = 1073742103,
    SDLK_KBDILLUMUP = 1073742104,
    SDLK_EJECT = 1073742105,
    SDLK_SLEEP = 1073742106,
    SDLK_APP1 = 1073742107,
    SDLK_APP2 = 1073742108,
    SDLK_AUDIOREWIND = 1073742109,
    SDLK_AUDIOFASTFORWARD = 1073742110,
}
#[repr(u32)]
/// \brief Enumeration of valid key mods (possibly OR'd together).
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_Keymod {
    KMOD_NONE = 0,
    KMOD_LSHIFT = 1,
    KMOD_RSHIFT = 2,
    KMOD_LCTRL = 64,
    KMOD_RCTRL = 128,
    KMOD_LALT = 256,
    KMOD_RALT = 512,
    KMOD_LGUI = 1024,
    KMOD_RGUI = 2048,
    KMOD_NUM = 4096,
    KMOD_CAPS = 8192,
    KMOD_MODE = 16384,
    KMOD_RESERVED = 32768,
}
/// \brief The SDL keysym structure, used in key events.
///
/// \note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_Keysym {
    /// < SDL physical key code - see ::SDL_Scancode for details
    pub scancode: SDL_Scancode,
    /// < SDL virtual key code - see ::SDL_Keycode for details
    pub sym: SDL_Keycode,
    /// < current key modifiers
    pub mod_: Uint16,
    pub unused: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_Keysym() {
    assert_eq!(::std::mem::size_of::<SDL_Keysym>() , 16usize , concat ! (
               "Size of: " , stringify ! ( SDL_Keysym ) ));
    assert_eq! (::std::mem::align_of::<SDL_Keysym>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( SDL_Keysym ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Keysym ) ) . scancode as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Keysym ) , "::" ,
                stringify ! ( scancode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Keysym ) ) . sym as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Keysym ) , "::" ,
                stringify ! ( sym ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Keysym ) ) . mod_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Keysym ) , "::" ,
                stringify ! ( mod_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Keysym ) ) . unused as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Keysym ) , "::" ,
                stringify ! ( unused ) ));
}
impl Clone for SDL_Keysym {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// \brief Get the window which currently has keyboard focus.
    pub fn SDL_GetKeyboardFocus() -> *mut SDL_Window;
}
extern "C" {
    /// \brief Get a snapshot of the current state of the keyboard.
///
/// \param numkeys if non-NULL, receives the length of the returned array.
///
/// \return An array of key states. Indexes into this array are obtained by using ::SDL_Scancode values.
///
/// \b Example:
/// \code
/// const Uint8 *state = SDL_GetKeyboardState(NULL);
/// if ( state[SDL_SCANCODE_RETURN] )   {
/// printf("<RETURN> is pressed.\n");
/// }
/// \endcode
    pub fn SDL_GetKeyboardState(numkeys: *mut ::std::os::raw::c_int)
     -> *const Uint8;
}
extern "C" {
    /// \brief Get the current key modifier state for the keyboard.
    pub fn SDL_GetModState() -> SDL_Keymod;
}
extern "C" {
    /// \brief Set the current key modifier state for the keyboard.
///
/// \note This does not change the keyboard state, only the key modifier flags.
    pub fn SDL_SetModState(modstate: SDL_Keymod);
}
extern "C" {
    /// \brief Get the key code corresponding to the given scancode according
/// to the current keyboard layout.
///
/// See ::SDL_Keycode for details.
///
/// \sa SDL_GetKeyName()
    pub fn SDL_GetKeyFromScancode(scancode: SDL_Scancode) -> SDL_Keycode;
}
extern "C" {
    /// \brief Get the scancode corresponding to the given key code according to the
/// current keyboard layout.
///
/// See ::SDL_Scancode for details.
///
/// \sa SDL_GetScancodeName()
    pub fn SDL_GetScancodeFromKey(key: SDL_Keycode) -> SDL_Scancode;
}
extern "C" {
    /// \brief Get a human-readable name for a scancode.
///
/// \return A pointer to the name for the scancode.
/// If the scancode doesn't have a name, this function returns
/// an empty string ("").
///
/// \sa SDL_Scancode
    pub fn SDL_GetScancodeName(scancode: SDL_Scancode)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Get a scancode from a human-readable name
///
/// \return scancode, or SDL_SCANCODE_UNKNOWN if the name wasn't recognized
///
/// \sa SDL_Scancode
    pub fn SDL_GetScancodeFromName(name: *const ::std::os::raw::c_char)
     -> SDL_Scancode;
}
extern "C" {
    /// \brief Get a human-readable name for a key.
///
/// \return A pointer to a UTF-8 string that stays valid at least until the next
/// call to this function. If you need it around any longer, you must
/// copy it.  If the key doesn't have a name, this function returns an
/// empty string ("").
///
/// \sa SDL_Keycode
    pub fn SDL_GetKeyName(key: SDL_Keycode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Get a key code from a human-readable name
///
/// \return key code, or SDLK_UNKNOWN if the name wasn't recognized
///
/// \sa SDL_Keycode
    pub fn SDL_GetKeyFromName(name: *const ::std::os::raw::c_char)
     -> SDL_Keycode;
}
extern "C" {
    /// \brief Start accepting Unicode text input events.
/// This function will show the on-screen keyboard if supported.
///
/// \sa SDL_StopTextInput()
/// \sa SDL_SetTextInputRect()
/// \sa SDL_HasScreenKeyboardSupport()
    pub fn SDL_StartTextInput();
}
extern "C" {
    /// \brief Return whether or not Unicode text input events are enabled.
///
/// \sa SDL_StartTextInput()
/// \sa SDL_StopTextInput()
    pub fn SDL_IsTextInputActive() -> SDL_bool;
}
extern "C" {
    /// \brief Stop receiving any text input events.
/// This function will hide the on-screen keyboard if supported.
///
/// \sa SDL_StartTextInput()
/// \sa SDL_HasScreenKeyboardSupport()
    pub fn SDL_StopTextInput();
}
extern "C" {
    /// \brief Set the rectangle used to type Unicode text inputs.
/// This is used as a hint for IME and on-screen keyboard placement.
///
/// \sa SDL_StartTextInput()
    pub fn SDL_SetTextInputRect(rect: *mut SDL_Rect);
}
extern "C" {
    /// \brief Returns whether the platform has some screen keyboard support.
///
/// \return SDL_TRUE if some keyboard support is available else SDL_FALSE.
///
/// \note Not all screen keyboard functions are supported on all platforms.
///
/// \sa SDL_IsScreenKeyboardShown()
    pub fn SDL_HasScreenKeyboardSupport() -> SDL_bool;
}
extern "C" {
    /// \brief Returns whether the screen keyboard is shown for given window.
///
/// \param window The window for which screen keyboard should be queried.
///
/// \return SDL_TRUE if screen keyboard is shown else SDL_FALSE.
///
/// \sa SDL_HasScreenKeyboardSupport()
    pub fn SDL_IsScreenKeyboardShown(window: *mut SDL_Window) -> SDL_bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Cursor {
    _unused: [u8; 0],
}
#[repr(u32)]
/// \brief Cursor types for SDL_CreateSystemCursor().
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_SystemCursor {
    SDL_SYSTEM_CURSOR_ARROW = 0,
    SDL_SYSTEM_CURSOR_IBEAM = 1,
    SDL_SYSTEM_CURSOR_WAIT = 2,
    SDL_SYSTEM_CURSOR_CROSSHAIR = 3,
    SDL_SYSTEM_CURSOR_WAITARROW = 4,
    SDL_SYSTEM_CURSOR_SIZENWSE = 5,
    SDL_SYSTEM_CURSOR_SIZENESW = 6,
    SDL_SYSTEM_CURSOR_SIZEWE = 7,
    SDL_SYSTEM_CURSOR_SIZENS = 8,
    SDL_SYSTEM_CURSOR_SIZEALL = 9,
    SDL_SYSTEM_CURSOR_NO = 10,
    SDL_SYSTEM_CURSOR_HAND = 11,
    SDL_NUM_SYSTEM_CURSORS = 12,
}
#[repr(u32)]
/// \brief Scroll direction types for the Scroll event
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_MouseWheelDirection {
    SDL_MOUSEWHEEL_NORMAL = 0,
    SDL_MOUSEWHEEL_FLIPPED = 1,
}
extern "C" {
    /// \brief Get the window which currently has mouse focus.
    pub fn SDL_GetMouseFocus() -> *mut SDL_Window;
}
extern "C" {
    /// \brief Retrieve the current state of the mouse.
///
/// The current button state is returned as a button bitmask, which can
/// be tested using the SDL_BUTTON(X) macros, and x and y are set to the
/// mouse cursor position relative to the focus window for the currently
/// selected mouse.  You can pass NULL for either x or y.
    pub fn SDL_GetMouseState(x: *mut ::std::os::raw::c_int,
                             y: *mut ::std::os::raw::c_int) -> Uint32;
}
extern "C" {
    /// \brief Get the current state of the mouse, in relation to the desktop
///
/// This works just like SDL_GetMouseState(), but the coordinates will be
/// reported relative to the top-left of the desktop. This can be useful if
/// you need to track the mouse outside of a specific window and
/// SDL_CaptureMouse() doesn't fit your needs. For example, it could be
/// useful if you need to track the mouse while dragging a window, where
/// coordinates relative to a window might not be in sync at all times.
///
/// \note SDL_GetMouseState() returns the mouse position as SDL understands
/// it from the last pump of the event queue. This function, however,
/// queries the OS for the current mouse position, and as such, might
/// be a slightly less efficient function. Unless you know what you're
/// doing and have a good reason to use this function, you probably want
/// SDL_GetMouseState() instead.
///
/// \param x Returns the current X coord, relative to the desktop. Can be NULL.
/// \param y Returns the current Y coord, relative to the desktop. Can be NULL.
/// \return The current button state as a bitmask, which can be tested using the SDL_BUTTON(X) macros.
///
/// \sa SDL_GetMouseState
    pub fn SDL_GetGlobalMouseState(x: *mut ::std::os::raw::c_int,
                                   y: *mut ::std::os::raw::c_int) -> Uint32;
}
extern "C" {
    /// \brief Retrieve the relative state of the mouse.
///
/// The current button state is returned as a button bitmask, which can
/// be tested using the SDL_BUTTON(X) macros, and x and y are set to the
/// mouse deltas since the last call to SDL_GetRelativeMouseState().
    pub fn SDL_GetRelativeMouseState(x: *mut ::std::os::raw::c_int,
                                     y: *mut ::std::os::raw::c_int) -> Uint32;
}
extern "C" {
    /// \brief Moves the mouse to the given position within the window.
///
/// \param window The window to move the mouse into, or NULL for the current mouse focus
/// \param x The x coordinate within the window
/// \param y The y coordinate within the window
///
/// \note This function generates a mouse motion event
    pub fn SDL_WarpMouseInWindow(window: *mut SDL_Window,
                                 x: ::std::os::raw::c_int,
                                 y: ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Moves the mouse to the given position in global screen space.
///
/// \param x The x coordinate
/// \param y The y coordinate
/// \return 0 on success, -1 on error (usually: unsupported by a platform).
///
/// \note This function generates a mouse motion event
    pub fn SDL_WarpMouseGlobal(x: ::std::os::raw::c_int,
                               y: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set relative mouse mode.
///
/// \param enabled Whether or not to enable relative mode
///
/// \return 0 on success, or -1 if relative mode is not supported.
///
/// While the mouse is in relative mode, the cursor is hidden, and the
/// driver will try to report continuous motion in the current window.
/// Only relative motion events will be delivered, the mouse position
/// will not change.
///
/// \note This function will flush any pending mouse motion.
///
/// \sa SDL_GetRelativeMouseMode()
    pub fn SDL_SetRelativeMouseMode(enabled: SDL_bool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Capture the mouse, to track input outside an SDL window.
///
/// \param enabled Whether or not to enable capturing
///
/// Capturing enables your app to obtain mouse events globally, instead of
/// just within your window. Not all video targets support this function.
/// When capturing is enabled, the current window will get all mouse events,
/// but unlike relative mode, no change is made to the cursor and it is
/// not restrained to your window.
///
/// This function may also deny mouse input to other windows--both those in
/// your application and others on the system--so you should use this
/// function sparingly, and in small bursts. For example, you might want to
/// track the mouse while the user is dragging something, until the user
/// releases a mouse button. It is not recommended that you capture the mouse
/// for long periods of time, such as the entire time your app is running.
///
/// While captured, mouse events still report coordinates relative to the
/// current (foreground) window, but those coordinates may be outside the
/// bounds of the window (including negative values). Capturing is only
/// allowed for the foreground window. If the window loses focus while
/// capturing, the capture will be disabled automatically.
///
/// While capturing is enabled, the current window will have the
/// SDL_WINDOW_MOUSE_CAPTURE flag set.
///
/// \return 0 on success, or -1 if not supported.
    pub fn SDL_CaptureMouse(enabled: SDL_bool) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Query whether relative mouse mode is enabled.
///
/// \sa SDL_SetRelativeMouseMode()
    pub fn SDL_GetRelativeMouseMode() -> SDL_bool;
}
extern "C" {
    /// \brief Create a cursor, using the specified bitmap data and
/// mask (in MSB format).
///
/// The cursor width must be a multiple of 8 bits.
///
/// The cursor is created in black and white according to the following:
/// <table>
/// <tr><td> data </td><td> mask </td><td> resulting pixel on screen </td></tr>
/// <tr><td>  0   </td><td>  1   </td><td> White </td></tr>
/// <tr><td>  1   </td><td>  1   </td><td> Black </td></tr>
/// <tr><td>  0   </td><td>  0   </td><td> Transparent </td></tr>
/// <tr><td>  1   </td><td>  0   </td><td> Inverted color if possible, black
/// if not. </td></tr>
/// </table>
///
/// \sa SDL_FreeCursor()
    pub fn SDL_CreateCursor(data: *const Uint8, mask: *const Uint8,
                            w: ::std::os::raw::c_int,
                            h: ::std::os::raw::c_int,
                            hot_x: ::std::os::raw::c_int,
                            hot_y: ::std::os::raw::c_int) -> *mut SDL_Cursor;
}
extern "C" {
    /// \brief Create a color cursor.
///
/// \sa SDL_FreeCursor()
    pub fn SDL_CreateColorCursor(surface: *mut SDL_Surface,
                                 hot_x: ::std::os::raw::c_int,
                                 hot_y: ::std::os::raw::c_int)
     -> *mut SDL_Cursor;
}
extern "C" {
    /// \brief Create a system cursor.
///
/// \sa SDL_FreeCursor()
    pub fn SDL_CreateSystemCursor(id: SDL_SystemCursor) -> *mut SDL_Cursor;
}
extern "C" {
    /// \brief Set the active cursor.
    pub fn SDL_SetCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    /// \brief Return the active cursor.
    pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
extern "C" {
    /// \brief Return the default cursor.
    pub fn SDL_GetDefaultCursor() -> *mut SDL_Cursor;
}
extern "C" {
    /// \brief Frees a cursor created with SDL_CreateCursor() or similar functions.
///
/// \sa SDL_CreateCursor()
/// \sa SDL_CreateColorCursor()
/// \sa SDL_CreateSystemCursor()
    pub fn SDL_FreeCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    /// \brief Toggle whether or not the cursor is shown.
///
/// \param toggle 1 to show the cursor, 0 to hide it, -1 to query the current
/// state.
///
/// \return 1 if the cursor is shown, or 0 if the cursor is hidden.
    pub fn SDL_ShowCursor(toggle: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Joystick {
    _unused: [u8; 0],
}
pub type SDL_Joystick = _SDL_Joystick;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_JoystickGUID {
    pub data: [Uint8; 16usize],
}
#[test]
fn bindgen_test_layout_SDL_JoystickGUID() {
    assert_eq!(::std::mem::size_of::<SDL_JoystickGUID>() , 16usize , concat !
               ( "Size of: " , stringify ! ( SDL_JoystickGUID ) ));
    assert_eq! (::std::mem::align_of::<SDL_JoystickGUID>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( SDL_JoystickGUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoystickGUID ) ) . data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoystickGUID ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for SDL_JoystickGUID {
    fn clone(&self) -> Self { *self }
}
/// This is a unique ID for a joystick for the time it is connected to the system,
/// and is never reused for the lifetime of the application. If the joystick is
/// disconnected and reconnected, it will get a new ID.
///
/// The ID value starts at 0 and increments from there. The value -1 is an invalid ID.
pub type SDL_JoystickID = Sint32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_JoystickType {
    SDL_JOYSTICK_TYPE_UNKNOWN = 0,
    SDL_JOYSTICK_TYPE_GAMECONTROLLER = 1,
    SDL_JOYSTICK_TYPE_WHEEL = 2,
    SDL_JOYSTICK_TYPE_ARCADE_STICK = 3,
    SDL_JOYSTICK_TYPE_FLIGHT_STICK = 4,
    SDL_JOYSTICK_TYPE_DANCE_PAD = 5,
    SDL_JOYSTICK_TYPE_GUITAR = 6,
    SDL_JOYSTICK_TYPE_DRUM_KIT = 7,
    SDL_JOYSTICK_TYPE_ARCADE_PAD = 8,
    SDL_JOYSTICK_TYPE_THROTTLE = 9,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_JoystickPowerLevel {
    SDL_JOYSTICK_POWER_UNKNOWN = -1,
    SDL_JOYSTICK_POWER_EMPTY = 0,
    SDL_JOYSTICK_POWER_LOW = 1,
    SDL_JOYSTICK_POWER_MEDIUM = 2,
    SDL_JOYSTICK_POWER_FULL = 3,
    SDL_JOYSTICK_POWER_WIRED = 4,
    SDL_JOYSTICK_POWER_MAX = 5,
}
extern "C" {
    /// Count the number of joysticks attached to the system right now
    pub fn SDL_NumJoysticks() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the implementation dependent name of a joystick.
/// This can be called before any joysticks are opened.
/// If no name can be found, this function returns NULL.
    pub fn SDL_JoystickNameForIndex(device_index: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Return the GUID for the joystick at this index
/// This can be called before any joysticks are opened.
    pub fn SDL_JoystickGetDeviceGUID(device_index: ::std::os::raw::c_int)
     -> SDL_JoystickGUID;
}
extern "C" {
    /// Get the USB vendor ID of a joystick, if available.
/// This can be called before any joysticks are opened.
/// If the vendor ID isn't available this function returns 0.
    pub fn SDL_JoystickGetDeviceVendor(device_index: ::std::os::raw::c_int)
     -> Uint16;
}
extern "C" {
    /// Get the USB product ID of a joystick, if available.
/// This can be called before any joysticks are opened.
/// If the product ID isn't available this function returns 0.
    pub fn SDL_JoystickGetDeviceProduct(device_index: ::std::os::raw::c_int)
     -> Uint16;
}
extern "C" {
    /// Get the product version of a joystick, if available.
/// This can be called before any joysticks are opened.
/// If the product version isn't available this function returns 0.
    pub fn SDL_JoystickGetDeviceProductVersion(device_index:
                                                   ::std::os::raw::c_int)
     -> Uint16;
}
extern "C" {
    /// Get the type of a joystick, if available.
/// This can be called before any joysticks are opened.
    pub fn SDL_JoystickGetDeviceType(device_index: ::std::os::raw::c_int)
     -> SDL_JoystickType;
}
extern "C" {
    /// Get the instance ID of a joystick.
/// This can be called before any joysticks are opened.
/// If the index is out of range, this function will return -1.
    pub fn SDL_JoystickGetDeviceInstanceID(device_index:
                                               ::std::os::raw::c_int)
     -> SDL_JoystickID;
}
extern "C" {
    /// Open a joystick for use.
/// The index passed as an argument refers to the N'th joystick on the system.
/// This index is not the value which will identify this joystick in future
/// joystick events.  The joystick's instance id (::SDL_JoystickID) will be used
/// there instead.
///
/// \return A joystick identifier, or NULL if an error occurred.
    pub fn SDL_JoystickOpen(device_index: ::std::os::raw::c_int)
     -> *mut SDL_Joystick;
}
extern "C" {
    /// Return the SDL_Joystick associated with an instance id.
    pub fn SDL_JoystickFromInstanceID(joyid: SDL_JoystickID)
     -> *mut SDL_Joystick;
}
extern "C" {
    /// Return the name for this currently opened joystick.
/// If no name can be found, this function returns NULL.
    pub fn SDL_JoystickName(joystick: *mut SDL_Joystick)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Return the GUID for this opened joystick
    pub fn SDL_JoystickGetGUID(joystick: *mut SDL_Joystick)
     -> SDL_JoystickGUID;
}
extern "C" {
    /// Get the USB vendor ID of an opened joystick, if available.
/// If the vendor ID isn't available this function returns 0.
    pub fn SDL_JoystickGetVendor(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    /// Get the USB product ID of an opened joystick, if available.
/// If the product ID isn't available this function returns 0.
    pub fn SDL_JoystickGetProduct(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    /// Get the product version of an opened joystick, if available.
/// If the product version isn't available this function returns 0.
    pub fn SDL_JoystickGetProductVersion(joystick: *mut SDL_Joystick)
     -> Uint16;
}
extern "C" {
    /// Get the type of an opened joystick.
    pub fn SDL_JoystickGetType(joystick: *mut SDL_Joystick)
     -> SDL_JoystickType;
}
extern "C" {
    /// Return a string representation for this guid. pszGUID must point to at least 33 bytes
/// (32 for the string plus a NULL terminator).
    pub fn SDL_JoystickGetGUIDString(guid: SDL_JoystickGUID,
                                     pszGUID: *mut ::std::os::raw::c_char,
                                     cbGUID: ::std::os::raw::c_int);
}
extern "C" {
    /// Convert a string into a joystick guid
    pub fn SDL_JoystickGetGUIDFromString(pchGUID:
                                             *const ::std::os::raw::c_char)
     -> SDL_JoystickGUID;
}
extern "C" {
    /// Returns SDL_TRUE if the joystick has been opened and currently connected, or SDL_FALSE if it has not.
    pub fn SDL_JoystickGetAttached(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    /// Get the instance ID of an opened joystick or -1 if the joystick is invalid.
    pub fn SDL_JoystickInstanceID(joystick: *mut SDL_Joystick)
     -> SDL_JoystickID;
}
extern "C" {
    /// Get the number of general axis controls on a joystick.
    pub fn SDL_JoystickNumAxes(joystick: *mut SDL_Joystick)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the number of trackballs on a joystick.
///
/// Joystick trackballs have only relative motion events associated
/// with them and their state cannot be polled.
    pub fn SDL_JoystickNumBalls(joystick: *mut SDL_Joystick)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the number of POV hats on a joystick.
    pub fn SDL_JoystickNumHats(joystick: *mut SDL_Joystick)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the number of buttons on a joystick.
    pub fn SDL_JoystickNumButtons(joystick: *mut SDL_Joystick)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Update the current state of the open joysticks.
///
/// This is called automatically by the event loop if any joystick
/// events are enabled.
    pub fn SDL_JoystickUpdate();
}
extern "C" {
    /// Enable/disable joystick event polling.
///
/// If joystick events are disabled, you must call SDL_JoystickUpdate()
/// yourself and check the state of the joystick when you want joystick
/// information.
///
/// The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE.
    pub fn SDL_JoystickEventState(state: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the current state of an axis control on a joystick.
///
/// The state is a value ranging from -32768 to 32767.
///
/// The axis indices start at index 0.
    pub fn SDL_JoystickGetAxis(joystick: *mut SDL_Joystick,
                               axis: ::std::os::raw::c_int) -> Sint16;
}
extern "C" {
    /// Get the initial state of an axis control on a joystick.
///
/// The state is a value ranging from -32768 to 32767.
///
/// The axis indices start at index 0.
///
/// \return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.
    pub fn SDL_JoystickGetAxisInitialState(joystick: *mut SDL_Joystick,
                                           axis: ::std::os::raw::c_int,
                                           state: *mut Sint16) -> SDL_bool;
}
extern "C" {
    /// Get the current state of a POV hat on a joystick.
///
/// The hat indices start at index 0.
///
/// \return The return value is one of the following positions:
/// - ::SDL_HAT_CENTERED
/// - ::SDL_HAT_UP
/// - ::SDL_HAT_RIGHT
/// - ::SDL_HAT_DOWN
/// - ::SDL_HAT_LEFT
/// - ::SDL_HAT_RIGHTUP
/// - ::SDL_HAT_RIGHTDOWN
/// - ::SDL_HAT_LEFTUP
/// - ::SDL_HAT_LEFTDOWN
    pub fn SDL_JoystickGetHat(joystick: *mut SDL_Joystick,
                              hat: ::std::os::raw::c_int) -> Uint8;
}
extern "C" {
    /// Get the ball axis change since the last poll.
///
/// \return 0, or -1 if you passed it invalid parameters.
///
/// The ball indices start at index 0.
    pub fn SDL_JoystickGetBall(joystick: *mut SDL_Joystick,
                               ball: ::std::os::raw::c_int,
                               dx: *mut ::std::os::raw::c_int,
                               dy: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the current state of a button on a joystick.
///
/// The button indices start at index 0.
    pub fn SDL_JoystickGetButton(joystick: *mut SDL_Joystick,
                                 button: ::std::os::raw::c_int) -> Uint8;
}
extern "C" {
    /// Close a joystick previously opened with SDL_JoystickOpen().
    pub fn SDL_JoystickClose(joystick: *mut SDL_Joystick);
}
extern "C" {
    /// Return the battery level of this joystick
    pub fn SDL_JoystickCurrentPowerLevel(joystick: *mut SDL_Joystick)
     -> SDL_JoystickPowerLevel;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_GameController {
    _unused: [u8; 0],
}
pub type SDL_GameController = _SDL_GameController;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GameControllerBindType {
    SDL_CONTROLLER_BINDTYPE_NONE = 0,
    SDL_CONTROLLER_BINDTYPE_BUTTON = 1,
    SDL_CONTROLLER_BINDTYPE_AXIS = 2,
    SDL_CONTROLLER_BINDTYPE_HAT = 3,
}
/// Get the SDL joystick layer binding for this controller button/axis mapping
#[repr(C)]
#[derive(Copy)]
pub struct SDL_GameControllerButtonBind {
    pub bindType: SDL_GameControllerBindType,
    pub value: SDL_GameControllerButtonBind__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union SDL_GameControllerButtonBind__bindgen_ty_1 {
    pub button: ::std::os::raw::c_int,
    pub axis: ::std::os::raw::c_int,
    pub hat: SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 {
    pub hat: ::std::os::raw::c_int,
    pub hat_mask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 ) ) .
                hat as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( hat ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 ) ) .
                hat_mask as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( hat_mask ) ));
}
impl Clone for SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               SDL_GameControllerButtonBind__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                SDL_GameControllerButtonBind__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const SDL_GameControllerButtonBind__bindgen_ty_1 )
                ) . button as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_GameControllerButtonBind__bindgen_ty_1 ) , "::" ,
                stringify ! ( button ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const SDL_GameControllerButtonBind__bindgen_ty_1 )
                ) . axis as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_GameControllerButtonBind__bindgen_ty_1 ) , "::" ,
                stringify ! ( axis ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const SDL_GameControllerButtonBind__bindgen_ty_1 )
                ) . hat as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_GameControllerButtonBind__bindgen_ty_1 ) , "::" ,
                stringify ! ( hat ) ));
}
impl Clone for SDL_GameControllerButtonBind__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind() {
    assert_eq!(::std::mem::size_of::<SDL_GameControllerButtonBind>() , 12usize
               , concat ! (
               "Size of: " , stringify ! ( SDL_GameControllerButtonBind ) ));
    assert_eq! (::std::mem::align_of::<SDL_GameControllerButtonBind>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( SDL_GameControllerButtonBind )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_GameControllerButtonBind ) ) .
                bindType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_GameControllerButtonBind ) , "::" , stringify ! ( bindType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_GameControllerButtonBind ) ) . value
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_GameControllerButtonBind ) , "::" , stringify ! ( value )
                ));
}
impl Clone for SDL_GameControllerButtonBind {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Load a set of mappings from a seekable SDL data stream (memory or file), filtered by the current SDL_GetPlatform()
/// A community sourced database of controllers is available at https://raw.github.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt
///
/// If \c freerw is non-zero, the stream will be closed after being read.
///
/// \return number of mappings added, -1 on error
    pub fn SDL_GameControllerAddMappingsFromRW(rw: *mut SDL_RWops,
                                               freerw: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Add or update an existing mapping configuration
///
/// \return 1 if mapping is added, 0 if updated, -1 on error
    pub fn SDL_GameControllerAddMapping(mappingString:
                                            *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the number of mappings installed
///
/// \return the number of mappings
    pub fn SDL_GameControllerNumMappings() -> ::std::os::raw::c_int;
}
extern "C" {
    /// Get the mapping at a particular index.
///
/// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if the index is out of range.
    pub fn SDL_GameControllerMappingForIndex(mapping_index:
                                                 ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Get a mapping string for a GUID
///
/// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available
    pub fn SDL_GameControllerMappingForGUID(guid: SDL_JoystickGUID)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Get a mapping string for an open GameController
///
/// \return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available
    pub fn SDL_GameControllerMapping(gamecontroller: *mut SDL_GameController)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// Is the joystick on this index supported by the game controller interface?
    pub fn SDL_IsGameController(joystick_index: ::std::os::raw::c_int)
     -> SDL_bool;
}
extern "C" {
    /// Get the implementation dependent name of a game controller.
/// This can be called before any controllers are opened.
/// If no name can be found, this function returns NULL.
    pub fn SDL_GameControllerNameForIndex(joystick_index:
                                              ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Open a game controller for use.
/// The index passed as an argument refers to the N'th game controller on the system.
/// This index is not the value which will identify this controller in future
/// controller events.  The joystick's instance id (::SDL_JoystickID) will be
/// used there instead.
///
/// \return A controller identifier, or NULL if an error occurred.
    pub fn SDL_GameControllerOpen(joystick_index: ::std::os::raw::c_int)
     -> *mut SDL_GameController;
}
extern "C" {
    /// Return the SDL_GameController associated with an instance id.
    pub fn SDL_GameControllerFromInstanceID(joyid: SDL_JoystickID)
     -> *mut SDL_GameController;
}
extern "C" {
    /// Return the name for this currently opened controller
    pub fn SDL_GameControllerName(gamecontroller: *mut SDL_GameController)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the USB vendor ID of an opened controller, if available.
/// If the vendor ID isn't available this function returns 0.
    pub fn SDL_GameControllerGetVendor(gamecontroller:
                                           *mut SDL_GameController) -> Uint16;
}
extern "C" {
    /// Get the USB product ID of an opened controller, if available.
/// If the product ID isn't available this function returns 0.
    pub fn SDL_GameControllerGetProduct(gamecontroller:
                                            *mut SDL_GameController)
     -> Uint16;
}
extern "C" {
    /// Get the product version of an opened controller, if available.
/// If the product version isn't available this function returns 0.
    pub fn SDL_GameControllerGetProductVersion(gamecontroller:
                                                   *mut SDL_GameController)
     -> Uint16;
}
extern "C" {
    /// Returns SDL_TRUE if the controller has been opened and currently connected,
/// or SDL_FALSE if it has not.
    pub fn SDL_GameControllerGetAttached(gamecontroller:
                                             *mut SDL_GameController)
     -> SDL_bool;
}
extern "C" {
    /// Get the underlying joystick object used by a controller
    pub fn SDL_GameControllerGetJoystick(gamecontroller:
                                             *mut SDL_GameController)
     -> *mut SDL_Joystick;
}
extern "C" {
    /// Enable/disable controller event polling.
///
/// If controller events are disabled, you must call SDL_GameControllerUpdate()
/// yourself and check the state of the controller when you want controller
/// information.
///
/// The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE.
    pub fn SDL_GameControllerEventState(state: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// Update the current state of the open game controllers.
///
/// This is called automatically by the event loop if any game controller
/// events are enabled.
    pub fn SDL_GameControllerUpdate();
}
#[repr(i32)]
/// The list of axes available from a controller
///
/// Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,
/// and are centered within ~8000 of zero, though advanced UI will allow users to set
/// or autodetect the dead zone, which varies between controllers.
///
/// Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GameControllerAxis {
    SDL_CONTROLLER_AXIS_INVALID = -1,
    SDL_CONTROLLER_AXIS_LEFTX = 0,
    SDL_CONTROLLER_AXIS_LEFTY = 1,
    SDL_CONTROLLER_AXIS_RIGHTX = 2,
    SDL_CONTROLLER_AXIS_RIGHTY = 3,
    SDL_CONTROLLER_AXIS_TRIGGERLEFT = 4,
    SDL_CONTROLLER_AXIS_TRIGGERRIGHT = 5,
    SDL_CONTROLLER_AXIS_MAX = 6,
}
extern "C" {
    /// turn this string into a axis mapping
    pub fn SDL_GameControllerGetAxisFromString(pchString:
                                                   *const ::std::os::raw::c_char)
     -> SDL_GameControllerAxis;
}
extern "C" {
    /// turn this axis enum into a string mapping
    pub fn SDL_GameControllerGetStringForAxis(axis: SDL_GameControllerAxis)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the SDL joystick layer binding for this controller button mapping
    pub fn SDL_GameControllerGetBindForAxis(gamecontroller:
                                                *mut SDL_GameController,
                                            axis: SDL_GameControllerAxis)
     -> SDL_GameControllerButtonBind;
}
extern "C" {
    /// Get the current state of an axis control on a game controller.
///
/// The state is a value ranging from -32768 to 32767 (except for the triggers,
/// which range from 0 to 32767).
///
/// The axis indices start at index 0.
    pub fn SDL_GameControllerGetAxis(gamecontroller: *mut SDL_GameController,
                                     axis: SDL_GameControllerAxis) -> Sint16;
}
#[repr(i32)]
/// The list of buttons available from a controller
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_GameControllerButton {
    SDL_CONTROLLER_BUTTON_INVALID = -1,
    SDL_CONTROLLER_BUTTON_A = 0,
    SDL_CONTROLLER_BUTTON_B = 1,
    SDL_CONTROLLER_BUTTON_X = 2,
    SDL_CONTROLLER_BUTTON_Y = 3,
    SDL_CONTROLLER_BUTTON_BACK = 4,
    SDL_CONTROLLER_BUTTON_GUIDE = 5,
    SDL_CONTROLLER_BUTTON_START = 6,
    SDL_CONTROLLER_BUTTON_LEFTSTICK = 7,
    SDL_CONTROLLER_BUTTON_RIGHTSTICK = 8,
    SDL_CONTROLLER_BUTTON_LEFTSHOULDER = 9,
    SDL_CONTROLLER_BUTTON_RIGHTSHOULDER = 10,
    SDL_CONTROLLER_BUTTON_DPAD_UP = 11,
    SDL_CONTROLLER_BUTTON_DPAD_DOWN = 12,
    SDL_CONTROLLER_BUTTON_DPAD_LEFT = 13,
    SDL_CONTROLLER_BUTTON_DPAD_RIGHT = 14,
    SDL_CONTROLLER_BUTTON_MAX = 15,
}
extern "C" {
    /// turn this string into a button mapping
    pub fn SDL_GameControllerGetButtonFromString(pchString:
                                                     *const ::std::os::raw::c_char)
     -> SDL_GameControllerButton;
}
extern "C" {
    /// turn this button enum into a string mapping
    pub fn SDL_GameControllerGetStringForButton(button:
                                                    SDL_GameControllerButton)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// Get the SDL joystick layer binding for this controller button mapping
    pub fn SDL_GameControllerGetBindForButton(gamecontroller:
                                                  *mut SDL_GameController,
                                              button:
                                                  SDL_GameControllerButton)
     -> SDL_GameControllerButtonBind;
}
extern "C" {
    /// Get the current state of a button on a game controller.
///
/// The button indices start at index 0.
    pub fn SDL_GameControllerGetButton(gamecontroller:
                                           *mut SDL_GameController,
                                       button: SDL_GameControllerButton)
     -> Uint8;
}
extern "C" {
    /// Close a controller previously opened with SDL_GameControllerOpen().
    pub fn SDL_GameControllerClose(gamecontroller: *mut SDL_GameController);
}
pub type SDL_TouchID = Sint64;
pub type SDL_FingerID = Sint64;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_Finger {
    pub id: SDL_FingerID,
    pub x: f32,
    pub y: f32,
    pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_Finger() {
    assert_eq!(::std::mem::size_of::<SDL_Finger>() , 24usize , concat ! (
               "Size of: " , stringify ! ( SDL_Finger ) ));
    assert_eq! (::std::mem::align_of::<SDL_Finger>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SDL_Finger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Finger ) ) . id as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Finger ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Finger ) ) . x as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Finger ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Finger ) ) . y as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Finger ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Finger ) ) . pressure as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Finger ) , "::" ,
                stringify ! ( pressure ) ));
}
impl Clone for SDL_Finger {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// \brief Get the number of registered touch devices.
    pub fn SDL_GetNumTouchDevices() -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the touch ID with the given index, or 0 if the index is invalid.
    pub fn SDL_GetTouchDevice(index: ::std::os::raw::c_int) -> SDL_TouchID;
}
extern "C" {
    /// \brief Get the number of active fingers for a given touch device.
    pub fn SDL_GetNumTouchFingers(touchID: SDL_TouchID)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the finger object of the given touch, with the given index.
    pub fn SDL_GetTouchFinger(touchID: SDL_TouchID,
                              index: ::std::os::raw::c_int)
     -> *mut SDL_Finger;
}
pub type SDL_GestureID = Sint64;
extern "C" {
    /// \brief Begin Recording a gesture on the specified touch, or all touches (-1)
///
///
    pub fn SDL_RecordGesture(touchId: SDL_TouchID) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Save all currently loaded Dollar Gesture templates
///
///
    pub fn SDL_SaveAllDollarTemplates(dst: *mut SDL_RWops)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Save a currently loaded Dollar Gesture template
///
///
    pub fn SDL_SaveDollarTemplate(gestureId: SDL_GestureID,
                                  dst: *mut SDL_RWops)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Load Dollar Gesture templates from a file
///
///
    pub fn SDL_LoadDollarTemplates(touchId: SDL_TouchID, src: *mut SDL_RWops)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// \brief The types of events that can be delivered.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_EventType {
    SDL_FIRSTEVENT = 0,
    SDL_QUIT = 256,
    SDL_APP_TERMINATING = 257,
    SDL_APP_LOWMEMORY = 258,
    SDL_APP_WILLENTERBACKGROUND = 259,
    SDL_APP_DIDENTERBACKGROUND = 260,
    SDL_APP_WILLENTERFOREGROUND = 261,
    SDL_APP_DIDENTERFOREGROUND = 262,
    SDL_WINDOWEVENT = 512,
    SDL_SYSWMEVENT = 513,
    SDL_KEYDOWN = 768,
    SDL_KEYUP = 769,
    SDL_TEXTEDITING = 770,
    SDL_TEXTINPUT = 771,
    SDL_KEYMAPCHANGED = 772,
    SDL_MOUSEMOTION = 1024,
    SDL_MOUSEBUTTONDOWN = 1025,
    SDL_MOUSEBUTTONUP = 1026,
    SDL_MOUSEWHEEL = 1027,
    SDL_JOYAXISMOTION = 1536,
    SDL_JOYBALLMOTION = 1537,
    SDL_JOYHATMOTION = 1538,
    SDL_JOYBUTTONDOWN = 1539,
    SDL_JOYBUTTONUP = 1540,
    SDL_JOYDEVICEADDED = 1541,
    SDL_JOYDEVICEREMOVED = 1542,
    SDL_CONTROLLERAXISMOTION = 1616,
    SDL_CONTROLLERBUTTONDOWN = 1617,
    SDL_CONTROLLERBUTTONUP = 1618,
    SDL_CONTROLLERDEVICEADDED = 1619,
    SDL_CONTROLLERDEVICEREMOVED = 1620,
    SDL_CONTROLLERDEVICEREMAPPED = 1621,
    SDL_FINGERDOWN = 1792,
    SDL_FINGERUP = 1793,
    SDL_FINGERMOTION = 1794,
    SDL_DOLLARGESTURE = 2048,
    SDL_DOLLARRECORD = 2049,
    SDL_MULTIGESTURE = 2050,
    SDL_CLIPBOARDUPDATE = 2304,
    SDL_DROPFILE = 4096,
    SDL_DROPTEXT = 4097,
    SDL_DROPBEGIN = 4098,
    SDL_DROPCOMPLETE = 4099,
    SDL_AUDIODEVICEADDED = 4352,
    SDL_AUDIODEVICEREMOVED = 4353,
    SDL_RENDER_TARGETS_RESET = 8192,
    SDL_RENDER_DEVICE_RESET = 8193,
    SDL_USEREVENT = 32768,
    SDL_LASTEVENT = 65535,
}
/// \brief Fields shared by every event
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_CommonEvent {
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_CommonEvent() {
    assert_eq!(::std::mem::size_of::<SDL_CommonEvent>() , 8usize , concat ! (
               "Size of: " , stringify ! ( SDL_CommonEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_CommonEvent>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( SDL_CommonEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_CommonEvent ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_CommonEvent ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_CommonEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_CommonEvent ) ,
                "::" , stringify ! ( timestamp ) ));
}
impl Clone for SDL_CommonEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Window state change event data (event.window.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_WindowEvent {
    /// < ::SDL_WINDOWEVENT
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The associated window
    pub windowID: Uint32,
    /// < ::SDL_WindowEventID
    pub event: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    /// < event dependent data
    pub data1: Sint32,
    /// < event dependent data
    pub data2: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_WindowEvent() {
    assert_eq!(::std::mem::size_of::<SDL_WindowEvent>() , 24usize , concat ! (
               "Size of: " , stringify ! ( SDL_WindowEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_WindowEvent>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( SDL_WindowEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowEvent ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowEvent ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowEvent ) ,
                "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowEvent ) ) . windowID as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowEvent ) ,
                "::" , stringify ! ( windowID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowEvent ) ) . event as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowEvent ) ,
                "::" , stringify ! ( event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowEvent ) ) . padding1 as * const
                _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowEvent ) ,
                "::" , stringify ! ( padding1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowEvent ) ) . padding2 as * const
                _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowEvent ) ,
                "::" , stringify ! ( padding2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowEvent ) ) . padding3 as * const
                _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowEvent ) ,
                "::" , stringify ! ( padding3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowEvent ) ) . data1 as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowEvent ) ,
                "::" , stringify ! ( data1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowEvent ) ) . data2 as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowEvent ) ,
                "::" , stringify ! ( data2 ) ));
}
impl Clone for SDL_WindowEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Keyboard button event structure (event.key.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_KeyboardEvent {
    /// < ::SDL_KEYDOWN or ::SDL_KEYUP
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The window with keyboard focus, if any
    pub windowID: Uint32,
    /// < ::SDL_PRESSED or ::SDL_RELEASED
    pub state: Uint8,
    /// < Non-zero if this is a key repeat
    pub repeat: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    /// < The key that was pressed or released
    pub keysym: SDL_Keysym,
}
#[test]
fn bindgen_test_layout_SDL_KeyboardEvent() {
    assert_eq!(::std::mem::size_of::<SDL_KeyboardEvent>() , 32usize , concat !
               ( "Size of: " , stringify ! ( SDL_KeyboardEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_KeyboardEvent>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( SDL_KeyboardEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_KeyboardEvent ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_KeyboardEvent ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_KeyboardEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_KeyboardEvent ) ,
                "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_KeyboardEvent ) ) . windowID as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_KeyboardEvent ) ,
                "::" , stringify ! ( windowID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_KeyboardEvent ) ) . state as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_KeyboardEvent ) ,
                "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_KeyboardEvent ) ) . repeat as * const
                _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_KeyboardEvent ) ,
                "::" , stringify ! ( repeat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_KeyboardEvent ) ) . padding2 as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_KeyboardEvent ) ,
                "::" , stringify ! ( padding2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_KeyboardEvent ) ) . padding3 as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_KeyboardEvent ) ,
                "::" , stringify ! ( padding3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_KeyboardEvent ) ) . keysym as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_KeyboardEvent ) ,
                "::" , stringify ! ( keysym ) ));
}
impl Clone for SDL_KeyboardEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Keyboard text editing event structure (event.edit.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_TextEditingEvent {
    /// < ::SDL_TEXTEDITING
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The window with keyboard focus, if any
    pub windowID: Uint32,
    /// < The editing text
    pub text: [::std::os::raw::c_char; 32usize],
    /// < The start cursor of selected editing text
    pub start: Sint32,
    /// < The length of selected editing text
    pub length: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_TextEditingEvent() {
    assert_eq!(::std::mem::size_of::<SDL_TextEditingEvent>() , 52usize ,
               concat ! ( "Size of: " , stringify ! ( SDL_TextEditingEvent )
               ));
    assert_eq! (::std::mem::align_of::<SDL_TextEditingEvent>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_TextEditingEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TextEditingEvent ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TextEditingEvent )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TextEditingEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TextEditingEvent )
                , "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TextEditingEvent ) ) . windowID as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TextEditingEvent )
                , "::" , stringify ! ( windowID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TextEditingEvent ) ) . text as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TextEditingEvent )
                , "::" , stringify ! ( text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TextEditingEvent ) ) . start as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TextEditingEvent )
                , "::" , stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TextEditingEvent ) ) . length as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TextEditingEvent )
                , "::" , stringify ! ( length ) ));
}
impl Clone for SDL_TextEditingEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Keyboard text input event structure (event.text.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_TextInputEvent {
    /// < ::SDL_TEXTINPUT
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The window with keyboard focus, if any
    pub windowID: Uint32,
    /// < The input text
    pub text: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_SDL_TextInputEvent() {
    assert_eq!(::std::mem::size_of::<SDL_TextInputEvent>() , 44usize , concat
               ! ( "Size of: " , stringify ! ( SDL_TextInputEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_TextInputEvent>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( SDL_TextInputEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TextInputEvent ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TextInputEvent ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TextInputEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TextInputEvent ) ,
                "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TextInputEvent ) ) . windowID as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TextInputEvent ) ,
                "::" , stringify ! ( windowID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TextInputEvent ) ) . text as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TextInputEvent ) ,
                "::" , stringify ! ( text ) ));
}
impl Clone for SDL_TextInputEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Mouse motion event structure (event.motion.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_MouseMotionEvent {
    /// < ::SDL_MOUSEMOTION
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The window with mouse focus, if any
    pub windowID: Uint32,
    /// < The mouse instance id, or SDL_TOUCH_MOUSEID
    pub which: Uint32,
    /// < The current button state
    pub state: Uint32,
    /// < X coordinate, relative to window
    pub x: Sint32,
    /// < Y coordinate, relative to window
    pub y: Sint32,
    /// < The relative motion in the X direction
    pub xrel: Sint32,
    /// < The relative motion in the Y direction
    pub yrel: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseMotionEvent() {
    assert_eq!(::std::mem::size_of::<SDL_MouseMotionEvent>() , 36usize ,
               concat ! ( "Size of: " , stringify ! ( SDL_MouseMotionEvent )
               ));
    assert_eq! (::std::mem::align_of::<SDL_MouseMotionEvent>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_MouseMotionEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseMotionEvent ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseMotionEvent )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseMotionEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseMotionEvent )
                , "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseMotionEvent ) ) . windowID as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseMotionEvent )
                , "::" , stringify ! ( windowID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseMotionEvent ) ) . which as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseMotionEvent )
                , "::" , stringify ! ( which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseMotionEvent ) ) . state as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseMotionEvent )
                , "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseMotionEvent ) ) . x as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseMotionEvent )
                , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseMotionEvent ) ) . y as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseMotionEvent )
                , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseMotionEvent ) ) . xrel as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseMotionEvent )
                , "::" , stringify ! ( xrel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseMotionEvent ) ) . yrel as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseMotionEvent )
                , "::" , stringify ! ( yrel ) ));
}
impl Clone for SDL_MouseMotionEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Mouse button event structure (event.button.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_MouseButtonEvent {
    /// < ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The window with mouse focus, if any
    pub windowID: Uint32,
    /// < The mouse instance id, or SDL_TOUCH_MOUSEID
    pub which: Uint32,
    /// < The mouse button index
    pub button: Uint8,
    /// < ::SDL_PRESSED or ::SDL_RELEASED
    pub state: Uint8,
    /// < 1 for single-click, 2 for double-click, etc.
    pub clicks: Uint8,
    pub padding1: Uint8,
    /// < X coordinate, relative to window
    pub x: Sint32,
    /// < Y coordinate, relative to window
    pub y: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseButtonEvent() {
    assert_eq!(::std::mem::size_of::<SDL_MouseButtonEvent>() , 28usize ,
               concat ! ( "Size of: " , stringify ! ( SDL_MouseButtonEvent )
               ));
    assert_eq! (::std::mem::align_of::<SDL_MouseButtonEvent>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_MouseButtonEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseButtonEvent ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseButtonEvent )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseButtonEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseButtonEvent )
                , "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseButtonEvent ) ) . windowID as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseButtonEvent )
                , "::" , stringify ! ( windowID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseButtonEvent ) ) . which as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseButtonEvent )
                , "::" , stringify ! ( which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseButtonEvent ) ) . button as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseButtonEvent )
                , "::" , stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseButtonEvent ) ) . state as *
                const _ as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseButtonEvent )
                , "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseButtonEvent ) ) . clicks as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseButtonEvent )
                , "::" , stringify ! ( clicks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseButtonEvent ) ) . padding1 as *
                const _ as usize } , 19usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseButtonEvent )
                , "::" , stringify ! ( padding1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseButtonEvent ) ) . x as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseButtonEvent )
                , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseButtonEvent ) ) . y as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseButtonEvent )
                , "::" , stringify ! ( y ) ));
}
impl Clone for SDL_MouseButtonEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Mouse wheel event structure (event.wheel.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_MouseWheelEvent {
    /// < ::SDL_MOUSEWHEEL
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The window with mouse focus, if any
    pub windowID: Uint32,
    /// < The mouse instance id, or SDL_TOUCH_MOUSEID
    pub which: Uint32,
    /// < The amount scrolled horizontally, positive to the right and negative to the left
    pub x: Sint32,
    /// < The amount scrolled vertically, positive away from the user and negative toward the user
    pub y: Sint32,
    /// < Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back
    pub direction: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseWheelEvent() {
    assert_eq!(::std::mem::size_of::<SDL_MouseWheelEvent>() , 28usize , concat
               ! ( "Size of: " , stringify ! ( SDL_MouseWheelEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_MouseWheelEvent>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_MouseWheelEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseWheelEvent ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseWheelEvent ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseWheelEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseWheelEvent ) ,
                "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseWheelEvent ) ) . windowID as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseWheelEvent ) ,
                "::" , stringify ! ( windowID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseWheelEvent ) ) . which as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseWheelEvent ) ,
                "::" , stringify ! ( which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseWheelEvent ) ) . x as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseWheelEvent ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseWheelEvent ) ) . y as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseWheelEvent ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MouseWheelEvent ) ) . direction as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MouseWheelEvent ) ,
                "::" , stringify ! ( direction ) ));
}
impl Clone for SDL_MouseWheelEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Joystick axis motion event structure (event.jaxis.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_JoyAxisEvent {
    /// < ::SDL_JOYAXISMOTION
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The joystick instance id
    pub which: SDL_JoystickID,
    /// < The joystick axis index
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    /// < The axis value (range: -32768 to 32767)
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyAxisEvent() {
    assert_eq!(::std::mem::size_of::<SDL_JoyAxisEvent>() , 20usize , concat !
               ( "Size of: " , stringify ! ( SDL_JoyAxisEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_JoyAxisEvent>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( SDL_JoyAxisEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyAxisEvent ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyAxisEvent ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyAxisEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyAxisEvent ) ,
                "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyAxisEvent ) ) . which as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyAxisEvent ) ,
                "::" , stringify ! ( which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyAxisEvent ) ) . axis as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyAxisEvent ) ,
                "::" , stringify ! ( axis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyAxisEvent ) ) . padding1 as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyAxisEvent ) ,
                "::" , stringify ! ( padding1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyAxisEvent ) ) . padding2 as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyAxisEvent ) ,
                "::" , stringify ! ( padding2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyAxisEvent ) ) . padding3 as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyAxisEvent ) ,
                "::" , stringify ! ( padding3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyAxisEvent ) ) . value as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyAxisEvent ) ,
                "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyAxisEvent ) ) . padding4 as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyAxisEvent ) ,
                "::" , stringify ! ( padding4 ) ));
}
impl Clone for SDL_JoyAxisEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Joystick trackball motion event structure (event.jball.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_JoyBallEvent {
    /// < ::SDL_JOYBALLMOTION
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The joystick instance id
    pub which: SDL_JoystickID,
    /// < The joystick trackball index
    pub ball: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    /// < The relative motion in the X direction
    pub xrel: Sint16,
    /// < The relative motion in the Y direction
    pub yrel: Sint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyBallEvent() {
    assert_eq!(::std::mem::size_of::<SDL_JoyBallEvent>() , 20usize , concat !
               ( "Size of: " , stringify ! ( SDL_JoyBallEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_JoyBallEvent>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( SDL_JoyBallEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyBallEvent ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyBallEvent ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyBallEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyBallEvent ) ,
                "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyBallEvent ) ) . which as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyBallEvent ) ,
                "::" , stringify ! ( which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyBallEvent ) ) . ball as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyBallEvent ) ,
                "::" , stringify ! ( ball ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyBallEvent ) ) . padding1 as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyBallEvent ) ,
                "::" , stringify ! ( padding1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyBallEvent ) ) . padding2 as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyBallEvent ) ,
                "::" , stringify ! ( padding2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyBallEvent ) ) . padding3 as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyBallEvent ) ,
                "::" , stringify ! ( padding3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyBallEvent ) ) . xrel as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyBallEvent ) ,
                "::" , stringify ! ( xrel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyBallEvent ) ) . yrel as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyBallEvent ) ,
                "::" , stringify ! ( yrel ) ));
}
impl Clone for SDL_JoyBallEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Joystick hat position change event structure (event.jhat.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_JoyHatEvent {
    /// < ::SDL_JOYHATMOTION
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The joystick instance id
    pub which: SDL_JoystickID,
    /// < The joystick hat index
    pub hat: Uint8,
    /// < The hat position value.
    /// \sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP
    /// \sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT
    /// \sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN
    ///
    /// Note that zero means the POV is centered.
    pub value: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyHatEvent() {
    assert_eq!(::std::mem::size_of::<SDL_JoyHatEvent>() , 16usize , concat ! (
               "Size of: " , stringify ! ( SDL_JoyHatEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_JoyHatEvent>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( SDL_JoyHatEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyHatEvent ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyHatEvent ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyHatEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyHatEvent ) ,
                "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyHatEvent ) ) . which as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyHatEvent ) ,
                "::" , stringify ! ( which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyHatEvent ) ) . hat as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyHatEvent ) ,
                "::" , stringify ! ( hat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyHatEvent ) ) . value as * const _
                as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyHatEvent ) ,
                "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyHatEvent ) ) . padding1 as * const
                _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyHatEvent ) ,
                "::" , stringify ! ( padding1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyHatEvent ) ) . padding2 as * const
                _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyHatEvent ) ,
                "::" , stringify ! ( padding2 ) ));
}
impl Clone for SDL_JoyHatEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Joystick button event structure (event.jbutton.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_JoyButtonEvent {
    /// < ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The joystick instance id
    pub which: SDL_JoystickID,
    /// < The joystick button index
    pub button: Uint8,
    /// < ::SDL_PRESSED or ::SDL_RELEASED
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyButtonEvent() {
    assert_eq!(::std::mem::size_of::<SDL_JoyButtonEvent>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( SDL_JoyButtonEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_JoyButtonEvent>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( SDL_JoyButtonEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyButtonEvent ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyButtonEvent ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyButtonEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyButtonEvent ) ,
                "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyButtonEvent ) ) . which as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyButtonEvent ) ,
                "::" , stringify ! ( which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyButtonEvent ) ) . button as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyButtonEvent ) ,
                "::" , stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyButtonEvent ) ) . state as * const
                _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyButtonEvent ) ,
                "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyButtonEvent ) ) . padding1 as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyButtonEvent ) ,
                "::" , stringify ! ( padding1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyButtonEvent ) ) . padding2 as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyButtonEvent ) ,
                "::" , stringify ! ( padding2 ) ));
}
impl Clone for SDL_JoyButtonEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Joystick device event structure (event.jdevice.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_JoyDeviceEvent {
    /// < ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The joystick device index for the ADDED event, instance id for the REMOVED event
    pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_JoyDeviceEvent() {
    assert_eq!(::std::mem::size_of::<SDL_JoyDeviceEvent>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( SDL_JoyDeviceEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_JoyDeviceEvent>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( SDL_JoyDeviceEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyDeviceEvent ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyDeviceEvent ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyDeviceEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyDeviceEvent ) ,
                "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_JoyDeviceEvent ) ) . which as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_JoyDeviceEvent ) ,
                "::" , stringify ! ( which ) ));
}
impl Clone for SDL_JoyDeviceEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Game controller axis motion event structure (event.caxis.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_ControllerAxisEvent {
    /// < ::SDL_CONTROLLERAXISMOTION
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The joystick instance id
    pub which: SDL_JoystickID,
    /// < The controller axis (SDL_GameControllerAxis)
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    /// < The axis value (range: -32768 to 32767)
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_ControllerAxisEvent() {
    assert_eq!(::std::mem::size_of::<SDL_ControllerAxisEvent>() , 20usize ,
               concat ! (
               "Size of: " , stringify ! ( SDL_ControllerAxisEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_ControllerAxisEvent>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_ControllerAxisEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerAxisEvent ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_ControllerAxisEvent
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerAxisEvent ) ) . timestamp
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_ControllerAxisEvent
                ) , "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerAxisEvent ) ) . which as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_ControllerAxisEvent
                ) , "::" , stringify ! ( which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerAxisEvent ) ) . axis as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_ControllerAxisEvent
                ) , "::" , stringify ! ( axis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerAxisEvent ) ) . padding1 as
                * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_ControllerAxisEvent
                ) , "::" , stringify ! ( padding1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerAxisEvent ) ) . padding2 as
                * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_ControllerAxisEvent
                ) , "::" , stringify ! ( padding2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerAxisEvent ) ) . padding3 as
                * const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_ControllerAxisEvent
                ) , "::" , stringify ! ( padding3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerAxisEvent ) ) . value as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_ControllerAxisEvent
                ) , "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerAxisEvent ) ) . padding4 as
                * const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_ControllerAxisEvent
                ) , "::" , stringify ! ( padding4 ) ));
}
impl Clone for SDL_ControllerAxisEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Game controller button event structure (event.cbutton.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_ControllerButtonEvent {
    /// < ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The joystick instance id
    pub which: SDL_JoystickID,
    /// < The controller button (SDL_GameControllerButton)
    pub button: Uint8,
    /// < ::SDL_PRESSED or ::SDL_RELEASED
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_ControllerButtonEvent() {
    assert_eq!(::std::mem::size_of::<SDL_ControllerButtonEvent>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( SDL_ControllerButtonEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_ControllerButtonEvent>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_ControllerButtonEvent )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerButtonEvent ) ) . type_ as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_ControllerButtonEvent ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerButtonEvent ) ) . timestamp
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_ControllerButtonEvent ) , "::" , stringify ! ( timestamp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerButtonEvent ) ) . which as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_ControllerButtonEvent ) , "::" , stringify ! ( which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerButtonEvent ) ) . button as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_ControllerButtonEvent ) , "::" , stringify ! ( button )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerButtonEvent ) ) . state as
                * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_ControllerButtonEvent ) , "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerButtonEvent ) ) . padding1
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_ControllerButtonEvent ) , "::" , stringify ! ( padding1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerButtonEvent ) ) . padding2
                as * const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_ControllerButtonEvent ) , "::" , stringify ! ( padding2 )
                ));
}
impl Clone for SDL_ControllerButtonEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Controller device event structure (event.cdevice.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_ControllerDeviceEvent {
    /// < ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event
    pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_ControllerDeviceEvent() {
    assert_eq!(::std::mem::size_of::<SDL_ControllerDeviceEvent>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( SDL_ControllerDeviceEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_ControllerDeviceEvent>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_ControllerDeviceEvent )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerDeviceEvent ) ) . type_ as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_ControllerDeviceEvent ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerDeviceEvent ) ) . timestamp
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_ControllerDeviceEvent ) , "::" , stringify ! ( timestamp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_ControllerDeviceEvent ) ) . which as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_ControllerDeviceEvent ) , "::" , stringify ! ( which ) ));
}
impl Clone for SDL_ControllerDeviceEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Audio device event structure (event.adevice.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_AudioDeviceEvent {
    /// < ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event
    pub which: Uint32,
    /// < zero if an output device, non-zero if a capture device.
    pub iscapture: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_AudioDeviceEvent() {
    assert_eq!(::std::mem::size_of::<SDL_AudioDeviceEvent>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( SDL_AudioDeviceEvent )
               ));
    assert_eq! (::std::mem::align_of::<SDL_AudioDeviceEvent>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_AudioDeviceEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioDeviceEvent ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioDeviceEvent )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioDeviceEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioDeviceEvent )
                , "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioDeviceEvent ) ) . which as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioDeviceEvent )
                , "::" , stringify ! ( which ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioDeviceEvent ) ) . iscapture as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioDeviceEvent )
                , "::" , stringify ! ( iscapture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioDeviceEvent ) ) . padding1 as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioDeviceEvent )
                , "::" , stringify ! ( padding1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioDeviceEvent ) ) . padding2 as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioDeviceEvent )
                , "::" , stringify ! ( padding2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_AudioDeviceEvent ) ) . padding3 as *
                const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_AudioDeviceEvent )
                , "::" , stringify ! ( padding3 ) ));
}
impl Clone for SDL_AudioDeviceEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Touch finger event structure (event.tfinger.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_TouchFingerEvent {
    /// < ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The touch device id
    pub touchId: SDL_TouchID,
    pub fingerId: SDL_FingerID,
    /// < Normalized in the range 0...1
    pub x: f32,
    /// < Normalized in the range 0...1
    pub y: f32,
    /// < Normalized in the range -1...1
    pub dx: f32,
    /// < Normalized in the range -1...1
    pub dy: f32,
    /// < Normalized in the range 0...1
    pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_TouchFingerEvent() {
    assert_eq!(::std::mem::size_of::<SDL_TouchFingerEvent>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( SDL_TouchFingerEvent )
               ));
    assert_eq! (::std::mem::align_of::<SDL_TouchFingerEvent>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_TouchFingerEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TouchFingerEvent ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TouchFingerEvent )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TouchFingerEvent ) ) . timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TouchFingerEvent )
                , "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TouchFingerEvent ) ) . touchId as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TouchFingerEvent )
                , "::" , stringify ! ( touchId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TouchFingerEvent ) ) . fingerId as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TouchFingerEvent )
                , "::" , stringify ! ( fingerId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TouchFingerEvent ) ) . x as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TouchFingerEvent )
                , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TouchFingerEvent ) ) . y as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TouchFingerEvent )
                , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TouchFingerEvent ) ) . dx as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TouchFingerEvent )
                , "::" , stringify ! ( dx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TouchFingerEvent ) ) . dy as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TouchFingerEvent )
                , "::" , stringify ! ( dy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_TouchFingerEvent ) ) . pressure as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_TouchFingerEvent )
                , "::" , stringify ! ( pressure ) ));
}
impl Clone for SDL_TouchFingerEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Multiple Finger Gesture Event (event.mgesture.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_MultiGestureEvent {
    /// < ::SDL_MULTIGESTURE
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The touch device id
    pub touchId: SDL_TouchID,
    pub dTheta: f32,
    pub dDist: f32,
    pub x: f32,
    pub y: f32,
    pub numFingers: Uint16,
    pub padding: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_MultiGestureEvent() {
    assert_eq!(::std::mem::size_of::<SDL_MultiGestureEvent>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( SDL_MultiGestureEvent )
               ));
    assert_eq! (::std::mem::align_of::<SDL_MultiGestureEvent>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_MultiGestureEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MultiGestureEvent ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MultiGestureEvent )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MultiGestureEvent ) ) . timestamp as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MultiGestureEvent )
                , "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MultiGestureEvent ) ) . touchId as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MultiGestureEvent )
                , "::" , stringify ! ( touchId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MultiGestureEvent ) ) . dTheta as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MultiGestureEvent )
                , "::" , stringify ! ( dTheta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MultiGestureEvent ) ) . dDist as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MultiGestureEvent )
                , "::" , stringify ! ( dDist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MultiGestureEvent ) ) . x as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MultiGestureEvent )
                , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MultiGestureEvent ) ) . y as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MultiGestureEvent )
                , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MultiGestureEvent ) ) . numFingers as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MultiGestureEvent )
                , "::" , stringify ! ( numFingers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MultiGestureEvent ) ) . padding as *
                const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MultiGestureEvent )
                , "::" , stringify ! ( padding ) ));
}
impl Clone for SDL_MultiGestureEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief Dollar Gesture Event (event.dgesture.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_DollarGestureEvent {
    /// < ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The touch device id
    pub touchId: SDL_TouchID,
    pub gestureId: SDL_GestureID,
    pub numFingers: Uint32,
    pub error: f32,
    /// < Normalized center of gesture
    pub x: f32,
    /// < Normalized center of gesture
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_DollarGestureEvent() {
    assert_eq!(::std::mem::size_of::<SDL_DollarGestureEvent>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( SDL_DollarGestureEvent )
               ));
    assert_eq! (::std::mem::align_of::<SDL_DollarGestureEvent>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_DollarGestureEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DollarGestureEvent ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DollarGestureEvent
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DollarGestureEvent ) ) . timestamp as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DollarGestureEvent
                ) , "::" , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DollarGestureEvent ) ) . touchId as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DollarGestureEvent
                ) , "::" , stringify ! ( touchId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DollarGestureEvent ) ) . gestureId as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DollarGestureEvent
                ) , "::" , stringify ! ( gestureId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DollarGestureEvent ) ) . numFingers
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DollarGestureEvent
                ) , "::" , stringify ! ( numFingers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DollarGestureEvent ) ) . error as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DollarGestureEvent
                ) , "::" , stringify ! ( error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DollarGestureEvent ) ) . x as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DollarGestureEvent
                ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DollarGestureEvent ) ) . y as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DollarGestureEvent
                ) , "::" , stringify ! ( y ) ));
}
impl Clone for SDL_DollarGestureEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief An event used to request a file open by the system (event.drop.*)
/// This event is enabled by default, you can disable it with SDL_EventState().
/// \note If this event is enabled, you must free the filename in the event.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_DropEvent {
    /// < ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The file name, which should be freed with SDL_free(), is NULL on begin/complete
    pub file: *mut ::std::os::raw::c_char,
    /// < The window that was dropped on, if any
    pub windowID: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_DropEvent() {
    assert_eq!(::std::mem::size_of::<SDL_DropEvent>() , 24usize , concat ! (
               "Size of: " , stringify ! ( SDL_DropEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_DropEvent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SDL_DropEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DropEvent ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DropEvent ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DropEvent ) ) . timestamp as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DropEvent ) , "::"
                , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DropEvent ) ) . file as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DropEvent ) , "::"
                , stringify ! ( file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_DropEvent ) ) . windowID as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_DropEvent ) , "::"
                , stringify ! ( windowID ) ));
}
impl Clone for SDL_DropEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief The "quit requested" event
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_QuitEvent {
    /// < ::SDL_QUIT
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_QuitEvent() {
    assert_eq!(::std::mem::size_of::<SDL_QuitEvent>() , 8usize , concat ! (
               "Size of: " , stringify ! ( SDL_QuitEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_QuitEvent>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( SDL_QuitEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_QuitEvent ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_QuitEvent ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_QuitEvent ) ) . timestamp as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_QuitEvent ) , "::"
                , stringify ! ( timestamp ) ));
}
impl Clone for SDL_QuitEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief OS Specific event
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_OSEvent {
    /// < ::SDL_QUIT
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_OSEvent() {
    assert_eq!(::std::mem::size_of::<SDL_OSEvent>() , 8usize , concat ! (
               "Size of: " , stringify ! ( SDL_OSEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_OSEvent>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( SDL_OSEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_OSEvent ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_OSEvent ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_OSEvent ) ) . timestamp as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_OSEvent ) , "::" ,
                stringify ! ( timestamp ) ));
}
impl Clone for SDL_OSEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief A user-defined event type (event.user.*)
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_UserEvent {
    /// < ::SDL_USEREVENT through ::SDL_LASTEVENT-1
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < The associated window if any
    pub windowID: Uint32,
    /// < User defined event code
    pub code: Sint32,
    /// < User defined data pointer
    pub data1: *mut ::std::os::raw::c_void,
    /// < User defined data pointer
    pub data2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SDL_UserEvent() {
    assert_eq!(::std::mem::size_of::<SDL_UserEvent>() , 32usize , concat ! (
               "Size of: " , stringify ! ( SDL_UserEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_UserEvent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SDL_UserEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_UserEvent ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_UserEvent ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_UserEvent ) ) . timestamp as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_UserEvent ) , "::"
                , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_UserEvent ) ) . windowID as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_UserEvent ) , "::"
                , stringify ! ( windowID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_UserEvent ) ) . code as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_UserEvent ) , "::"
                , stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_UserEvent ) ) . data1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_UserEvent ) , "::"
                , stringify ! ( data1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_UserEvent ) ) . data2 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_UserEvent ) , "::"
                , stringify ! ( data2 ) ));
}
impl Clone for SDL_UserEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SysWMmsg {
    _unused: [u8; 0],
}
/// \brief A video driver dependent system event (event.syswm.*)
/// This event is disabled by default, you can enable it with SDL_EventState()
///
/// \note If you want to use this event, you should include SDL_syswm.h.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_SysWMEvent {
    /// < ::SDL_SYSWMEVENT
    pub type_: Uint32,
    /// < In milliseconds, populated using SDL_GetTicks()
    pub timestamp: Uint32,
    /// < driver dependent data, defined in SDL_syswm.h
    pub msg: *mut SDL_SysWMmsg,
}
#[test]
fn bindgen_test_layout_SDL_SysWMEvent() {
    assert_eq!(::std::mem::size_of::<SDL_SysWMEvent>() , 16usize , concat ! (
               "Size of: " , stringify ! ( SDL_SysWMEvent ) ));
    assert_eq! (::std::mem::align_of::<SDL_SysWMEvent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SDL_SysWMEvent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_SysWMEvent ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_SysWMEvent ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_SysWMEvent ) ) . timestamp as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_SysWMEvent ) , "::"
                , stringify ! ( timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_SysWMEvent ) ) . msg as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_SysWMEvent ) , "::"
                , stringify ! ( msg ) ));
}
impl Clone for SDL_SysWMEvent {
    fn clone(&self) -> Self { *self }
}
/// \brief General event structure
#[repr(C)]
#[derive(Copy)]
pub union SDL_Event {
    /// < Event type, shared with all events
    pub type_: Uint32,
    /// < Common event data
    pub common: SDL_CommonEvent,
    /// < Window event data
    pub window: SDL_WindowEvent,
    /// < Keyboard event data
    pub key: SDL_KeyboardEvent,
    /// < Text editing event data
    pub edit: SDL_TextEditingEvent,
    /// < Text input event data
    pub text: SDL_TextInputEvent,
    /// < Mouse motion event data
    pub motion: SDL_MouseMotionEvent,
    /// < Mouse button event data
    pub button: SDL_MouseButtonEvent,
    /// < Mouse wheel event data
    pub wheel: SDL_MouseWheelEvent,
    /// < Joystick axis event data
    pub jaxis: SDL_JoyAxisEvent,
    /// < Joystick ball event data
    pub jball: SDL_JoyBallEvent,
    /// < Joystick hat event data
    pub jhat: SDL_JoyHatEvent,
    /// < Joystick button event data
    pub jbutton: SDL_JoyButtonEvent,
    /// < Joystick device change event data
    pub jdevice: SDL_JoyDeviceEvent,
    /// < Game Controller axis event data
    pub caxis: SDL_ControllerAxisEvent,
    /// < Game Controller button event data
    pub cbutton: SDL_ControllerButtonEvent,
    /// < Game Controller device event data
    pub cdevice: SDL_ControllerDeviceEvent,
    /// < Audio device event data
    pub adevice: SDL_AudioDeviceEvent,
    /// < Quit request event data
    pub quit: SDL_QuitEvent,
    /// < Custom event data
    pub user: SDL_UserEvent,
    /// < System dependent window event data
    pub syswm: SDL_SysWMEvent,
    /// < Touch finger event data
    pub tfinger: SDL_TouchFingerEvent,
    /// < Gesture event data
    pub mgesture: SDL_MultiGestureEvent,
    /// < Gesture event data
    pub dgesture: SDL_DollarGestureEvent,
    /// < Drag and drop event data
    pub drop: SDL_DropEvent,
    pub padding: [Uint8; 56usize],
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_SDL_Event() {
    assert_eq!(::std::mem::size_of::<SDL_Event>() , 56usize , concat ! (
               "Size of: " , stringify ! ( SDL_Event ) ));
    assert_eq! (::std::mem::align_of::<SDL_Event>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( SDL_Event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . common as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( common ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . window as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . key as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . edit as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( edit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . text as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( text ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . motion as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( motion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . button as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . wheel as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( wheel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . jaxis as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( jaxis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . jball as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( jball ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . jhat as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( jhat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . jbutton as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( jbutton ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . jdevice as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( jdevice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . caxis as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( caxis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . cbutton as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( cbutton ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . cdevice as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( cdevice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . adevice as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( adevice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . quit as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( quit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . user as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . syswm as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( syswm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . tfinger as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( tfinger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . mgesture as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( mgesture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . dgesture as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( dgesture ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . drop as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( drop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_Event ) ) . padding as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_Event ) , "::" ,
                stringify ! ( padding ) ));
}
impl Clone for SDL_Event {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// Pumps the event loop, gathering events from the input devices.
///
/// This function updates the event queue and internal input device state.
///
/// This should only be run in the thread that sets the video mode.
    pub fn SDL_PumpEvents();
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_eventaction {
    SDL_ADDEVENT = 0,
    SDL_PEEKEVENT = 1,
    SDL_GETEVENT = 2,
}
extern "C" {
    /// Checks the event queue for messages and optionally returns them.
///
/// If \c action is ::SDL_ADDEVENT, up to \c numevents events will be added to
/// the back of the event queue.
///
/// If \c action is ::SDL_PEEKEVENT, up to \c numevents events at the front
/// of the event queue, within the specified minimum and maximum type,
/// will be returned and will not be removed from the queue.
///
/// If \c action is ::SDL_GETEVENT, up to \c numevents events at the front
/// of the event queue, within the specified minimum and maximum type,
/// will be returned and will be removed from the queue.
///
/// \return The number of events actually stored, or -1 if there was an error.
///
/// This function is thread-safe.
    pub fn SDL_PeepEvents(events: *mut SDL_Event,
                          numevents: ::std::os::raw::c_int,
                          action: SDL_eventaction, minType: Uint32,
                          maxType: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// Checks to see if certain event types are in the event queue.
    pub fn SDL_HasEvent(type_: Uint32) -> SDL_bool;
}
extern "C" {
    pub fn SDL_HasEvents(minType: Uint32, maxType: Uint32) -> SDL_bool;
}
extern "C" {
    /// This function clears events from the event queue
/// This function only affects currently queued events. If you want to make
/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()
/// on the main thread immediately before the flush call.
    pub fn SDL_FlushEvent(type_: Uint32);
}
extern "C" {
    pub fn SDL_FlushEvents(minType: Uint32, maxType: Uint32);
}
extern "C" {
    /// \brief Polls for currently pending events.
///
/// \return 1 if there are any pending events, or 0 if there are none available.
///
/// \param event If not NULL, the next event is removed from the queue and
/// stored in that area.
    pub fn SDL_PollEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Waits indefinitely for the next available event.
///
/// \return 1, or 0 if there was an error while waiting for events.
///
/// \param event If not NULL, the next event is removed from the queue and
/// stored in that area.
    pub fn SDL_WaitEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Waits until the specified timeout (in milliseconds) for the next
/// available event.
///
/// \return 1, or 0 if there was an error while waiting for events.
///
/// \param event If not NULL, the next event is removed from the queue and
/// stored in that area.
/// \param timeout The timeout (in milliseconds) to wait for next event.
    pub fn SDL_WaitEventTimeout(event: *mut SDL_Event,
                                timeout: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Add an event to the event queue.
///
/// \return 1 on success, 0 if the event was filtered, or -1 if the event queue
/// was full or there was some other error.
    pub fn SDL_PushEvent(event: *mut SDL_Event) -> ::std::os::raw::c_int;
}
pub type SDL_EventFilter =
    ::std::option::Option<unsafe extern "C" fn(userdata:
                                                   *mut ::std::os::raw::c_void,
                                               event: *mut SDL_Event)
                              -> ::std::os::raw::c_int>;
extern "C" {
    /// Sets up a filter to process all events before they change internal state and
/// are posted to the internal event queue.
///
/// The filter is prototyped as:
/// \code
/// int SDL_EventFilter(void *userdata, SDL_Event * event);
/// \endcode
///
/// If the filter returns 1, then the event will be added to the internal queue.
/// If it returns 0, then the event will be dropped from the queue, but the
/// internal state will still be updated.  This allows selective filtering of
/// dynamically arriving events.
///
/// \warning  Be very careful of what you do in the event filter function, as
/// it may run in a different thread!
///
/// There is one caveat when dealing with the ::SDL_QuitEvent event type.  The
/// event filter is only called when the window manager desires to close the
/// application window.  If the event filter returns 1, then the window will
/// be closed, otherwise the window will remain open if possible.
///
/// If the quit event is generated by an interrupt signal, it will bypass the
/// internal queue and be delivered to the application at the next event poll.
    pub fn SDL_SetEventFilter(filter: SDL_EventFilter,
                              userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Return the current event filter - can be used to "chain" filters.
/// If there is no event filter set, this function returns SDL_FALSE.
    pub fn SDL_GetEventFilter(filter: *mut SDL_EventFilter,
                              userdata: *mut *mut ::std::os::raw::c_void)
     -> SDL_bool;
}
extern "C" {
    /// Add a function which is called when an event is added to the queue.
    pub fn SDL_AddEventWatch(filter: SDL_EventFilter,
                             userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Remove an event watch function added with SDL_AddEventWatch()
    pub fn SDL_DelEventWatch(filter: SDL_EventFilter,
                             userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// Run the filter function on the current event queue, removing any
/// events for which the filter returns 0.
    pub fn SDL_FilterEvents(filter: SDL_EventFilter,
                            userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// This function allows you to set the state of processing certain events.
/// - If \c state is set to ::SDL_IGNORE, that event will be automatically
/// dropped from the event queue and will not be filtered.
/// - If \c state is set to ::SDL_ENABLE, that event will be processed
/// normally.
/// - If \c state is set to ::SDL_QUERY, SDL_EventState() will return the
/// current processing state of the specified event.
    pub fn SDL_EventState(type_: Uint32, state: ::std::os::raw::c_int)
     -> Uint8;
}
extern "C" {
    /// This function allocates a set of user-defined events, and returns
/// the beginning event number for that set of events.
///
/// If there aren't enough user-defined events left, this function
/// returns (Uint32)-1
    pub fn SDL_RegisterEvents(numevents: ::std::os::raw::c_int) -> Uint32;
}
extern "C" {
    /// \brief Get the path where the application resides.
///
/// Get the "base path". This is the directory where the application was run
/// from, which is probably the installation directory, and may or may not
/// be the process's current working directory.
///
/// This returns an absolute path in UTF-8 encoding, and is guaranteed to
/// end with a path separator ('\\' on Windows, '/' most other places).
///
/// The pointer returned by this function is owned by you. Please call
/// SDL_free() on the pointer when you are done with it, or it will be a
/// memory leak. This is not necessarily a fast call, though, so you should
/// call this once near startup and save the string if you need it.
///
/// Some platforms can't determine the application's path, and on other
/// platforms, this might be meaningless. In such cases, this function will
/// return NULL.
///
/// \return String of base dir in UTF-8 encoding, or NULL on error.
///
/// \sa SDL_GetPrefPath
    pub fn SDL_GetBasePath() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Get the user-and-app-specific path where files can be written.
///
/// Get the "pref dir". This is meant to be where users can write personal
/// files (preferences and save games, etc) that are specific to your
/// application. This directory is unique per user, per application.
///
/// This function will decide the appropriate location in the native filesystem,
/// create the directory if necessary, and return a string of the absolute
/// path to the directory in UTF-8 encoding.
///
/// On Windows, the string might look like:
/// "C:\\Users\\bob\\AppData\\Roaming\\My Company\\My Program Name\\"
///
/// On Linux, the string might look like:
/// "/home/bob/.local/share/My Program Name/"
///
/// On Mac OS X, the string might look like:
/// "/Users/bob/Library/Application Support/My Program Name/"
///
/// (etc.)
///
/// You specify the name of your organization (if it's not a real organization,
/// your name or an Internet domain you own might do) and the name of your
/// application. These should be untranslated proper names.
///
/// Both the org and app strings may become part of a directory name, so
/// please follow these rules:
///
/// - Try to use the same org string (including case-sensitivity) for
/// all your applications that use this function.
/// - Always use a unique app string for each one, and make sure it never
/// changes for an app once you've decided on it.
/// - Unicode characters are legal, as long as it's UTF-8 encoded, but...
/// - ...only use letters, numbers, and spaces. Avoid punctuation like
/// "Game Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.
///
/// This returns an absolute path in UTF-8 encoding, and is guaranteed to
/// end with a path separator ('\\' on Windows, '/' most other places).
///
/// The pointer returned by this function is owned by you. Please call
/// SDL_free() on the pointer when you are done with it, or it will be a
/// memory leak. This is not necessarily a fast call, though, so you should
/// call this once near startup and save the string if you need it.
///
/// You should assume the path returned by this function is the only safe
/// place to write files (and that SDL_GetBasePath(), while it might be
/// writable, or even the parent of the returned path, aren't where you
/// should be writing things).
///
/// Some platforms can't determine the pref path, and on other
/// platforms, this might be meaningless. In such cases, this function will
/// return NULL.
///
/// \param org The name of your organization.
/// \param app The name of your application.
/// \return UTF-8 string of user dir in platform-dependent notation. NULL
/// if there's a problem (creating directory failed, etc).
///
/// \sa SDL_GetBasePath
    pub fn SDL_GetPrefPath(org: *const ::std::os::raw::c_char,
                           app: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Haptic {
    _unused: [u8; 0],
}
pub type SDL_Haptic = _SDL_Haptic;
/// \brief Structure that represents a haptic direction.
///
/// This is the direction where the force comes from,
/// instead of the direction in which the force is exerted.
///
/// Directions can be specified by:
/// - ::SDL_HAPTIC_POLAR : Specified by polar coordinates.
/// - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.
/// - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.
///
/// Cardinal directions of the haptic device are relative to the positioning
/// of the device.  North is considered to be away from the user.
///
/// The following diagram represents the cardinal directions:
/// \verbatim
/// .--.
/// |__| .-------.
/// |=.| |.-----.|
/// |--| ||     ||
/// |  | |'-----'|
/// |__|~')_____('
/// [ COMPUTER ]
///
///
/// North (0,-1)
/// ^
/// |
/// |
/// (-1,0)  West <----[ HAPTIC ]----> East (1,0)
/// |
/// |
/// v
/// South (0,1)
///
///
/// [ USER ]
/// \|||/
/// (o o)
/// ---ooO-(_)-Ooo---
/// \endverbatim
///
/// If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a
/// degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses
/// the first \c dir parameter.  The cardinal directions would be:
/// - North: 0 (0 degrees)
/// - East: 9000 (90 degrees)
/// - South: 18000 (180 degrees)
/// - West: 27000 (270 degrees)
///
/// If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions
/// (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses
/// the first three \c dir parameters.  The cardinal directions would be:
/// - North:  0,-1, 0
/// - East:   1, 0, 0
/// - South:  0, 1, 0
/// - West:  -1, 0, 0
///
/// The Z axis represents the height of the effect if supported, otherwise
/// it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you
/// can use any multiple you want, only the direction matters.
///
/// If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.
/// The first two \c dir parameters are used.  The \c dir parameters are as
/// follows (all values are in hundredths of degrees):
/// - Degrees from (1, 0) rotated towards (0, 1).
/// - Degrees towards (0, 0, 1) (device needs at least 3 axes).
///
///
/// Example of force coming from the south with all encodings (force coming
/// from the south means the user will have to pull the stick to counteract):
/// \code
/// SDL_HapticDirection direction;
///
/// // Cartesian directions
/// direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.
/// direction.dir[0] = 0; // X position
/// direction.dir[1] = 1; // Y position
/// // Assuming the device has 2 axes, we don't need to specify third parameter.
///
/// // Polar directions
/// direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.
/// direction.dir[0] = 18000; // Polar only uses first parameter
///
/// // Spherical coordinates
/// direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding
/// direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.
/// \endcode
///
/// \sa SDL_HAPTIC_POLAR
/// \sa SDL_HAPTIC_CARTESIAN
/// \sa SDL_HAPTIC_SPHERICAL
/// \sa SDL_HapticEffect
/// \sa SDL_HapticNumAxes
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_HapticDirection {
    /// < The type of encoding.
    pub type_: Uint8,
    /// < The encoded direction.
    pub dir: [Sint32; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticDirection() {
    assert_eq!(::std::mem::size_of::<SDL_HapticDirection>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( SDL_HapticDirection ) ));
    assert_eq! (::std::mem::align_of::<SDL_HapticDirection>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_HapticDirection ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticDirection ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticDirection ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticDirection ) ) . dir as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticDirection ) ,
                "::" , stringify ! ( dir ) ));
}
impl Clone for SDL_HapticDirection {
    fn clone(&self) -> Self { *self }
}
/// \brief A structure containing a template for a Constant effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect.
///
/// A constant effect applies a constant force in the specified direction
/// to the joystick.
///
/// \sa SDL_HAPTIC_CONSTANT
/// \sa SDL_HapticEffect
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_HapticConstant {
    /// < ::SDL_HAPTIC_CONSTANT
    pub type_: Uint16,
    /// < Direction of the effect.
    pub direction: SDL_HapticDirection,
    /// < Duration of the effect.
    pub length: Uint32,
    /// < Delay before starting the effect.
    pub delay: Uint16,
    /// < Button that triggers the effect.
    pub button: Uint16,
    /// < How soon it can be triggered again after button.
    pub interval: Uint16,
    /// < Strength of the constant effect.
    pub level: Sint16,
    /// < Duration of the attack.
    pub attack_length: Uint16,
    /// < Level at the start of the attack.
    pub attack_level: Uint16,
    /// < Duration of the fade.
    pub fade_length: Uint16,
    /// < Level at the end of the fade.
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticConstant() {
    assert_eq!(::std::mem::size_of::<SDL_HapticConstant>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( SDL_HapticConstant ) ));
    assert_eq! (::std::mem::align_of::<SDL_HapticConstant>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( SDL_HapticConstant ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticConstant ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticConstant ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticConstant ) ) . direction as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticConstant ) ,
                "::" , stringify ! ( direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticConstant ) ) . length as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticConstant ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticConstant ) ) . delay as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticConstant ) ,
                "::" , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticConstant ) ) . button as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticConstant ) ,
                "::" , stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticConstant ) ) . interval as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticConstant ) ,
                "::" , stringify ! ( interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticConstant ) ) . level as * const
                _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticConstant ) ,
                "::" , stringify ! ( level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticConstant ) ) . attack_length as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticConstant ) ,
                "::" , stringify ! ( attack_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticConstant ) ) . attack_level as
                * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticConstant ) ,
                "::" , stringify ! ( attack_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticConstant ) ) . fade_length as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticConstant ) ,
                "::" , stringify ! ( fade_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticConstant ) ) . fade_level as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticConstant ) ,
                "::" , stringify ! ( fade_level ) ));
}
impl Clone for SDL_HapticConstant {
    fn clone(&self) -> Self { *self }
}
/// \brief A structure containing a template for a Periodic effect.
///
/// The struct handles the following effects:
/// - ::SDL_HAPTIC_SINE
/// - ::SDL_HAPTIC_LEFTRIGHT
/// - ::SDL_HAPTIC_TRIANGLE
/// - ::SDL_HAPTIC_SAWTOOTHUP
/// - ::SDL_HAPTIC_SAWTOOTHDOWN
///
/// A periodic effect consists in a wave-shaped effect that repeats itself
/// over time.  The type determines the shape of the wave and the parameters
/// determine the dimensions of the wave.
///
/// Phase is given by hundredth of a degree meaning that giving the phase a value
/// of 9000 will displace it 25% of its period.  Here are sample values:
/// -     0: No phase displacement.
/// -  9000: Displaced 25% of its period.
/// - 18000: Displaced 50% of its period.
/// - 27000: Displaced 75% of its period.
/// - 36000: Displaced 100% of its period, same as 0, but 0 is preferred.
///
/// Examples:
/// \verbatim
/// SDL_HAPTIC_SINE
/// __      __      __      __
/// /  \    /  \    /  \    /
/// /    \__/    \__/    \__/
///
/// SDL_HAPTIC_SQUARE
/// __    __    __    __    __
/// |  |  |  |  |  |  |  |  |  |
/// |  |__|  |__|  |__|  |__|  |
///
/// SDL_HAPTIC_TRIANGLE
/// /\    /\    /\    /\    /\
/// /  \  /  \  /  \  /  \  /
/// /    \/    \/    \/    \/
///
/// SDL_HAPTIC_SAWTOOTHUP
/// /|  /|  /|  /|  /|  /|  /|
/// / | / | / | / | / | / | / |
/// /  |/  |/  |/  |/  |/  |/  |
///
/// SDL_HAPTIC_SAWTOOTHDOWN
/// \  |\  |\  |\  |\  |\  |\  |
/// \ | \ | \ | \ | \ | \ | \ |
/// \|  \|  \|  \|  \|  \|  \|
/// \endverbatim
///
/// \sa SDL_HAPTIC_SINE
/// \sa SDL_HAPTIC_LEFTRIGHT
/// \sa SDL_HAPTIC_TRIANGLE
/// \sa SDL_HAPTIC_SAWTOOTHUP
/// \sa SDL_HAPTIC_SAWTOOTHDOWN
/// \sa SDL_HapticEffect
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_HapticPeriodic {
    /// < ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,
    /// ::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or
    /// ::SDL_HAPTIC_SAWTOOTHDOWN
    pub type_: Uint16,
    /// < Direction of the effect.
    pub direction: SDL_HapticDirection,
    /// < Duration of the effect.
    pub length: Uint32,
    /// < Delay before starting the effect.
    pub delay: Uint16,
    /// < Button that triggers the effect.
    pub button: Uint16,
    /// < How soon it can be triggered again after button.
    pub interval: Uint16,
    /// < Period of the wave.
    pub period: Uint16,
    /// < Peak value; if negative, equivalent to 180 degrees extra phase shift.
    pub magnitude: Sint16,
    /// < Mean value of the wave.
    pub offset: Sint16,
    /// < Positive phase shift given by hundredth of a degree.
    pub phase: Uint16,
    /// < Duration of the attack.
    pub attack_length: Uint16,
    /// < Level at the start of the attack.
    pub attack_level: Uint16,
    /// < Duration of the fade.
    pub fade_length: Uint16,
    /// < Level at the end of the fade.
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticPeriodic() {
    assert_eq!(::std::mem::size_of::<SDL_HapticPeriodic>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( SDL_HapticPeriodic ) ));
    assert_eq! (::std::mem::align_of::<SDL_HapticPeriodic>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( SDL_HapticPeriodic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . direction as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . length as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . delay as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . button as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . interval as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . period as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . magnitude as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( magnitude ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . offset as *
                const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . phase as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( phase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . attack_length as
                * const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( attack_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . attack_level as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( attack_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . fade_length as *
                const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( fade_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticPeriodic ) ) . fade_level as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticPeriodic ) ,
                "::" , stringify ! ( fade_level ) ));
}
impl Clone for SDL_HapticPeriodic {
    fn clone(&self) -> Self { *self }
}
/// \brief A structure containing a template for a Condition effect.
///
/// The struct handles the following effects:
/// - ::SDL_HAPTIC_SPRING: Effect based on axes position.
/// - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.
/// - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.
/// - ::SDL_HAPTIC_FRICTION: Effect based on axes movement.
///
/// Direction is handled by condition internals instead of a direction member.
/// The condition effect specific members have three parameters.  The first
/// refers to the X axis, the second refers to the Y axis and the third
/// refers to the Z axis.  The right terms refer to the positive side of the
/// axis and the left terms refer to the negative side of the axis.  Please
/// refer to the ::SDL_HapticDirection diagram for which side is positive and
/// which is negative.
///
/// \sa SDL_HapticDirection
/// \sa SDL_HAPTIC_SPRING
/// \sa SDL_HAPTIC_DAMPER
/// \sa SDL_HAPTIC_INERTIA
/// \sa SDL_HAPTIC_FRICTION
/// \sa SDL_HapticEffect
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_HapticCondition {
    /// < ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,
    /// ::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION
    pub type_: Uint16,
    /// < Direction of the effect - Not used ATM.
    pub direction: SDL_HapticDirection,
    /// < Duration of the effect.
    pub length: Uint32,
    /// < Delay before starting the effect.
    pub delay: Uint16,
    /// < Button that triggers the effect.
    pub button: Uint16,
    /// < How soon it can be triggered again after button.
    pub interval: Uint16,
    /// < Level when joystick is to the positive side; max 0xFFFF.
    pub right_sat: [Uint16; 3usize],
    /// < Level when joystick is to the negative side; max 0xFFFF.
    pub left_sat: [Uint16; 3usize],
    /// < How fast to increase the force towards the positive side.
    pub right_coeff: [Sint16; 3usize],
    /// < How fast to increase the force towards the negative side.
    pub left_coeff: [Sint16; 3usize],
    /// < Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered.
    pub deadband: [Uint16; 3usize],
    /// < Position of the dead zone.
    pub center: [Sint16; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticCondition() {
    assert_eq!(::std::mem::size_of::<SDL_HapticCondition>() , 68usize , concat
               ! ( "Size of: " , stringify ! ( SDL_HapticCondition ) ));
    assert_eq! (::std::mem::align_of::<SDL_HapticCondition>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_HapticCondition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . direction as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . length as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . delay as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . button as *
                const _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . interval as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . right_sat as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( right_sat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . left_sat as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( left_sat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . right_coeff as
                * const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( right_coeff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . left_coeff as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( left_coeff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . deadband as *
                const _ as usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( deadband ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCondition ) ) . center as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCondition ) ,
                "::" , stringify ! ( center ) ));
}
impl Clone for SDL_HapticCondition {
    fn clone(&self) -> Self { *self }
}
/// \brief A structure containing a template for a Ramp effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.
///
/// The ramp effect starts at start strength and ends at end strength.
/// It augments in linear fashion.  If you use attack and fade with a ramp
/// the effects get added to the ramp effect making the effect become
/// quadratic instead of linear.
///
/// \sa SDL_HAPTIC_RAMP
/// \sa SDL_HapticEffect
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_HapticRamp {
    /// < ::SDL_HAPTIC_RAMP
    pub type_: Uint16,
    /// < Direction of the effect.
    pub direction: SDL_HapticDirection,
    /// < Duration of the effect.
    pub length: Uint32,
    /// < Delay before starting the effect.
    pub delay: Uint16,
    /// < Button that triggers the effect.
    pub button: Uint16,
    /// < How soon it can be triggered again after button.
    pub interval: Uint16,
    /// < Beginning strength level.
    pub start: Sint16,
    /// < Ending strength level.
    pub end: Sint16,
    /// < Duration of the attack.
    pub attack_length: Uint16,
    /// < Level at the start of the attack.
    pub attack_level: Uint16,
    /// < Duration of the fade.
    pub fade_length: Uint16,
    /// < Level at the end of the fade.
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticRamp() {
    assert_eq!(::std::mem::size_of::<SDL_HapticRamp>() , 44usize , concat ! (
               "Size of: " , stringify ! ( SDL_HapticRamp ) ));
    assert_eq! (::std::mem::align_of::<SDL_HapticRamp>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( SDL_HapticRamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . direction as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . length as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . delay as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . button as * const _
                as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . interval as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . start as * const _
                as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . end as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . attack_length as *
                const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( attack_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . attack_level as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( attack_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . fade_length as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( fade_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticRamp ) ) . fade_level as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticRamp ) , "::"
                , stringify ! ( fade_level ) ));
}
impl Clone for SDL_HapticRamp {
    fn clone(&self) -> Self { *self }
}
/// \brief A structure containing a template for a Left/Right effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.
///
/// The Left/Right effect is used to explicitly control the large and small
/// motors, commonly found in modern game controllers. One motor is high
/// frequency, the other is low frequency.
///
/// \sa SDL_HAPTIC_LEFTRIGHT
/// \sa SDL_HapticEffect
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_HapticLeftRight {
    /// < ::SDL_HAPTIC_LEFTRIGHT
    pub type_: Uint16,
    /// < Duration of the effect.
    pub length: Uint32,
    /// < Control of the large controller motor.
    pub large_magnitude: Uint16,
    /// < Control of the small controller motor.
    pub small_magnitude: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticLeftRight() {
    assert_eq!(::std::mem::size_of::<SDL_HapticLeftRight>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( SDL_HapticLeftRight ) ));
    assert_eq! (::std::mem::align_of::<SDL_HapticLeftRight>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_HapticLeftRight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticLeftRight ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticLeftRight ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticLeftRight ) ) . length as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticLeftRight ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticLeftRight ) ) . large_magnitude
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticLeftRight ) ,
                "::" , stringify ! ( large_magnitude ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticLeftRight ) ) . small_magnitude
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticLeftRight ) ,
                "::" , stringify ! ( small_magnitude ) ));
}
impl Clone for SDL_HapticLeftRight {
    fn clone(&self) -> Self { *self }
}
/// \brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.
///
/// This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect.
///
/// A custom force feedback effect is much like a periodic effect, where the
/// application can define its exact shape.  You will have to allocate the
/// data yourself.  Data should consist of channels * samples Uint16 samples.
///
/// If channels is one, the effect is rotated using the defined direction.
/// Otherwise it uses the samples in data for the different axes.
///
/// \sa SDL_HAPTIC_CUSTOM
/// \sa SDL_HapticEffect
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_HapticCustom {
    /// < ::SDL_HAPTIC_CUSTOM
    pub type_: Uint16,
    /// < Direction of the effect.
    pub direction: SDL_HapticDirection,
    /// < Duration of the effect.
    pub length: Uint32,
    /// < Delay before starting the effect.
    pub delay: Uint16,
    /// < Button that triggers the effect.
    pub button: Uint16,
    /// < How soon it can be triggered again after button.
    pub interval: Uint16,
    /// < Axes to use, minimum of one.
    pub channels: Uint8,
    /// < Sample periods.
    pub period: Uint16,
    /// < Amount of samples.
    pub samples: Uint16,
    /// < Should contain channels*samples items.
    pub data: *mut Uint16,
    /// < Duration of the attack.
    pub attack_length: Uint16,
    /// < Level at the start of the attack.
    pub attack_level: Uint16,
    /// < Duration of the fade.
    pub fade_length: Uint16,
    /// < Level at the end of the fade.
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticCustom() {
    assert_eq!(::std::mem::size_of::<SDL_HapticCustom>() , 56usize , concat !
               ( "Size of: " , stringify ! ( SDL_HapticCustom ) ));
    assert_eq! (::std::mem::align_of::<SDL_HapticCustom>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SDL_HapticCustom ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . direction as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . length as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . delay as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . button as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( button ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . interval as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . channels as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( channels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . period as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( period ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . samples as * const
                _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . data as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . attack_length as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( attack_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . attack_level as *
                const _ as usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( attack_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . fade_length as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( fade_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticCustom ) ) . fade_level as *
                const _ as usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticCustom ) ,
                "::" , stringify ! ( fade_level ) ));
}
impl Clone for SDL_HapticCustom {
    fn clone(&self) -> Self { *self }
}
/// \brief The generic template for any haptic effect.
///
/// All values max at 32767 (0x7FFF).  Signed values also can be negative.
/// Time values unless specified otherwise are in milliseconds.
///
/// You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767
/// value.  Neither delay, interval, attack_length nor fade_length support
/// ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.
///
/// Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of
/// ::SDL_HAPTIC_INFINITY.
///
/// Button triggers may not be supported on all devices, it is advised to not
/// use them if possible.  Buttons start at index 1 instead of index 0 like
/// the joystick.
///
/// If both attack_length and fade_level are 0, the envelope is not used,
/// otherwise both values are used.
///
/// Common parts:
/// \code
/// // Replay - All effects have this
/// Uint32 length;        // Duration of effect (ms).
/// Uint16 delay;         // Delay before starting effect.
///
/// // Trigger - All effects have this
/// Uint16 button;        // Button that triggers effect.
/// Uint16 interval;      // How soon before effect can be triggered again.
///
/// // Envelope - All effects except condition effects have this
/// Uint16 attack_length; // Duration of the attack (ms).
/// Uint16 attack_level;  // Level at the start of the attack.
/// Uint16 fade_length;   // Duration of the fade out (ms).
/// Uint16 fade_level;    // Level at the end of the fade.
/// \endcode
///
///
/// Here we have an example of a constant effect evolution in time:
/// \verbatim
/// Strength
/// ^
/// |
/// |    effect level -->  _________________
/// |                     /                 \
/// |                    /                   \
/// |                   /                     \
/// |                  /                       \
/// | attack_level --> |                        \
/// |                  |                        |  <---  fade_level
/// |
/// +--------------------------------------------------> Time
/// [--]                 [---]
/// attack_length        fade_length
///
/// [------------------][-----------------------]
/// delay               length
/// \endverbatim
///
/// Note either the attack_level or the fade_level may be above the actual
/// effect level.
///
/// \sa SDL_HapticConstant
/// \sa SDL_HapticPeriodic
/// \sa SDL_HapticCondition
/// \sa SDL_HapticRamp
/// \sa SDL_HapticLeftRight
/// \sa SDL_HapticCustom
#[repr(C)]
#[derive(Copy)]
pub union SDL_HapticEffect {
    /// < Effect type.
    pub type_: Uint16,
    /// < Constant effect.
    pub constant: SDL_HapticConstant,
    /// < Periodic effect.
    pub periodic: SDL_HapticPeriodic,
    /// < Condition effect.
    pub condition: SDL_HapticCondition,
    /// < Ramp effect.
    pub ramp: SDL_HapticRamp,
    /// < Left/Right effect.
    pub leftright: SDL_HapticLeftRight,
    /// < Custom effect.
    pub custom: SDL_HapticCustom,
    _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticEffect() {
    assert_eq!(::std::mem::size_of::<SDL_HapticEffect>() , 72usize , concat !
               ( "Size of: " , stringify ! ( SDL_HapticEffect ) ));
    assert_eq! (::std::mem::align_of::<SDL_HapticEffect>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SDL_HapticEffect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticEffect ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticEffect ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticEffect ) ) . constant as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticEffect ) ,
                "::" , stringify ! ( constant ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticEffect ) ) . periodic as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticEffect ) ,
                "::" , stringify ! ( periodic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticEffect ) ) . condition as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticEffect ) ,
                "::" , stringify ! ( condition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticEffect ) ) . ramp as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticEffect ) ,
                "::" , stringify ! ( ramp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticEffect ) ) . leftright as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticEffect ) ,
                "::" , stringify ! ( leftright ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_HapticEffect ) ) . custom as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_HapticEffect ) ,
                "::" , stringify ! ( custom ) ));
}
impl Clone for SDL_HapticEffect {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// \brief Count the number of haptic devices attached to the system.
///
/// \return Number of haptic devices detected on the system.
    pub fn SDL_NumHaptics() -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the implementation dependent name of a haptic device.
///
/// This can be called before any joysticks are opened.
/// If no name can be found, this function returns NULL.
///
/// \param device_index Index of the device to get its name.
/// \return Name of the device or NULL on error.
///
/// \sa SDL_NumHaptics
    pub fn SDL_HapticName(device_index: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Opens a haptic device for use.
///
/// The index passed as an argument refers to the N'th haptic device on this
/// system.
///
/// When opening a haptic device, its gain will be set to maximum and
/// autocenter will be disabled.  To modify these values use
/// SDL_HapticSetGain() and SDL_HapticSetAutocenter().
///
/// \param device_index Index of the device to open.
/// \return Device identifier or NULL on error.
///
/// \sa SDL_HapticIndex
/// \sa SDL_HapticOpenFromMouse
/// \sa SDL_HapticOpenFromJoystick
/// \sa SDL_HapticClose
/// \sa SDL_HapticSetGain
/// \sa SDL_HapticSetAutocenter
/// \sa SDL_HapticPause
/// \sa SDL_HapticStopAll
    pub fn SDL_HapticOpen(device_index: ::std::os::raw::c_int)
     -> *mut SDL_Haptic;
}
extern "C" {
    /// \brief Checks if the haptic device at index has been opened.
///
/// \param device_index Index to check to see if it has been opened.
/// \return 1 if it has been opened or 0 if it hasn't.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticIndex
    pub fn SDL_HapticOpened(device_index: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Gets the index of a haptic device.
///
/// \param haptic Haptic device to get the index of.
/// \return The index of the haptic device or -1 on error.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticOpened
    pub fn SDL_HapticIndex(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Gets whether or not the current mouse has haptic capabilities.
///
/// \return SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't.
///
/// \sa SDL_HapticOpenFromMouse
    pub fn SDL_MouseIsHaptic() -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Tries to open a haptic device from the current mouse.
///
/// \return The haptic device identifier or NULL on error.
///
/// \sa SDL_MouseIsHaptic
/// \sa SDL_HapticOpen
    pub fn SDL_HapticOpenFromMouse() -> *mut SDL_Haptic;
}
extern "C" {
    /// \brief Checks to see if a joystick has haptic features.
///
/// \param joystick Joystick to test for haptic capabilities.
/// \return SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't
/// or -1 if an error occurred.
///
/// \sa SDL_HapticOpenFromJoystick
    pub fn SDL_JoystickIsHaptic(joystick: *mut SDL_Joystick)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Opens a haptic device for use from a joystick device.
///
/// You must still close the haptic device separately.  It will not be closed
/// with the joystick.
///
/// When opening from a joystick you should first close the haptic device before
/// closing the joystick device.  If not, on some implementations the haptic
/// device will also get unallocated and you'll be unable to use force feedback
/// on that device.
///
/// \param joystick Joystick to create a haptic device from.
/// \return A valid haptic device identifier on success or NULL on error.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticClose
    pub fn SDL_HapticOpenFromJoystick(joystick: *mut SDL_Joystick)
     -> *mut SDL_Haptic;
}
extern "C" {
    /// \brief Closes a haptic device previously opened with SDL_HapticOpen().
///
/// \param haptic Haptic device to close.
    pub fn SDL_HapticClose(haptic: *mut SDL_Haptic);
}
extern "C" {
    /// \brief Returns the number of effects a haptic device can store.
///
/// On some platforms this isn't fully supported, and therefore is an
/// approximation.  Always check to see if your created effect was actually
/// created and do not rely solely on SDL_HapticNumEffects().
///
/// \param haptic The haptic device to query effect max.
/// \return The number of effects the haptic device can store or
/// -1 on error.
///
/// \sa SDL_HapticNumEffectsPlaying
/// \sa SDL_HapticQuery
    pub fn SDL_HapticNumEffects(haptic: *mut SDL_Haptic)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Returns the number of effects a haptic device can play at the same
/// time.
///
/// This is not supported on all platforms, but will always return a value.
/// Added here for the sake of completeness.
///
/// \param haptic The haptic device to query maximum playing effects.
/// \return The number of effects the haptic device can play at the same time
/// or -1 on error.
///
/// \sa SDL_HapticNumEffects
/// \sa SDL_HapticQuery
    pub fn SDL_HapticNumEffectsPlaying(haptic: *mut SDL_Haptic)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Gets the haptic device's supported features in bitwise manner.
///
/// Example:
/// \code
/// if (SDL_HapticQuery(haptic) & SDL_HAPTIC_CONSTANT) {
/// printf("We have constant haptic effect!\n");
/// }
/// \endcode
///
/// \param haptic The haptic device to query.
/// \return Haptic features in bitwise manner (OR'd).
///
/// \sa SDL_HapticNumEffects
/// \sa SDL_HapticEffectSupported
    pub fn SDL_HapticQuery(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// \brief Gets the number of haptic axes the device has.
///
/// \sa SDL_HapticDirection
    pub fn SDL_HapticNumAxes(haptic: *mut SDL_Haptic)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Checks to see if effect is supported by haptic.
///
/// \param haptic Haptic device to check on.
/// \param effect Effect to check to see if it is supported.
/// \return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.
///
/// \sa SDL_HapticQuery
/// \sa SDL_HapticNewEffect
    pub fn SDL_HapticEffectSupported(haptic: *mut SDL_Haptic,
                                     effect: *mut SDL_HapticEffect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Creates a new haptic effect on the device.
///
/// \param haptic Haptic device to create the effect on.
/// \param effect Properties of the effect to create.
/// \return The identifier of the effect on success or -1 on error.
///
/// \sa SDL_HapticUpdateEffect
/// \sa SDL_HapticRunEffect
/// \sa SDL_HapticDestroyEffect
    pub fn SDL_HapticNewEffect(haptic: *mut SDL_Haptic,
                               effect: *mut SDL_HapticEffect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Updates the properties of an effect.
///
/// Can be used dynamically, although behavior when dynamically changing
/// direction may be strange.  Specifically the effect may reupload itself
/// and start playing from the start.  You cannot change the type either when
/// running SDL_HapticUpdateEffect().
///
/// \param haptic Haptic device that has the effect.
/// \param effect Identifier of the effect to update.
/// \param data New effect properties to use.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticNewEffect
/// \sa SDL_HapticRunEffect
/// \sa SDL_HapticDestroyEffect
    pub fn SDL_HapticUpdateEffect(haptic: *mut SDL_Haptic,
                                  effect: ::std::os::raw::c_int,
                                  data: *mut SDL_HapticEffect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Runs the haptic effect on its associated haptic device.
///
/// If iterations are ::SDL_HAPTIC_INFINITY, it'll run the effect over and over
/// repeating the envelope (attack and fade) every time.  If you only want the
/// effect to last forever, set ::SDL_HAPTIC_INFINITY in the effect's length
/// parameter.
///
/// \param haptic Haptic device to run the effect on.
/// \param effect Identifier of the haptic effect to run.
/// \param iterations Number of iterations to run the effect. Use
/// ::SDL_HAPTIC_INFINITY for infinity.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticStopEffect
/// \sa SDL_HapticDestroyEffect
/// \sa SDL_HapticGetEffectStatus
    pub fn SDL_HapticRunEffect(haptic: *mut SDL_Haptic,
                               effect: ::std::os::raw::c_int,
                               iterations: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Stops the haptic effect on its associated haptic device.
///
/// \param haptic Haptic device to stop the effect on.
/// \param effect Identifier of the effect to stop.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticRunEffect
/// \sa SDL_HapticDestroyEffect
    pub fn SDL_HapticStopEffect(haptic: *mut SDL_Haptic,
                                effect: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Destroys a haptic effect on the device.
///
/// This will stop the effect if it's running.  Effects are automatically
/// destroyed when the device is closed.
///
/// \param haptic Device to destroy the effect on.
/// \param effect Identifier of the effect to destroy.
///
/// \sa SDL_HapticNewEffect
    pub fn SDL_HapticDestroyEffect(haptic: *mut SDL_Haptic,
                                   effect: ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Gets the status of the current effect on the haptic device.
///
/// Device must support the ::SDL_HAPTIC_STATUS feature.
///
/// \param haptic Haptic device to query the effect status on.
/// \param effect Identifier of the effect to query its status.
/// \return 0 if it isn't playing, 1 if it is playing or -1 on error.
///
/// \sa SDL_HapticRunEffect
/// \sa SDL_HapticStopEffect
    pub fn SDL_HapticGetEffectStatus(haptic: *mut SDL_Haptic,
                                     effect: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Sets the global gain of the device.
///
/// Device must support the ::SDL_HAPTIC_GAIN feature.
///
/// The user may specify the maximum gain by setting the environment variable
/// SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to
/// SDL_HapticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the
/// maximum.
///
/// \param haptic Haptic device to set the gain on.
/// \param gain Value to set the gain to, should be between 0 and 100.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticQuery
    pub fn SDL_HapticSetGain(haptic: *mut SDL_Haptic,
                             gain: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Sets the global autocenter of the device.
///
/// Autocenter should be between 0 and 100.  Setting it to 0 will disable
/// autocentering.
///
/// Device must support the ::SDL_HAPTIC_AUTOCENTER feature.
///
/// \param haptic Haptic device to set autocentering on.
/// \param autocenter Value to set autocenter to, 0 disables autocentering.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticQuery
    pub fn SDL_HapticSetAutocenter(haptic: *mut SDL_Haptic,
                                   autocenter: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Pauses a haptic device.
///
/// Device must support the ::SDL_HAPTIC_PAUSE feature.  Call
/// SDL_HapticUnpause() to resume playback.
///
/// Do not modify the effects nor add new ones while the device is paused.
/// That can cause all sorts of weird errors.
///
/// \param haptic Haptic device to pause.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticUnpause
    pub fn SDL_HapticPause(haptic: *mut SDL_Haptic) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Unpauses a haptic device.
///
/// Call to unpause after SDL_HapticPause().
///
/// \param haptic Haptic device to unpause.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticPause
    pub fn SDL_HapticUnpause(haptic: *mut SDL_Haptic)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Stops all the currently playing effects on a haptic device.
///
/// \param haptic Haptic device to stop.
/// \return 0 on success or -1 on error.
    pub fn SDL_HapticStopAll(haptic: *mut SDL_Haptic)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Checks to see if rumble is supported on a haptic device.
///
/// \param haptic Haptic device to check to see if it supports rumble.
/// \return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.
///
/// \sa SDL_HapticRumbleInit
/// \sa SDL_HapticRumblePlay
/// \sa SDL_HapticRumbleStop
    pub fn SDL_HapticRumbleSupported(haptic: *mut SDL_Haptic)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Initializes the haptic device for simple rumble playback.
///
/// \param haptic Haptic device to initialize for simple rumble playback.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticOpen
/// \sa SDL_HapticRumbleSupported
/// \sa SDL_HapticRumblePlay
/// \sa SDL_HapticRumbleStop
    pub fn SDL_HapticRumbleInit(haptic: *mut SDL_Haptic)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Runs simple rumble on a haptic device
///
/// \param haptic Haptic device to play rumble effect on.
/// \param strength Strength of the rumble to play as a 0-1 float value.
/// \param length Length of the rumble to play in milliseconds.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticRumbleSupported
/// \sa SDL_HapticRumbleInit
/// \sa SDL_HapticRumbleStop
    pub fn SDL_HapticRumblePlay(haptic: *mut SDL_Haptic, strength: f32,
                                length: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Stops the simple rumble on a haptic device.
///
/// \param haptic Haptic to stop the rumble on.
/// \return 0 on success or -1 on error.
///
/// \sa SDL_HapticRumbleSupported
/// \sa SDL_HapticRumbleInit
/// \sa SDL_HapticRumblePlay
    pub fn SDL_HapticRumbleStop(haptic: *mut SDL_Haptic)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// \brief  An enumeration of hint priorities
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_HintPriority {
    SDL_HINT_DEFAULT = 0,
    SDL_HINT_NORMAL = 1,
    SDL_HINT_OVERRIDE = 2,
}
extern "C" {
    /// \brief Set a hint with a specific priority
///
/// The priority controls the behavior when setting a hint that already
/// has a value.  Hints will replace existing hints of their priority and
/// lower.  Environment variables are considered to have override priority.
///
/// \return SDL_TRUE if the hint was set, SDL_FALSE otherwise
    pub fn SDL_SetHintWithPriority(name: *const ::std::os::raw::c_char,
                                   value: *const ::std::os::raw::c_char,
                                   priority: SDL_HintPriority) -> SDL_bool;
}
extern "C" {
    /// \brief Set a hint with normal priority
///
/// \return SDL_TRUE if the hint was set, SDL_FALSE otherwise
    pub fn SDL_SetHint(name: *const ::std::os::raw::c_char,
                       value: *const ::std::os::raw::c_char) -> SDL_bool;
}
extern "C" {
    /// \brief Get a hint
///
/// \return The string value of a hint variable.
    pub fn SDL_GetHint(name: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Get a hint
///
/// \return The boolean value of a hint variable.
    pub fn SDL_GetHintBoolean(name: *const ::std::os::raw::c_char,
                              default_value: SDL_bool) -> SDL_bool;
}
/// \brief type definition of the hint callback function.
pub type SDL_HintCallback =
    ::std::option::Option<unsafe extern "C" fn(userdata:
                                                   *mut ::std::os::raw::c_void,
                                               name:
                                                   *const ::std::os::raw::c_char,
                                               oldValue:
                                                   *const ::std::os::raw::c_char,
                                               newValue:
                                                   *const ::std::os::raw::c_char)>;
extern "C" {
    /// \brief Add a function to watch a particular hint
///
/// \param name The hint to watch
/// \param callback The function to call when the hint value changes
/// \param userdata A pointer to pass to the callback function
    pub fn SDL_AddHintCallback(name: *const ::std::os::raw::c_char,
                               callback: SDL_HintCallback,
                               userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// \brief Remove a function watching a particular hint
///
/// \param name The hint being watched
/// \param callback The function being called when the hint value changes
/// \param userdata A pointer being passed to the callback function
    pub fn SDL_DelHintCallback(name: *const ::std::os::raw::c_char,
                               callback: SDL_HintCallback,
                               userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// \brief  Clear all hints
///
/// This function is called during SDL_Quit() to free stored hints.
    pub fn SDL_ClearHints();
}
extern "C" {
    /// This function dynamically loads a shared object and returns a pointer
/// to the object handle (or NULL if there was an error).
/// The 'sofile' parameter is a system dependent name of the object file.
    pub fn SDL_LoadObject(sofile: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Given an object handle, this function looks up the address of the
/// named function in the shared object and returns it.  This address
/// is no longer valid after calling SDL_UnloadObject().
    pub fn SDL_LoadFunction(handle: *mut ::std::os::raw::c_void,
                            name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /// Unload a shared object from memory.
    pub fn SDL_UnloadObject(handle: *mut ::std::os::raw::c_void);
}
pub const SDL_LOG_CATEGORY_APPLICATION: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_APPLICATION;
pub const SDL_LOG_CATEGORY_ERROR: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_ERROR;
pub const SDL_LOG_CATEGORY_ASSERT: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_ASSERT;
pub const SDL_LOG_CATEGORY_SYSTEM: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_SYSTEM;
pub const SDL_LOG_CATEGORY_AUDIO: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_AUDIO;
pub const SDL_LOG_CATEGORY_VIDEO: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_VIDEO;
pub const SDL_LOG_CATEGORY_RENDER: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_RENDER;
pub const SDL_LOG_CATEGORY_INPUT: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_INPUT;
pub const SDL_LOG_CATEGORY_TEST: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_TEST;
pub const SDL_LOG_CATEGORY_RESERVED1: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_RESERVED1;
pub const SDL_LOG_CATEGORY_RESERVED2: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_RESERVED2;
pub const SDL_LOG_CATEGORY_RESERVED3: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_RESERVED3;
pub const SDL_LOG_CATEGORY_RESERVED4: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_RESERVED4;
pub const SDL_LOG_CATEGORY_RESERVED5: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_RESERVED5;
pub const SDL_LOG_CATEGORY_RESERVED6: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_RESERVED6;
pub const SDL_LOG_CATEGORY_RESERVED7: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_RESERVED7;
pub const SDL_LOG_CATEGORY_RESERVED8: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_RESERVED8;
pub const SDL_LOG_CATEGORY_RESERVED9: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_RESERVED9;
pub const SDL_LOG_CATEGORY_RESERVED10: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_RESERVED10;
pub const SDL_LOG_CATEGORY_CUSTOM: _bindgen_ty_8 =
    _bindgen_ty_8::SDL_LOG_CATEGORY_CUSTOM;
#[repr(u32)]
/// \brief The predefined log categories
///
/// By default the application category is enabled at the INFO level,
/// the assert category is enabled at the WARN level, test is enabled
/// at the VERBOSE level and all other categories are enabled at the
/// CRITICAL level.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    SDL_LOG_CATEGORY_APPLICATION = 0,
    SDL_LOG_CATEGORY_ERROR = 1,
    SDL_LOG_CATEGORY_ASSERT = 2,
    SDL_LOG_CATEGORY_SYSTEM = 3,
    SDL_LOG_CATEGORY_AUDIO = 4,
    SDL_LOG_CATEGORY_VIDEO = 5,
    SDL_LOG_CATEGORY_RENDER = 6,
    SDL_LOG_CATEGORY_INPUT = 7,
    SDL_LOG_CATEGORY_TEST = 8,
    SDL_LOG_CATEGORY_RESERVED1 = 9,
    SDL_LOG_CATEGORY_RESERVED2 = 10,
    SDL_LOG_CATEGORY_RESERVED3 = 11,
    SDL_LOG_CATEGORY_RESERVED4 = 12,
    SDL_LOG_CATEGORY_RESERVED5 = 13,
    SDL_LOG_CATEGORY_RESERVED6 = 14,
    SDL_LOG_CATEGORY_RESERVED7 = 15,
    SDL_LOG_CATEGORY_RESERVED8 = 16,
    SDL_LOG_CATEGORY_RESERVED9 = 17,
    SDL_LOG_CATEGORY_RESERVED10 = 18,
    SDL_LOG_CATEGORY_CUSTOM = 19,
}
#[repr(u32)]
/// \brief The predefined log priorities
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_LogPriority {
    SDL_LOG_PRIORITY_VERBOSE = 1,
    SDL_LOG_PRIORITY_DEBUG = 2,
    SDL_LOG_PRIORITY_INFO = 3,
    SDL_LOG_PRIORITY_WARN = 4,
    SDL_LOG_PRIORITY_ERROR = 5,
    SDL_LOG_PRIORITY_CRITICAL = 6,
    SDL_NUM_LOG_PRIORITIES = 7,
}
extern "C" {
    /// \brief Set the priority of all log categories
    pub fn SDL_LogSetAllPriority(priority: SDL_LogPriority);
}
extern "C" {
    /// \brief Set the priority of a particular log category
    pub fn SDL_LogSetPriority(category: ::std::os::raw::c_int,
                              priority: SDL_LogPriority);
}
extern "C" {
    /// \brief Get the priority of a particular log category
    pub fn SDL_LogGetPriority(category: ::std::os::raw::c_int)
     -> SDL_LogPriority;
}
extern "C" {
    /// \brief Reset all priorities to default.
///
/// \note This is called in SDL_Quit().
    pub fn SDL_LogResetPriorities();
}
extern "C" {
    /// \brief Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO
    pub fn SDL_Log(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    /// \brief Log a message with SDL_LOG_PRIORITY_VERBOSE
    pub fn SDL_LogVerbose(category: ::std::os::raw::c_int,
                          fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    /// \brief Log a message with SDL_LOG_PRIORITY_DEBUG
    pub fn SDL_LogDebug(category: ::std::os::raw::c_int,
                        fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    /// \brief Log a message with SDL_LOG_PRIORITY_INFO
    pub fn SDL_LogInfo(category: ::std::os::raw::c_int,
                       fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    /// \brief Log a message with SDL_LOG_PRIORITY_WARN
    pub fn SDL_LogWarn(category: ::std::os::raw::c_int,
                       fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    /// \brief Log a message with SDL_LOG_PRIORITY_ERROR
    pub fn SDL_LogError(category: ::std::os::raw::c_int,
                        fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    /// \brief Log a message with SDL_LOG_PRIORITY_CRITICAL
    pub fn SDL_LogCritical(category: ::std::os::raw::c_int,
                           fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    /// \brief Log a message with the specified category and priority.
    pub fn SDL_LogMessage(category: ::std::os::raw::c_int,
                          priority: SDL_LogPriority,
                          fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    /// \brief Log a message with the specified category and priority.
    pub fn SDL_LogMessageV(category: ::std::os::raw::c_int,
                           priority: SDL_LogPriority,
                           fmt: *const ::std::os::raw::c_char,
                           ap: *mut __va_list_tag);
}
/// \brief The prototype for the log output function
pub type SDL_LogOutputFunction =
    ::std::option::Option<unsafe extern "C" fn(userdata:
                                                   *mut ::std::os::raw::c_void,
                                               category:
                                                   ::std::os::raw::c_int,
                                               priority: SDL_LogPriority,
                                               message:
                                                   *const ::std::os::raw::c_char)>;
extern "C" {
    /// \brief Get the current log output function.
    pub fn SDL_LogGetOutputFunction(callback: *mut SDL_LogOutputFunction,
                                    userdata:
                                        *mut *mut ::std::os::raw::c_void);
}
extern "C" {
    /// \brief This function allows you to replace the default log output
/// function with one of your own.
    pub fn SDL_LogSetOutputFunction(callback: SDL_LogOutputFunction,
                                    userdata: *mut ::std::os::raw::c_void);
}
#[repr(u32)]
/// \brief SDL_MessageBox flags. If supported will display warning icon, etc.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_MessageBoxFlags {
    SDL_MESSAGEBOX_ERROR = 16,
    SDL_MESSAGEBOX_WARNING = 32,
    SDL_MESSAGEBOX_INFORMATION = 64,
}
#[repr(u32)]
/// \brief Flags for SDL_MessageBoxButtonData.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_MessageBoxButtonFlags {
    SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = 1,
    SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = 2,
}
/// \brief Individual button data.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_MessageBoxButtonData {
    /// < ::SDL_MessageBoxButtonFlags
    pub flags: Uint32,
    /// < User defined button id (value returned via SDL_ShowMessageBox)
    pub buttonid: ::std::os::raw::c_int,
    /// < The UTF-8 button text
    pub text: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxButtonData() {
    assert_eq!(::std::mem::size_of::<SDL_MessageBoxButtonData>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( SDL_MessageBoxButtonData ) ));
    assert_eq! (::std::mem::align_of::<SDL_MessageBoxButtonData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_MessageBoxButtonData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxButtonData ) ) . flags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_MessageBoxButtonData ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxButtonData ) ) . buttonid
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_MessageBoxButtonData ) , "::" , stringify ! ( buttonid )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxButtonData ) ) . text as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_MessageBoxButtonData ) , "::" , stringify ! ( text ) ));
}
impl Clone for SDL_MessageBoxButtonData {
    fn clone(&self) -> Self { *self }
}
/// \brief RGB value used in a message box color scheme
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_MessageBoxColor {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColor() {
    assert_eq!(::std::mem::size_of::<SDL_MessageBoxColor>() , 3usize , concat
               ! ( "Size of: " , stringify ! ( SDL_MessageBoxColor ) ));
    assert_eq! (::std::mem::align_of::<SDL_MessageBoxColor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_MessageBoxColor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxColor ) ) . r as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MessageBoxColor ) ,
                "::" , stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxColor ) ) . g as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MessageBoxColor ) ,
                "::" , stringify ! ( g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxColor ) ) . b as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MessageBoxColor ) ,
                "::" , stringify ! ( b ) ));
}
impl Clone for SDL_MessageBoxColor {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_MessageBoxColorType {
    SDL_MESSAGEBOX_COLOR_BACKGROUND = 0,
    SDL_MESSAGEBOX_COLOR_TEXT = 1,
    SDL_MESSAGEBOX_COLOR_BUTTON_BORDER = 2,
    SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND = 3,
    SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED = 4,
    SDL_MESSAGEBOX_COLOR_MAX = 5,
}
/// \brief A set of colors to use for message box dialogs
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_MessageBoxColorScheme {
    pub colors: [SDL_MessageBoxColor; 5usize],
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColorScheme() {
    assert_eq!(::std::mem::size_of::<SDL_MessageBoxColorScheme>() , 15usize ,
               concat ! (
               "Size of: " , stringify ! ( SDL_MessageBoxColorScheme ) ));
    assert_eq! (::std::mem::align_of::<SDL_MessageBoxColorScheme>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_MessageBoxColorScheme )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxColorScheme ) ) . colors as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                SDL_MessageBoxColorScheme ) , "::" , stringify ! ( colors )
                ));
}
impl Clone for SDL_MessageBoxColorScheme {
    fn clone(&self) -> Self { *self }
}
/// \brief MessageBox structure containing title, text, window, etc.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_MessageBoxData {
    /// < ::SDL_MessageBoxFlags
    pub flags: Uint32,
    /// < Parent window, can be NULL
    pub window: *mut SDL_Window,
    /// < UTF-8 title
    pub title: *const ::std::os::raw::c_char,
    /// < UTF-8 message text
    pub message: *const ::std::os::raw::c_char,
    pub numbuttons: ::std::os::raw::c_int,
    pub buttons: *const SDL_MessageBoxButtonData,
    /// < ::SDL_MessageBoxColorScheme, can be NULL to use system settings
    pub colorScheme: *const SDL_MessageBoxColorScheme,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxData() {
    assert_eq!(::std::mem::size_of::<SDL_MessageBoxData>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( SDL_MessageBoxData ) ));
    assert_eq! (::std::mem::align_of::<SDL_MessageBoxData>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( SDL_MessageBoxData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxData ) ) . flags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MessageBoxData ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxData ) ) . window as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MessageBoxData ) ,
                "::" , stringify ! ( window ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxData ) ) . title as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MessageBoxData ) ,
                "::" , stringify ! ( title ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxData ) ) . message as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MessageBoxData ) ,
                "::" , stringify ! ( message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxData ) ) . numbuttons as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MessageBoxData ) ,
                "::" , stringify ! ( numbuttons ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxData ) ) . buttons as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MessageBoxData ) ,
                "::" , stringify ! ( buttons ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_MessageBoxData ) ) . colorScheme as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_MessageBoxData ) ,
                "::" , stringify ! ( colorScheme ) ));
}
impl Clone for SDL_MessageBoxData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// \brief Create a modal message box.
///
/// \param messageboxdata The SDL_MessageBoxData structure with title, text, etc.
/// \param buttonid The pointer to which user id of hit button should be copied.
///
/// \return -1 on error, otherwise 0 and buttonid contains user id of button
/// hit or -1 if dialog was closed.
///
/// \note This function should be called on the thread that created the parent
/// window, or on the main thread if the messagebox has no parent.  It will
/// block execution of that thread until the user clicks a button or
/// closes the messagebox.
    pub fn SDL_ShowMessageBox(messageboxdata: *const SDL_MessageBoxData,
                              buttonid: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Create a simple modal message box
///
/// \param flags    ::SDL_MessageBoxFlags
/// \param title    UTF-8 title text
/// \param message  UTF-8 message text
/// \param window   The parent window, or NULL for no parent
///
/// \return 0 on success, -1 on error
///
/// \sa SDL_ShowMessageBox
    pub fn SDL_ShowSimpleMessageBox(flags: Uint32,
                                    title: *const ::std::os::raw::c_char,
                                    message: *const ::std::os::raw::c_char,
                                    window: *mut SDL_Window)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
/// \brief The basic state for the system's power supply.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_PowerState {
    SDL_POWERSTATE_UNKNOWN = 0,
    SDL_POWERSTATE_ON_BATTERY = 1,
    SDL_POWERSTATE_NO_BATTERY = 2,
    SDL_POWERSTATE_CHARGING = 3,
    SDL_POWERSTATE_CHARGED = 4,
}
extern "C" {
    /// \brief Get the current power supply details.
///
/// \param secs Seconds of battery life left. You can pass a NULL here if
/// you don't care. Will return -1 if we can't determine a
/// value, or we're not running on a battery.
///
/// \param pct Percentage of battery life left, between 0 and 100. You can
/// pass a NULL here if you don't care. Will return -1 if we
/// can't determine a value, or we're not running on a battery.
///
/// \return The state of the battery (if any).
    pub fn SDL_GetPowerInfo(secs: *mut ::std::os::raw::c_int,
                            pct: *mut ::std::os::raw::c_int)
     -> SDL_PowerState;
}
#[repr(u32)]
/// \brief Flags used when creating a rendering context
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_RendererFlags {
    SDL_RENDERER_SOFTWARE = 1,
    SDL_RENDERER_ACCELERATED = 2,
    SDL_RENDERER_PRESENTVSYNC = 4,
    SDL_RENDERER_TARGETTEXTURE = 8,
}
/// \brief Information on the capabilities of a render driver or context.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_RendererInfo {
    /// < The name of the renderer
    pub name: *const ::std::os::raw::c_char,
    /// < Supported ::SDL_RendererFlags
    pub flags: Uint32,
    /// < The number of available texture formats
    pub num_texture_formats: Uint32,
    /// < The available texture formats
    pub texture_formats: [Uint32; 16usize],
    /// < The maximum texture width
    pub max_texture_width: ::std::os::raw::c_int,
    /// < The maximum texture height
    pub max_texture_height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SDL_RendererInfo() {
    assert_eq!(::std::mem::size_of::<SDL_RendererInfo>() , 88usize , concat !
               ( "Size of: " , stringify ! ( SDL_RendererInfo ) ));
    assert_eq! (::std::mem::align_of::<SDL_RendererInfo>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( SDL_RendererInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RendererInfo ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RendererInfo ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RendererInfo ) ) . flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RendererInfo ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RendererInfo ) ) .
                num_texture_formats as * const _ as usize } , 12usize , concat
                ! (
                "Alignment of field: " , stringify ! ( SDL_RendererInfo ) ,
                "::" , stringify ! ( num_texture_formats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RendererInfo ) ) . texture_formats as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RendererInfo ) ,
                "::" , stringify ! ( texture_formats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RendererInfo ) ) . max_texture_width
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RendererInfo ) ,
                "::" , stringify ! ( max_texture_width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_RendererInfo ) ) . max_texture_height
                as * const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_RendererInfo ) ,
                "::" , stringify ! ( max_texture_height ) ));
}
impl Clone for SDL_RendererInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// \brief The access pattern allowed for a texture.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_TextureAccess {
    SDL_TEXTUREACCESS_STATIC = 0,
    SDL_TEXTUREACCESS_STREAMING = 1,
    SDL_TEXTUREACCESS_TARGET = 2,
}
#[repr(u32)]
/// \brief The texture channel modulation used in SDL_RenderCopy().
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_TextureModulate {
    SDL_TEXTUREMODULATE_NONE = 0,
    SDL_TEXTUREMODULATE_COLOR = 1,
    SDL_TEXTUREMODULATE_ALPHA = 2,
}
#[repr(u32)]
/// \brief Flip constants for SDL_RenderCopyEx
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SDL_RendererFlip {
    SDL_FLIP_NONE = 0,
    SDL_FLIP_HORIZONTAL = 1,
    SDL_FLIP_VERTICAL = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Renderer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Texture {
    _unused: [u8; 0],
}
extern "C" {
    /// \brief Get the number of 2D rendering drivers available for the current
/// display.
///
/// A render driver is a set of code that handles rendering and texture
/// management on a particular display.  Normally there is only one, but
/// some drivers may have several available with different capabilities.
///
/// \sa SDL_GetRenderDriverInfo()
/// \sa SDL_CreateRenderer()
    pub fn SDL_GetNumRenderDrivers() -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get information about a specific 2D rendering driver for the current
/// display.
///
/// \param index The index of the driver to query information about.
/// \param info  A pointer to an SDL_RendererInfo struct to be filled with
/// information on the rendering driver.
///
/// \return 0 on success, -1 if the index was out of range.
///
/// \sa SDL_CreateRenderer()
    pub fn SDL_GetRenderDriverInfo(index: ::std::os::raw::c_int,
                                   info: *mut SDL_RendererInfo)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Create a window and default renderer
///
/// \param width    The width of the window
/// \param height   The height of the window
/// \param window_flags The flags used to create the window
/// \param window   A pointer filled with the window, or NULL on error
/// \param renderer A pointer filled with the renderer, or NULL on error
///
/// \return 0 on success, or -1 on error
    pub fn SDL_CreateWindowAndRenderer(width: ::std::os::raw::c_int,
                                       height: ::std::os::raw::c_int,
                                       window_flags: Uint32,
                                       window: *mut *mut SDL_Window,
                                       renderer: *mut *mut SDL_Renderer)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Create a 2D rendering context for a window.
///
/// \param window The window where rendering is displayed.
/// \param index    The index of the rendering driver to initialize, or -1 to
/// initialize the first one supporting the requested flags.
/// \param flags    ::SDL_RendererFlags.
///
/// \return A valid rendering context or NULL if there was an error.
///
/// \sa SDL_CreateSoftwareRenderer()
/// \sa SDL_GetRendererInfo()
/// \sa SDL_DestroyRenderer()
    pub fn SDL_CreateRenderer(window: *mut SDL_Window,
                              index: ::std::os::raw::c_int, flags: Uint32)
     -> *mut SDL_Renderer;
}
extern "C" {
    /// \brief Create a 2D software rendering context for a surface.
///
/// \param surface The surface where rendering is done.
///
/// \return A valid rendering context or NULL if there was an error.
///
/// \sa SDL_CreateRenderer()
/// \sa SDL_DestroyRenderer()
    pub fn SDL_CreateSoftwareRenderer(surface: *mut SDL_Surface)
     -> *mut SDL_Renderer;
}
extern "C" {
    /// \brief Get the renderer associated with a window.
    pub fn SDL_GetRenderer(window: *mut SDL_Window) -> *mut SDL_Renderer;
}
extern "C" {
    /// \brief Get information about a rendering context.
    pub fn SDL_GetRendererInfo(renderer: *mut SDL_Renderer,
                               info: *mut SDL_RendererInfo)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the output size in pixels of a rendering context.
    pub fn SDL_GetRendererOutputSize(renderer: *mut SDL_Renderer,
                                     w: *mut ::std::os::raw::c_int,
                                     h: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Create a texture for a rendering context.
///
/// \param renderer The renderer.
/// \param format The format of the texture.
/// \param access One of the enumerated values in ::SDL_TextureAccess.
/// \param w      The width of the texture in pixels.
/// \param h      The height of the texture in pixels.
///
/// \return The created texture is returned, or NULL if no rendering context was
/// active,  the format was unsupported, or the width or height were out
/// of range.
///
/// \note The contents of the texture are not defined at creation.
///
/// \sa SDL_QueryTexture()
/// \sa SDL_UpdateTexture()
/// \sa SDL_DestroyTexture()
    pub fn SDL_CreateTexture(renderer: *mut SDL_Renderer, format: Uint32,
                             access: ::std::os::raw::c_int,
                             w: ::std::os::raw::c_int,
                             h: ::std::os::raw::c_int) -> *mut SDL_Texture;
}
extern "C" {
    /// \brief Create a texture from an existing surface.
///
/// \param renderer The renderer.
/// \param surface The surface containing pixel data used to fill the texture.
///
/// \return The created texture is returned, or NULL on error.
///
/// \note The surface is not modified or freed by this function.
///
/// \sa SDL_QueryTexture()
/// \sa SDL_DestroyTexture()
    pub fn SDL_CreateTextureFromSurface(renderer: *mut SDL_Renderer,
                                        surface: *mut SDL_Surface)
     -> *mut SDL_Texture;
}
extern "C" {
    /// \brief Query the attributes of a texture
///
/// \param texture A texture to be queried.
/// \param format  A pointer filled in with the raw format of the texture.  The
/// actual format may differ, but pixel transfers will use this
/// format.
/// \param access  A pointer filled in with the actual access to the texture.
/// \param w       A pointer filled in with the width of the texture in pixels.
/// \param h       A pointer filled in with the height of the texture in pixels.
///
/// \return 0 on success, or -1 if the texture is not valid.
    pub fn SDL_QueryTexture(texture: *mut SDL_Texture, format: *mut Uint32,
                            access: *mut ::std::os::raw::c_int,
                            w: *mut ::std::os::raw::c_int,
                            h: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set an additional color value used in render copy operations.
///
/// \param texture The texture to update.
/// \param r       The red color value multiplied into copy operations.
/// \param g       The green color value multiplied into copy operations.
/// \param b       The blue color value multiplied into copy operations.
///
/// \return 0 on success, or -1 if the texture is not valid or color modulation
/// is not supported.
///
/// \sa SDL_GetTextureColorMod()
    pub fn SDL_SetTextureColorMod(texture: *mut SDL_Texture, r: Uint8,
                                  g: Uint8, b: Uint8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the additional color value used in render copy operations.
///
/// \param texture The texture to query.
/// \param r         A pointer filled in with the current red color value.
/// \param g         A pointer filled in with the current green color value.
/// \param b         A pointer filled in with the current blue color value.
///
/// \return 0 on success, or -1 if the texture is not valid.
///
/// \sa SDL_SetTextureColorMod()
    pub fn SDL_GetTextureColorMod(texture: *mut SDL_Texture, r: *mut Uint8,
                                  g: *mut Uint8, b: *mut Uint8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set an additional alpha value used in render copy operations.
///
/// \param texture The texture to update.
/// \param alpha     The alpha value multiplied into copy operations.
///
/// \return 0 on success, or -1 if the texture is not valid or alpha modulation
/// is not supported.
///
/// \sa SDL_GetTextureAlphaMod()
    pub fn SDL_SetTextureAlphaMod(texture: *mut SDL_Texture, alpha: Uint8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the additional alpha value used in render copy operations.
///
/// \param texture The texture to query.
/// \param alpha     A pointer filled in with the current alpha value.
///
/// \return 0 on success, or -1 if the texture is not valid.
///
/// \sa SDL_SetTextureAlphaMod()
    pub fn SDL_GetTextureAlphaMod(texture: *mut SDL_Texture,
                                  alpha: *mut Uint8) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set the blend mode used for texture copy operations.
///
/// \param texture The texture to update.
/// \param blendMode ::SDL_BlendMode to use for texture blending.
///
/// \return 0 on success, or -1 if the texture is not valid or the blend mode is
/// not supported.
///
/// \note If the blend mode is not supported, the closest supported mode is
/// chosen.
///
/// \sa SDL_GetTextureBlendMode()
    pub fn SDL_SetTextureBlendMode(texture: *mut SDL_Texture,
                                   blendMode: SDL_BlendMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the blend mode used for texture copy operations.
///
/// \param texture   The texture to query.
/// \param blendMode A pointer filled in with the current blend mode.
///
/// \return 0 on success, or -1 if the texture is not valid.
///
/// \sa SDL_SetTextureBlendMode()
    pub fn SDL_GetTextureBlendMode(texture: *mut SDL_Texture,
                                   blendMode: *mut SDL_BlendMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Update the given texture rectangle with new pixel data.
///
/// \param texture   The texture to update
/// \param rect      A pointer to the rectangle of pixels to update, or NULL to
/// update the entire texture.
/// \param pixels    The raw pixel data in the format of the texture.
/// \param pitch     The number of bytes in a row of pixel data, including padding between lines.
///
/// The pixel data must be in the format of the texture. The pixel format can be
/// queried with SDL_QueryTexture.
///
/// \return 0 on success, or -1 if the texture is not valid.
///
/// \note This is a fairly slow function.
    pub fn SDL_UpdateTexture(texture: *mut SDL_Texture, rect: *const SDL_Rect,
                             pixels: *const ::std::os::raw::c_void,
                             pitch: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Update a rectangle within a planar YV12 or IYUV texture with new pixel data.
///
/// \param texture   The texture to update
/// \param rect      A pointer to the rectangle of pixels to update, or NULL to
/// update the entire texture.
/// \param Yplane    The raw pixel data for the Y plane.
/// \param Ypitch    The number of bytes between rows of pixel data for the Y plane.
/// \param Uplane    The raw pixel data for the U plane.
/// \param Upitch    The number of bytes between rows of pixel data for the U plane.
/// \param Vplane    The raw pixel data for the V plane.
/// \param Vpitch    The number of bytes between rows of pixel data for the V plane.
///
/// \return 0 on success, or -1 if the texture is not valid.
///
/// \note You can use SDL_UpdateTexture() as long as your pixel data is
/// a contiguous block of Y and U/V planes in the proper order, but
/// this function is available if your pixel data is not contiguous.
    pub fn SDL_UpdateYUVTexture(texture: *mut SDL_Texture,
                                rect: *const SDL_Rect, Yplane: *const Uint8,
                                Ypitch: ::std::os::raw::c_int,
                                Uplane: *const Uint8,
                                Upitch: ::std::os::raw::c_int,
                                Vplane: *const Uint8,
                                Vpitch: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Lock a portion of the texture for write-only pixel access.
///
/// \param texture   The texture to lock for access, which was created with
/// ::SDL_TEXTUREACCESS_STREAMING.
/// \param rect      A pointer to the rectangle to lock for access. If the rect
/// is NULL, the entire texture will be locked.
/// \param pixels    This is filled in with a pointer to the locked pixels,
/// appropriately offset by the locked area.
/// \param pitch     This is filled in with the pitch of the locked pixels.
///
/// \return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING.
///
/// \sa SDL_UnlockTexture()
    pub fn SDL_LockTexture(texture: *mut SDL_Texture, rect: *const SDL_Rect,
                           pixels: *mut *mut ::std::os::raw::c_void,
                           pitch: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Unlock a texture, uploading the changes to video memory, if needed.
///
/// \sa SDL_LockTexture()
    pub fn SDL_UnlockTexture(texture: *mut SDL_Texture);
}
extern "C" {
    /// \brief Determines whether a window supports the use of render targets
///
/// \param renderer The renderer that will be checked
///
/// \return SDL_TRUE if supported, SDL_FALSE if not.
    pub fn SDL_RenderTargetSupported(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    /// \brief Set a texture as the current rendering target.
///
/// \param renderer The renderer.
/// \param texture The targeted texture, which must be created with the SDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target
///
/// \return 0 on success, or -1 on error
///
/// \sa SDL_GetRenderTarget()
    pub fn SDL_SetRenderTarget(renderer: *mut SDL_Renderer,
                               texture: *mut SDL_Texture)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the current render target or NULL for the default render target.
///
/// \return The current render target
///
/// \sa SDL_SetRenderTarget()
    pub fn SDL_GetRenderTarget(renderer: *mut SDL_Renderer)
     -> *mut SDL_Texture;
}
extern "C" {
    /// \brief Set device independent resolution for rendering
///
/// \param renderer The renderer for which resolution should be set.
/// \param w      The width of the logical resolution
/// \param h      The height of the logical resolution
///
/// This function uses the viewport and scaling functionality to allow a fixed logical
/// resolution for rendering, regardless of the actual output resolution.  If the actual
/// output resolution doesn't have the same aspect ratio the output rendering will be
/// centered within the output display.
///
/// If the output display is a window, mouse events in the window will be filtered
/// and scaled so they seem to arrive within the logical resolution.
///
/// \note If this function results in scaling or subpixel drawing by the
/// rendering backend, it will be handled using the appropriate
/// quality hints.
///
/// \sa SDL_RenderGetLogicalSize()
/// \sa SDL_RenderSetScale()
/// \sa SDL_RenderSetViewport()
    pub fn SDL_RenderSetLogicalSize(renderer: *mut SDL_Renderer,
                                    w: ::std::os::raw::c_int,
                                    h: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get device independent resolution for rendering
///
/// \param renderer The renderer from which resolution should be queried.
/// \param w      A pointer filled with the width of the logical resolution
/// \param h      A pointer filled with the height of the logical resolution
///
/// \sa SDL_RenderSetLogicalSize()
    pub fn SDL_RenderGetLogicalSize(renderer: *mut SDL_Renderer,
                                    w: *mut ::std::os::raw::c_int,
                                    h: *mut ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Set whether to force integer scales for resolution-independent rendering
///
/// \param renderer The renderer for which integer scaling should be set.
/// \param enable   Enable or disable integer scaling
///
/// This function restricts the logical viewport to integer values - that is, when
/// a resolution is between two multiples of a logical size, the viewport size is
/// rounded down to the lower multiple.
///
/// \sa SDL_RenderSetLogicalSize()
    pub fn SDL_RenderSetIntegerScale(renderer: *mut SDL_Renderer,
                                     enable: SDL_bool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get whether integer scales are forced for resolution-independent rendering
///
/// \param renderer The renderer from which integer scaling should be queried.
///
/// \sa SDL_RenderSetIntegerScale()
    pub fn SDL_RenderGetIntegerScale(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    /// \brief Set the drawing area for rendering on the current target.
///
/// \param renderer The renderer for which the drawing area should be set.
/// \param rect The rectangle representing the drawing area, or NULL to set the viewport to the entire target.
///
/// The x,y of the viewport rect represents the origin for rendering.
///
/// \return 0 on success, or -1 on error
///
/// \note If the window associated with the renderer is resized, the viewport is automatically reset.
///
/// \sa SDL_RenderGetViewport()
/// \sa SDL_RenderSetLogicalSize()
    pub fn SDL_RenderSetViewport(renderer: *mut SDL_Renderer,
                                 rect: *const SDL_Rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the drawing area for the current target.
///
/// \sa SDL_RenderSetViewport()
    pub fn SDL_RenderGetViewport(renderer: *mut SDL_Renderer,
                                 rect: *mut SDL_Rect);
}
extern "C" {
    /// \brief Set the clip rectangle for the current target.
///
/// \param renderer The renderer for which clip rectangle should be set.
/// \param rect   A pointer to the rectangle to set as the clip rectangle, or
/// NULL to disable clipping.
///
/// \return 0 on success, or -1 on error
///
/// \sa SDL_RenderGetClipRect()
    pub fn SDL_RenderSetClipRect(renderer: *mut SDL_Renderer,
                                 rect: *const SDL_Rect)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the clip rectangle for the current target.
///
/// \param renderer The renderer from which clip rectangle should be queried.
/// \param rect   A pointer filled in with the current clip rectangle, or
/// an empty rectangle if clipping is disabled.
///
/// \sa SDL_RenderSetClipRect()
    pub fn SDL_RenderGetClipRect(renderer: *mut SDL_Renderer,
                                 rect: *mut SDL_Rect);
}
extern "C" {
    /// \brief Get whether clipping is enabled on the given renderer.
///
/// \param renderer The renderer from which clip state should be queried.
///
/// \sa SDL_RenderGetClipRect()
    pub fn SDL_RenderIsClipEnabled(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    /// \brief Set the drawing scale for rendering on the current target.
///
/// \param renderer The renderer for which the drawing scale should be set.
/// \param scaleX The horizontal scaling factor
/// \param scaleY The vertical scaling factor
///
/// The drawing coordinates are scaled by the x/y scaling factors
/// before they are used by the renderer.  This allows resolution
/// independent drawing with a single coordinate system.
///
/// \note If this results in scaling or subpixel drawing by the
/// rendering backend, it will be handled using the appropriate
/// quality hints.  For best results use integer scaling factors.
///
/// \sa SDL_RenderGetScale()
/// \sa SDL_RenderSetLogicalSize()
    pub fn SDL_RenderSetScale(renderer: *mut SDL_Renderer, scaleX: f32,
                              scaleY: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the drawing scale for the current target.
///
/// \param renderer The renderer from which drawing scale should be queried.
/// \param scaleX A pointer filled in with the horizontal scaling factor
/// \param scaleY A pointer filled in with the vertical scaling factor
///
/// \sa SDL_RenderSetScale()
    pub fn SDL_RenderGetScale(renderer: *mut SDL_Renderer, scaleX: *mut f32,
                              scaleY: *mut f32);
}
extern "C" {
    /// \brief Set the color used for drawing operations (Rect, Line and Clear).
///
/// \param renderer The renderer for which drawing color should be set.
/// \param r The red value used to draw on the rendering target.
/// \param g The green value used to draw on the rendering target.
/// \param b The blue value used to draw on the rendering target.
/// \param a The alpha value used to draw on the rendering target, usually
/// ::SDL_ALPHA_OPAQUE (255).
///
/// \return 0 on success, or -1 on error
    pub fn SDL_SetRenderDrawColor(renderer: *mut SDL_Renderer, r: Uint8,
                                  g: Uint8, b: Uint8, a: Uint8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the color used for drawing operations (Rect, Line and Clear).
///
/// \param renderer The renderer from which drawing color should be queried.
/// \param r A pointer to the red value used to draw on the rendering target.
/// \param g A pointer to the green value used to draw on the rendering target.
/// \param b A pointer to the blue value used to draw on the rendering target.
/// \param a A pointer to the alpha value used to draw on the rendering target,
/// usually ::SDL_ALPHA_OPAQUE (255).
///
/// \return 0 on success, or -1 on error
    pub fn SDL_GetRenderDrawColor(renderer: *mut SDL_Renderer, r: *mut Uint8,
                                  g: *mut Uint8, b: *mut Uint8, a: *mut Uint8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set the blend mode used for drawing operations (Fill and Line).
///
/// \param renderer The renderer for which blend mode should be set.
/// \param blendMode ::SDL_BlendMode to use for blending.
///
/// \return 0 on success, or -1 on error
///
/// \note If the blend mode is not supported, the closest supported mode is
/// chosen.
///
/// \sa SDL_GetRenderDrawBlendMode()
    pub fn SDL_SetRenderDrawBlendMode(renderer: *mut SDL_Renderer,
                                      blendMode: SDL_BlendMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the blend mode used for drawing operations.
///
/// \param renderer The renderer from which blend mode should be queried.
/// \param blendMode A pointer filled in with the current blend mode.
///
/// \return 0 on success, or -1 on error
///
/// \sa SDL_SetRenderDrawBlendMode()
    pub fn SDL_GetRenderDrawBlendMode(renderer: *mut SDL_Renderer,
                                      blendMode: *mut SDL_BlendMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Clear the current rendering target with the drawing color
///
/// This function clears the entire rendering target, ignoring the viewport and
/// the clip rectangle.
///
/// \return 0 on success, or -1 on error
    pub fn SDL_RenderClear(renderer: *mut SDL_Renderer)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Draw a point on the current rendering target.
///
/// \param renderer The renderer which should draw a point.
/// \param x The x coordinate of the point.
/// \param y The y coordinate of the point.
///
/// \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawPoint(renderer: *mut SDL_Renderer,
                               x: ::std::os::raw::c_int,
                               y: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Draw multiple points on the current rendering target.
///
/// \param renderer The renderer which should draw multiple points.
/// \param points The points to draw
/// \param count The number of points to draw
///
/// \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawPoints(renderer: *mut SDL_Renderer,
                                points: *const SDL_Point,
                                count: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Draw a line on the current rendering target.
///
/// \param renderer The renderer which should draw a line.
/// \param x1 The x coordinate of the start point.
/// \param y1 The y coordinate of the start point.
/// \param x2 The x coordinate of the end point.
/// \param y2 The y coordinate of the end point.
///
/// \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawLine(renderer: *mut SDL_Renderer,
                              x1: ::std::os::raw::c_int,
                              y1: ::std::os::raw::c_int,
                              x2: ::std::os::raw::c_int,
                              y2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Draw a series of connected lines on the current rendering target.
///
/// \param renderer The renderer which should draw multiple lines.
/// \param points The points along the lines
/// \param count The number of points, drawing count-1 lines
///
/// \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawLines(renderer: *mut SDL_Renderer,
                               points: *const SDL_Point,
                               count: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Draw a rectangle on the current rendering target.
///
/// \param renderer The renderer which should draw a rectangle.
/// \param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target.
///
/// \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawRect(renderer: *mut SDL_Renderer,
                              rect: *const SDL_Rect) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Draw some number of rectangles on the current rendering target.
///
/// \param renderer The renderer which should draw multiple rectangles.
/// \param rects A pointer to an array of destination rectangles.
/// \param count The number of rectangles.
///
/// \return 0 on success, or -1 on error
    pub fn SDL_RenderDrawRects(renderer: *mut SDL_Renderer,
                               rects: *const SDL_Rect,
                               count: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Fill a rectangle on the current rendering target with the drawing color.
///
/// \param renderer The renderer which should fill a rectangle.
/// \param rect A pointer to the destination rectangle, or NULL for the entire
/// rendering target.
///
/// \return 0 on success, or -1 on error
    pub fn SDL_RenderFillRect(renderer: *mut SDL_Renderer,
                              rect: *const SDL_Rect) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Fill some number of rectangles on the current rendering target with the drawing color.
///
/// \param renderer The renderer which should fill multiple rectangles.
/// \param rects A pointer to an array of destination rectangles.
/// \param count The number of rectangles.
///
/// \return 0 on success, or -1 on error
    pub fn SDL_RenderFillRects(renderer: *mut SDL_Renderer,
                               rects: *const SDL_Rect,
                               count: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Copy a portion of the texture to the current rendering target.
///
/// \param renderer The renderer which should copy parts of a texture.
/// \param texture The source texture.
/// \param srcrect   A pointer to the source rectangle, or NULL for the entire
/// texture.
/// \param dstrect   A pointer to the destination rectangle, or NULL for the
/// entire rendering target.
///
/// \return 0 on success, or -1 on error
    pub fn SDL_RenderCopy(renderer: *mut SDL_Renderer,
                          texture: *mut SDL_Texture, srcrect: *const SDL_Rect,
                          dstrect: *const SDL_Rect) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center
///
/// \param renderer The renderer which should copy parts of a texture.
/// \param texture The source texture.
/// \param srcrect   A pointer to the source rectangle, or NULL for the entire
/// texture.
/// \param dstrect   A pointer to the destination rectangle, or NULL for the
/// entire rendering target.
/// \param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction
/// \param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2).
/// \param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture
///
/// \return 0 on success, or -1 on error
    pub fn SDL_RenderCopyEx(renderer: *mut SDL_Renderer,
                            texture: *mut SDL_Texture,
                            srcrect: *const SDL_Rect,
                            dstrect: *const SDL_Rect, angle: f64,
                            center: *const SDL_Point, flip: SDL_RendererFlip)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Read pixels from the current rendering target.
///
/// \param renderer The renderer from which pixels should be read.
/// \param rect   A pointer to the rectangle to read, or NULL for the entire
/// render target.
/// \param format The desired format of the pixel data, or 0 to use the format
/// of the rendering target
/// \param pixels A pointer to be filled in with the pixel data
/// \param pitch  The pitch of the pixels parameter.
///
/// \return 0 on success, or -1 if pixel reading is not supported.
///
/// \warning This is a very slow operation, and should not be used frequently.
    pub fn SDL_RenderReadPixels(renderer: *mut SDL_Renderer,
                                rect: *const SDL_Rect, format: Uint32,
                                pixels: *mut ::std::os::raw::c_void,
                                pitch: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Update the screen with rendering performed.
    pub fn SDL_RenderPresent(renderer: *mut SDL_Renderer);
}
extern "C" {
    /// \brief Destroy the specified texture.
///
/// \sa SDL_CreateTexture()
/// \sa SDL_CreateTextureFromSurface()
    pub fn SDL_DestroyTexture(texture: *mut SDL_Texture);
}
extern "C" {
    /// \brief Destroy the rendering context for a window and free associated
/// textures.
///
/// \sa SDL_CreateRenderer()
    pub fn SDL_DestroyRenderer(renderer: *mut SDL_Renderer);
}
extern "C" {
    /// \brief Bind the texture to the current OpenGL/ES/ES2 context for use with
/// OpenGL instructions.
///
/// \param texture  The SDL texture to bind
/// \param texw     A pointer to a float that will be filled with the texture width
/// \param texh     A pointer to a float that will be filled with the texture height
///
/// \return 0 on success, or -1 if the operation is not supported
    pub fn SDL_GL_BindTexture(texture: *mut SDL_Texture, texw: *mut f32,
                              texh: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Unbind a texture from the current OpenGL/ES/ES2 context.
///
/// \param texture  The SDL texture to unbind
///
/// \return 0 on success, or -1 if the operation is not supported
    pub fn SDL_GL_UnbindTexture(texture: *mut SDL_Texture)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Create a window that can be shaped with the specified position, dimensions, and flags.
///
/// \param title The title of the window, in UTF-8 encoding.
/// \param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or
/// ::SDL_WINDOWPOS_UNDEFINED.
/// \param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or
/// ::SDL_WINDOWPOS_UNDEFINED.
/// \param w     The width of the window.
/// \param h     The height of the window.
/// \param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with any of the following:
/// ::SDL_WINDOW_OPENGL,     ::SDL_WINDOW_INPUT_GRABBED,
/// ::SDL_WINDOW_HIDDEN,     ::SDL_WINDOW_RESIZABLE,
/// ::SDL_WINDOW_MAXIMIZED,  ::SDL_WINDOW_MINIMIZED,
/// ::SDL_WINDOW_BORDERLESS is always set, and ::SDL_WINDOW_FULLSCREEN is always unset.
///
/// \return The window created, or NULL if window creation failed.
///
/// \sa SDL_DestroyWindow()
    pub fn SDL_CreateShapedWindow(title: *const ::std::os::raw::c_char,
                                  x: ::std::os::raw::c_uint,
                                  y: ::std::os::raw::c_uint,
                                  w: ::std::os::raw::c_uint,
                                  h: ::std::os::raw::c_uint, flags: Uint32)
     -> *mut SDL_Window;
}
extern "C" {
    /// \brief Return whether the given window is a shaped window.
///
/// \param window The window to query for being shaped.
///
/// \return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if the window is unshaped or NULL.
///
/// \sa SDL_CreateShapedWindow
    pub fn SDL_IsShapedWindow(window: *const SDL_Window) -> SDL_bool;
}
#[repr(u32)]
/// \brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WindowShapeMode {
    ShapeModeDefault = 0,
    ShapeModeBinarizeAlpha = 1,
    ShapeModeReverseBinarizeAlpha = 2,
    ShapeModeColorKey = 3,
}
/// \brief A union containing parameters for shaped windows.
#[repr(C)]
#[derive(Copy)]
pub union SDL_WindowShapeParams {
    /// \brief A cutoff alpha value for binarization of the window shape's alpha channel.
    pub binarizationCutoff: Uint8,
    pub colorKey: SDL_Color,
    _bindgen_union_align: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeParams() {
    assert_eq!(::std::mem::size_of::<SDL_WindowShapeParams>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( SDL_WindowShapeParams )
               ));
    assert_eq! (::std::mem::align_of::<SDL_WindowShapeParams>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_WindowShapeParams ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowShapeParams ) ) .
                binarizationCutoff as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( SDL_WindowShapeParams )
                , "::" , stringify ! ( binarizationCutoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowShapeParams ) ) . colorKey as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowShapeParams )
                , "::" , stringify ! ( colorKey ) ));
}
impl Clone for SDL_WindowShapeParams {
    fn clone(&self) -> Self { *self }
}
/// \brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents.
#[repr(C)]
#[derive(Copy)]
pub struct SDL_WindowShapeMode {
    /// \brief The mode of these window-shape parameters.
    pub mode: WindowShapeMode,
    /// \brief Window-shape parameters.
    pub parameters: SDL_WindowShapeParams,
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeMode() {
    assert_eq!(::std::mem::size_of::<SDL_WindowShapeMode>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( SDL_WindowShapeMode ) ));
    assert_eq! (::std::mem::align_of::<SDL_WindowShapeMode>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( SDL_WindowShapeMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowShapeMode ) ) . mode as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowShapeMode ) ,
                "::" , stringify ! ( mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_WindowShapeMode ) ) . parameters as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_WindowShapeMode ) ,
                "::" , stringify ! ( parameters ) ));
}
impl Clone for SDL_WindowShapeMode {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// \brief Set the shape and parameters of a shaped window.
///
/// \param window The shaped window whose parameters should be set.
/// \param shape A surface encoding the desired shape for the window.
/// \param shape_mode The parameters to set for the shaped window.
///
/// \return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape argument, or SDL_NONSHAPEABLE_WINDOW
/// if the SDL_Window given does not reference a valid shaped window.
///
/// \sa SDL_WindowShapeMode
/// \sa SDL_GetShapedWindowMode.
    pub fn SDL_SetWindowShape(window: *mut SDL_Window,
                              shape: *mut SDL_Surface,
                              shape_mode: *mut SDL_WindowShapeMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the shape parameters of a shaped window.
///
/// \param window The shaped window whose parameters should be retrieved.
/// \param shape_mode An empty shape-mode structure to fill, or NULL to check whether the window has a shape.
///
/// \return 0 if the window has a shape and, provided shape_mode was not NULL, shape_mode has been filled with the mode
/// data, SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped window, or SDL_WINDOW_LACKS_SHAPE if
/// the SDL_Window given is a shapeable window currently lacking a shape.
///
/// \sa SDL_WindowShapeMode
/// \sa SDL_SetWindowShape
    pub fn SDL_GetShapedWindowMode(window: *mut SDL_Window,
                                   shape_mode: *mut SDL_WindowShapeMode)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Get the number of milliseconds since the SDL library initialization.
///
/// \note This value wraps if the program runs for more than ~49 days.
    pub fn SDL_GetTicks() -> Uint32;
}
extern "C" {
    /// \brief Get the current value of the high resolution counter
    pub fn SDL_GetPerformanceCounter() -> Uint64;
}
extern "C" {
    /// \brief Get the count per second of the high resolution counter
    pub fn SDL_GetPerformanceFrequency() -> Uint64;
}
extern "C" {
    /// \brief Wait a specified number of milliseconds before returning.
    pub fn SDL_Delay(ms: Uint32);
}
/// Function prototype for the timer callback function.
///
/// The callback function is passed the current timer interval and returns
/// the next timer interval.  If the returned value is the same as the one
/// passed in, the periodic alarm continues, otherwise a new alarm is
/// scheduled.  If the callback returns 0, the periodic alarm is cancelled.
pub type SDL_TimerCallback =
    ::std::option::Option<unsafe extern "C" fn(interval: Uint32,
                                               param:
                                                   *mut ::std::os::raw::c_void)
                              -> Uint32>;
/// Definition of the timer ID type.
pub type SDL_TimerID = ::std::os::raw::c_int;
extern "C" {
    /// \brief Add a new timer to the pool of timers already running.
///
/// \return A timer ID, or 0 when an error occurs.
    pub fn SDL_AddTimer(interval: Uint32, callback: SDL_TimerCallback,
                        param: *mut ::std::os::raw::c_void) -> SDL_TimerID;
}
extern "C" {
    /// \brief Remove a timer knowing its ID.
///
/// \return A boolean value indicating success or failure.
///
/// \warning It is not safe to remove a timer multiple times.
    pub fn SDL_RemoveTimer(id: SDL_TimerID) -> SDL_bool;
}
/// \brief Information the version of SDL in use.
///
/// Represents the library's version as three levels: major revision
/// (increments with massive changes, additions, and enhancements),
/// minor revision (increments with backwards-compatible changes to the
/// major revision), and patchlevel (increments with fixes to the minor
/// revision).
///
/// \sa SDL_VERSION
/// \sa SDL_GetVersion
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_version {
    /// < major version
    pub major: Uint8,
    /// < minor version
    pub minor: Uint8,
    /// < update version
    pub patch: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_version() {
    assert_eq!(::std::mem::size_of::<SDL_version>() , 3usize , concat ! (
               "Size of: " , stringify ! ( SDL_version ) ));
    assert_eq! (::std::mem::align_of::<SDL_version>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( SDL_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_version ) ) . major as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_version ) , "::" ,
                stringify ! ( major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_version ) ) . minor as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_version ) , "::" ,
                stringify ! ( minor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const SDL_version ) ) . patch as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( SDL_version ) , "::" ,
                stringify ! ( patch ) ));
}
impl Clone for SDL_version {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /// \brief Get the version of SDL that is linked against your program.
///
/// If you are linking to SDL dynamically, then it is possible that the
/// current version will be different than the version you compiled against.
/// This function returns the current version, while SDL_VERSION() is a
/// macro that tells you what version you compiled with.
///
/// \code
/// SDL_version compiled;
/// SDL_version linked;
///
/// SDL_VERSION(&compiled);
/// SDL_GetVersion(&linked);
/// printf("We compiled against SDL version %d.%d.%d ...\n",
/// compiled.major, compiled.minor, compiled.patch);
/// printf("But we linked against SDL version %d.%d.%d.\n",
/// linked.major, linked.minor, linked.patch);
/// \endcode
///
/// This function may be called safely at any time, even before SDL_Init().
///
/// \sa SDL_VERSION
    pub fn SDL_GetVersion(ver: *mut SDL_version);
}
extern "C" {
    /// \brief Get the code revision of SDL that is linked against your program.
///
/// Returns an arbitrary string (a hash value) uniquely identifying the
/// exact revision of the SDL library in use, and is only useful in comparing
/// against other revisions. It is NOT an incrementing number.
    pub fn SDL_GetRevision() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Get the revision number of SDL that is linked against your program.
///
/// Returns a number uniquely identifying the exact revision of the SDL
/// library in use. It is an incrementing number based on commits to
/// hg.libsdl.org.
    pub fn SDL_GetRevisionNumber() -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function initializes  the subsystems specified by \c flags
    pub fn SDL_Init(flags: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function initializes specific SDL subsystems
///
/// Subsystem initialization is ref-counted, you must call
/// SDL_QuitSubSystem() for each SDL_InitSubSystem() to correctly
/// shutdown a subsystem manually (or call SDL_Quit() to force shutdown).
/// If a subsystem is already loaded then this call will
/// increase the ref-count and return.
    pub fn SDL_InitSubSystem(flags: Uint32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// This function cleans up specific SDL subsystems
    pub fn SDL_QuitSubSystem(flags: Uint32);
}
extern "C" {
    /// This function returns a mask of the specified subsystems which have
/// previously been initialized.
///
/// If \c flags is 0, it returns a mask of all initialized subsystems.
    pub fn SDL_WasInit(flags: Uint32) -> Uint32;
}
extern "C" {
    /// This function cleans up all initialized subsystems. You should
/// call it upon all exit conditions.
    pub fn SDL_Quit();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
/// < Private
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SDL_BlitMap {
    pub _address: u8,
}
impl Clone for SDL_BlitMap {
    fn clone(&self) -> Self { *self }
}
